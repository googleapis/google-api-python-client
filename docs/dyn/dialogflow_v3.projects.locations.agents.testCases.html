<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="dialogflow_v3.html">Dialogflow API</a> . <a href="dialogflow_v3.projects.html">projects</a> . <a href="dialogflow_v3.projects.locations.html">locations</a> . <a href="dialogflow_v3.projects.locations.agents.html">agents</a> . <a href="dialogflow_v3.projects.locations.agents.testCases.html">testCases</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="dialogflow_v3.projects.locations.agents.testCases.results.html">results()</a></code>
</p>
<p class="firstline">Returns the results Resource.</p>

<p class="toc_element">
  <code><a href="#batchDelete">batchDelete(parent, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Batch deletes test cases.</p>
<p class="toc_element">
  <code><a href="#batchRun">batchRun(parent, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Kicks off a batch run of test cases. This method is a [long-running operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation). The returned `Operation` type has the following method-specific fields: - `metadata`: BatchRunTestCasesMetadata - `response`: BatchRunTestCasesResponse</p>
<p class="toc_element">
  <code><a href="#calculateCoverage">calculateCoverage(agent, type=None, x__xgafv=None)</a></code></p>
<p class="firstline">Calculates the test coverage for an agent.</p>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#create">create(parent, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Creates a test case for the given agent.</p>
<p class="toc_element">
  <code><a href="#export">export(parent, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Exports the test cases under the agent to a Cloud Storage bucket or a local file. Filter can be applied to export a subset of test cases. This method is a [long-running operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation). The returned `Operation` type has the following method-specific fields: - `metadata`: ExportTestCasesMetadata - `response`: ExportTestCasesResponse</p>
<p class="toc_element">
  <code><a href="#get">get(name, x__xgafv=None)</a></code></p>
<p class="firstline">Gets a test case.</p>
<p class="toc_element">
  <code><a href="#import_">import_(parent, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Imports the test cases from a Cloud Storage bucket or a local file. It always creates new test cases and won't overwrite any existing ones. The provided ID in the imported test case is neglected. This method is a [long-running operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation). The returned `Operation` type has the following method-specific fields: - `metadata`: ImportTestCasesMetadata - `response`: ImportTestCasesResponse</p>
<p class="toc_element">
  <code><a href="#list">list(parent, pageSize=None, pageToken=None, view=None, x__xgafv=None)</a></code></p>
<p class="firstline">Fetches a list of test cases for a given agent.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next()</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<p class="toc_element">
  <code><a href="#patch">patch(name, body=None, updateMask=None, x__xgafv=None)</a></code></p>
<p class="firstline">Updates the specified test case.</p>
<p class="toc_element">
  <code><a href="#run">run(name, body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Kicks off a test case run. This method is a [long-running operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation). The returned `Operation` type has the following method-specific fields: - `metadata`: RunTestCaseMetadata - `response`: RunTestCaseResponse</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="batchDelete">batchDelete(parent, body=None, x__xgafv=None)</code>
  <pre>Batch deletes test cases.

Args:
  parent: string, Required. The agent to delete test cases from. Format: `projects//locations//agents/`. (required)
  body: object, The request body.
    The object takes the form of:

{ # The request message for TestCases.BatchDeleteTestCases.
  &quot;names&quot;: [ # Required. Format of test case names: `projects//locations/ /agents//testCases/`.
    &quot;A String&quot;,
  ],
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A generic empty message that you can re-use to avoid defining duplicated empty messages in your APIs. A typical example is to use it as the request or the response type of an API method. For instance: service Foo { rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty); }
}</pre>
</div>

<div class="method">
    <code class="details" id="batchRun">batchRun(parent, body=None, x__xgafv=None)</code>
  <pre>Kicks off a batch run of test cases. This method is a [long-running operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation). The returned `Operation` type has the following method-specific fields: - `metadata`: BatchRunTestCasesMetadata - `response`: BatchRunTestCasesResponse

Args:
  parent: string, Required. Agent name. Format: `projects//locations//agents/ `. (required)
  body: object, The request body.
    The object takes the form of:

{ # The request message for TestCases.BatchRunTestCases.
  &quot;environment&quot;: &quot;A String&quot;, # Optional. If not set, draft environment is assumed. Format: `projects//locations//agents//environments/`.
  &quot;testCases&quot;: [ # Required. Format: `projects//locations//agents//testCases/`.
    &quot;A String&quot;,
  ],
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal response of the operation in case of success. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="calculateCoverage">calculateCoverage(agent, type=None, x__xgafv=None)</code>
  <pre>Calculates the test coverage for an agent.

Args:
  agent: string, Required. The agent to calculate coverage for. Format: `projects//locations//agents/`. (required)
  type: string, Required. The type of coverage requested.
    Allowed values
      COVERAGE_TYPE_UNSPECIFIED - Should never be used.
      INTENT - Intent coverage.
      PAGE_TRANSITION - Page transition coverage.
      TRANSITION_ROUTE_GROUP - Transition route group coverage.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response message for TestCases.CalculateCoverage.
  &quot;agent&quot;: &quot;A String&quot;, # The agent to calculate coverage for. Format: `projects//locations//agents/`.
  &quot;intentCoverage&quot;: { # Intent coverage represents the percentage of all possible intents in the agent that are triggered in any of a parent&#x27;s test cases. # Intent coverage.
    &quot;coverageScore&quot;: 3.14, # The percent of intents in the agent that are covered.
    &quot;intents&quot;: [ # The list of Intents present in the agent
      { # The agent&#x27;s intent.
        &quot;covered&quot;: True or False, # Whether or not the intent is covered by at least one of the agent&#x27;s test cases.
        &quot;intent&quot;: &quot;A String&quot;, # The intent full resource name
      },
    ],
  },
  &quot;routeGroupCoverage&quot;: { # Transition route group coverage represents the percentage of all possible transition routes present within any of a parent&#x27;s test cases. The results are grouped by the transition route group. # Transition route group coverage.
    &quot;coverageScore&quot;: 3.14, # The percent of transition routes in all the transition route groups that are covered.
    &quot;coverages&quot;: [ # Transition route group coverages.
      { # Coverage result message for one transition route group.
        &quot;coverageScore&quot;: 3.14, # The percent of transition routes in the transition route group that are covered.
        &quot;routeGroup&quot;: { # An TransitionRouteGroup represents a group of `TransitionRoutes` to be used by a Page. # Transition route group metadata. Only name and displayName will be set.
          &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the transition route group, unique within the flow. The display name can be no longer than 30 characters.
          &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the transition route group. TransitionRouteGroups.CreateTransitionRouteGroup populates the name automatically. Format: `projects//locations//agents//flows//transitionRouteGroups/`.
          &quot;transitionRoutes&quot;: [ # Transition routes associated with the TransitionRouteGroup.
            { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
              &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
              &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
              &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
              &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
              &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
              &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
            },
          ],
        },
        &quot;transitions&quot;: [ # The list of transition routes and coverage in the transition route group.
          { # A transition coverage in a transition route group.
            &quot;covered&quot;: True or False, # Whether or not the transition route is covered by at least one of the agent&#x27;s test cases.
            &quot;transitionRoute&quot;: { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow. # Intent route or condition route.
              &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
              &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
              &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
              &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
              &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
              &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
            },
          },
        ],
      },
    ],
  },
  &quot;transitionCoverage&quot;: { # Transition coverage represents the percentage of all possible page transitions (page-level transition routes and event handlers, excluding transition route groups) present within any of a parent&#x27;s test cases. # Transition (excluding transition route groups) coverage.
    &quot;coverageScore&quot;: 3.14, # The percent of transitions in the agent that are covered.
    &quot;transitions&quot;: [ # The list of Transitions present in the agent.
      { # A transition in a page.
        &quot;covered&quot;: True or False, # Whether or not the transition is covered by at least one of the agent&#x27;s test cases.
        &quot;eventHandler&quot;: { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow. # Event handler.
          &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text responses.
                    &quot;A String&quot;,
                  ],
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
        },
        &quot;index&quot;: 42, # The index of a transition in the transition list. Starting from 0.
        &quot;source&quot;: { # The source or target of a transition. # The start node of a transition.
          &quot;flow&quot;: { # Flows represents the conversation flows when you build your chatbot agent. A flow consists of many pages connected by the transition routes. Conversations always start with the built-in Start Flow (with an all-0 ID). Transition routes can direct the conversation session from the current flow (parent flow) to another flow (sub flow). When the sub flow is finished, Dialogflow will bring the session back to the parent flow, where the sub flow is started. Usually, when a transition route is followed by a matched intent, the intent will be &quot;consumed&quot;. This means the intent won&#x27;t activate more transition routes. However, when the followed transition route moves the conversation session into a different flow, the matched intent can be carried over and to be consumed in the target flow. # Indicates a transition to a Flow. Only some fields such as name and displayname will be set.
            &quot;description&quot;: &quot;A String&quot;, # The description of the flow. The maximum length is 500 characters. If exceeded, the request is rejected.
            &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the flow.
            &quot;eventHandlers&quot;: [ # A flow&#x27;s event handlers serve two purposes: * They are responsible for handling events (e.g. no match, webhook errors) in the flow. * They are inherited by every page&#x27;s event handlers, which can be used to handle common events regardless of the current page. Event handlers defined in the page have higher priority than those defined in the flow. Unlike transition_routes, these handlers are evaluated on a first-match basis. The first one that matches the event get executed, with the rest being ignored.
              { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
            &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the flow. Format: `projects//locations//agents//flows/`.
            &quot;nluSettings&quot;: { # Settings related to NLU. # NLU related settings of the flow.
              &quot;classificationThreshold&quot;: 3.14, # To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold. If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
              &quot;modelTrainingMode&quot;: &quot;A String&quot;, # Indicates NLU model training mode.
              &quot;modelType&quot;: &quot;A String&quot;, # Indicates the type of NLU model.
            },
            &quot;transitionRouteGroups&quot;: [ # A flow&#x27;s transition route group serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition route groups. Transition route groups defined in the page have higher priority than those defined in the flow. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
              &quot;A String&quot;,
            ],
            &quot;transitionRoutes&quot;: [ # A flow&#x27;s transition routes serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition routes and can support use cases such as the user saying &quot;help&quot; or &quot;can I talk to a human?&quot;, which can be handled in a common way regardless of the current page. Transition routes defined in the page have higher priority than those defined in the flow. TransitionRoutes are evalauted in the following order: * TransitionRoutes with intent specified. * TransitionRoutes with only condition specified. TransitionRoutes with intent specified are inherited by pages in the flow.
              { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
                &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
          },
          &quot;page&quot;: { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page). # Indicates a transition to a Page. Only some fields such as name and displayname will be set.
            &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the flow.
            &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
              &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                  &quot;cases&quot;: [ # A list of cascading if-else conditions.
                    { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                      &quot;caseContent&quot;: [ # A list of case content.
                        { # The list of messages or conditional cases to activate for this case.
                          &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                          &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                            },
                            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                              &quot;segments&quot;: [ # Segments this audio response is composed of.
                                { # Represents one segment of audio.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                },
                              ],
                            },
                            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                            },
                            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                            },
                            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                            },
                            &quot;text&quot;: { # The text response message. # Returns a text response.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;text&quot;: [ # Required. A collection of text responses.
                                &quot;A String&quot;,
                              ],
                            },
                          },
                        },
                      ],
                      &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                    },
                  ],
                },
              ],
              &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                  },
                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                      { # Represents one segment of audio.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                      },
                    ],
                  },
                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                  },
                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                  },
                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                  },
                  &quot;text&quot;: { # The text response message. # Returns a text response.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;text&quot;: [ # Required. A collection of text responses.
                      &quot;A String&quot;,
                    ],
                  },
                },
              ],
              &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
              &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                { # Setting a parameter value.
                  &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                  &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                },
              ],
              &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
              &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
            },
            &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
              { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
            &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
              &quot;parameters&quot;: [ # Parameters to collect from the user.
                { # Represents a form parameter.
                  &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
                  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
                  &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                  &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
                    &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
                      &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                        { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                          &quot;cases&quot;: [ # A list of cascading if-else conditions.
                            { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                              &quot;caseContent&quot;: [ # A list of case content.
                                { # The list of messages or conditional cases to activate for this case.
                                  &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                  &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                    },
                                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                    },
                                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                    },
                                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                                        { # Represents one segment of audio.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                        },
                                      ],
                                    },
                                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                    },
                                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                    },
                                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                    },
                                    &quot;text&quot;: { # The text response message. # Returns a text response.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;text&quot;: [ # Required. A collection of text responses.
                                        &quot;A String&quot;,
                                      ],
                                    },
                                  },
                                },
                              ],
                              &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                            },
                          ],
                        },
                      ],
                      &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                        { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      ],
                      &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                      &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                        { # Setting a parameter value.
                          &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                          &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                        },
                      ],
                      &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                      &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                    },
                    &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
                      { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                        &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                        &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                        &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                        &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                        &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                          &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                            { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                              &quot;cases&quot;: [ # A list of cascading if-else conditions.
                                { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                                  &quot;caseContent&quot;: [ # A list of case content.
                                    { # The list of messages or conditional cases to activate for this case.
                                      &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                      &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                          },
                                        },
                                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                        },
                                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                          },
                                        },
                                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                                            { # Represents one segment of audio.
                                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                            },
                                          ],
                                        },
                                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                        },
                                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                        },
                                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                        },
                                        &quot;text&quot;: { # The text response message. # Returns a text response.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;text&quot;: [ # Required. A collection of text responses.
                                            &quot;A String&quot;,
                                          ],
                                        },
                                      },
                                    },
                                  ],
                                  &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                                },
                              ],
                            },
                          ],
                          &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                            { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          ],
                          &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                          &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                            { # Setting a parameter value.
                              &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                              &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                            },
                          ],
                          &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                          &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                        },
                      },
                    ],
                  },
                  &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                  &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
                  &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
                },
              ],
            },
            &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
            &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
              &quot;A String&quot;,
            ],
            &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
              { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
                &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
          },
        },
        &quot;target&quot;: { # The source or target of a transition. # The end node of a transition.
          &quot;flow&quot;: { # Flows represents the conversation flows when you build your chatbot agent. A flow consists of many pages connected by the transition routes. Conversations always start with the built-in Start Flow (with an all-0 ID). Transition routes can direct the conversation session from the current flow (parent flow) to another flow (sub flow). When the sub flow is finished, Dialogflow will bring the session back to the parent flow, where the sub flow is started. Usually, when a transition route is followed by a matched intent, the intent will be &quot;consumed&quot;. This means the intent won&#x27;t activate more transition routes. However, when the followed transition route moves the conversation session into a different flow, the matched intent can be carried over and to be consumed in the target flow. # Indicates a transition to a Flow. Only some fields such as name and displayname will be set.
            &quot;description&quot;: &quot;A String&quot;, # The description of the flow. The maximum length is 500 characters. If exceeded, the request is rejected.
            &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the flow.
            &quot;eventHandlers&quot;: [ # A flow&#x27;s event handlers serve two purposes: * They are responsible for handling events (e.g. no match, webhook errors) in the flow. * They are inherited by every page&#x27;s event handlers, which can be used to handle common events regardless of the current page. Event handlers defined in the page have higher priority than those defined in the flow. Unlike transition_routes, these handlers are evaluated on a first-match basis. The first one that matches the event get executed, with the rest being ignored.
              { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
            &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the flow. Format: `projects//locations//agents//flows/`.
            &quot;nluSettings&quot;: { # Settings related to NLU. # NLU related settings of the flow.
              &quot;classificationThreshold&quot;: 3.14, # To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold. If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
              &quot;modelTrainingMode&quot;: &quot;A String&quot;, # Indicates NLU model training mode.
              &quot;modelType&quot;: &quot;A String&quot;, # Indicates the type of NLU model.
            },
            &quot;transitionRouteGroups&quot;: [ # A flow&#x27;s transition route group serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition route groups. Transition route groups defined in the page have higher priority than those defined in the flow. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
              &quot;A String&quot;,
            ],
            &quot;transitionRoutes&quot;: [ # A flow&#x27;s transition routes serve two purposes: * They are responsible for matching the user&#x27;s first utterances in the flow. * They are inherited by every page&#x27;s transition routes and can support use cases such as the user saying &quot;help&quot; or &quot;can I talk to a human?&quot;, which can be handled in a common way regardless of the current page. Transition routes defined in the page have higher priority than those defined in the flow. TransitionRoutes are evalauted in the following order: * TransitionRoutes with intent specified. * TransitionRoutes with only condition specified. TransitionRoutes with intent specified are inherited by pages in the flow.
              { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
                &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
          },
          &quot;page&quot;: { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page). # Indicates a transition to a Page. Only some fields such as name and displayname will be set.
            &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the flow.
            &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
              &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                  &quot;cases&quot;: [ # A list of cascading if-else conditions.
                    { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                      &quot;caseContent&quot;: [ # A list of case content.
                        { # The list of messages or conditional cases to activate for this case.
                          &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                          &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                            },
                            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                              &quot;segments&quot;: [ # Segments this audio response is composed of.
                                { # Represents one segment of audio.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                },
                              ],
                            },
                            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                            },
                            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                            },
                            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                            },
                            &quot;text&quot;: { # The text response message. # Returns a text response.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;text&quot;: [ # Required. A collection of text responses.
                                &quot;A String&quot;,
                              ],
                            },
                          },
                        },
                      ],
                      &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                    },
                  ],
                },
              ],
              &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                  },
                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                      { # Represents one segment of audio.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                      },
                    ],
                  },
                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                  },
                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                  },
                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                  },
                  &quot;text&quot;: { # The text response message. # Returns a text response.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;text&quot;: [ # Required. A collection of text responses.
                      &quot;A String&quot;,
                    ],
                  },
                },
              ],
              &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
              &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                { # Setting a parameter value.
                  &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                  &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                },
              ],
              &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
              &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
            },
            &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
              { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
            &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
              &quot;parameters&quot;: [ # Parameters to collect from the user.
                { # Represents a form parameter.
                  &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
                  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
                  &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                  &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
                    &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
                      &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                        { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                          &quot;cases&quot;: [ # A list of cascading if-else conditions.
                            { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                              &quot;caseContent&quot;: [ # A list of case content.
                                { # The list of messages or conditional cases to activate for this case.
                                  &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                  &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                    },
                                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                    },
                                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                    },
                                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                                        { # Represents one segment of audio.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                        },
                                      ],
                                    },
                                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                    },
                                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                    },
                                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                    },
                                    &quot;text&quot;: { # The text response message. # Returns a text response.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;text&quot;: [ # Required. A collection of text responses.
                                        &quot;A String&quot;,
                                      ],
                                    },
                                  },
                                },
                              ],
                              &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                            },
                          ],
                        },
                      ],
                      &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                        { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      ],
                      &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                      &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                        { # Setting a parameter value.
                          &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                          &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                        },
                      ],
                      &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                      &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                    },
                    &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
                      { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                        &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                        &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                        &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                        &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                        &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                          &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                            { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                              &quot;cases&quot;: [ # A list of cascading if-else conditions.
                                { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                                  &quot;caseContent&quot;: [ # A list of case content.
                                    { # The list of messages or conditional cases to activate for this case.
                                      &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                      &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                          },
                                        },
                                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                        },
                                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                          },
                                        },
                                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                                            { # Represents one segment of audio.
                                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                            },
                                          ],
                                        },
                                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                        },
                                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                        },
                                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                        },
                                        &quot;text&quot;: { # The text response message. # Returns a text response.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;text&quot;: [ # Required. A collection of text responses.
                                            &quot;A String&quot;,
                                          ],
                                        },
                                      },
                                    },
                                  ],
                                  &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                                },
                              ],
                            },
                          ],
                          &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                            { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          ],
                          &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                          &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                            { # Setting a parameter value.
                              &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                              &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                            },
                          ],
                          &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                          &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                        },
                      },
                    ],
                  },
                  &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                  &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
                  &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
                },
              ],
            },
            &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
            &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
              &quot;A String&quot;,
            ],
            &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
              { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
                &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
          },
        },
        &quot;transitionRoute&quot;: { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow. # Intent route or condition route.
          &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
          &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text responses.
                    &quot;A String&quot;,
                  ],
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
        },
      },
    ],
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="create">create(parent, body=None, x__xgafv=None)</code>
  <pre>Creates a test case for the given agent.

Args:
  parent: string, Required. The agent to create the test case for. Format: `projects//locations//agents/`. (required)
  body: object, The request body.
    The object takes the form of:

{ # Represents a test case.
  &quot;creationTime&quot;: &quot;A String&quot;, # Output only. When the test was created.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the test case, unique within the agent. Limit of 200 characters.
  &quot;lastTestResult&quot;: { # Represents a result from running a test case in an agent environment. # The latest test result.
    &quot;conversationTurns&quot;: [ # The conversation turns uttered during the test case replay in chronological order.
      { # One interaction between a human and virtual agent. The human provides some input and the virtual agent provides a response.
        &quot;userInput&quot;: { # The input from the human user. # The user input.
          &quot;enableSentimentAnalysis&quot;: True or False, # Whether sentiment analysis is enabled.
          &quot;injectedParameters&quot;: { # Parameters that need to be injected into the conversation during intent detection.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;input&quot;: { # Represents the query input. It can contain one of: 1. A conversational query in the form of text. 2. An intent query that specifies which intent to trigger. 3. Natural language speech audio to be processed. 4. An event to be triggered. # Supports text input, event input, dtmf input in the test case.
            &quot;audio&quot;: { # Represents the natural speech audio to be processed. # The natural language speech audio to be processed.
              &quot;audio&quot;: &quot;A String&quot;, # The natural language speech audio to be processed. A single request can contain up to 1 minute of speech audio data. The transcribed text cannot contain more than 256 bytes. For non-streaming audio detect intent, both `config` and `audio` must be provided. For streaming audio detect intent, `config` must be provided in the first request and `audio` must be provided in all following requests.
              &quot;config&quot;: { # Instructs the speech recognizer on how to process the audio content. # Required. Instructs the speech recognizer how to process the speech audio.
                &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the audio content to process.
                &quot;enableWordInfo&quot;: True or False, # Optional. If `true`, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words, e.g. start and end time offsets. If false or unspecified, Speech doesn&#x27;t return any word-level information.
                &quot;model&quot;: &quot;A String&quot;, # Optional. Which Speech model to select for the given request. Select the model best suited to your domain to get best results. If a model is not explicitly specified, then we auto-select a model based on the parameters in the InputAudioConfig. If enhanced speech model is enabled for the agent and an enhanced version of the specified model for the language does not exist, then the speech is recognized using the standard version of the specified model. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics#select-model) for more details.
                &quot;modelVariant&quot;: &quot;A String&quot;, # Optional. Which variant of the Speech model to use.
                &quot;phraseHints&quot;: [ # Optional. A list of strings containing words and phrases that the speech recognizer should recognize with higher likelihood. See [the Cloud Speech documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints) for more details.
                  &quot;A String&quot;,
                ],
                &quot;sampleRateHertz&quot;: 42, # Sample rate (in Hertz) of the audio content sent in the query. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics) for more details.
                &quot;singleUtterance&quot;: True or False, # Optional. If `false` (default), recognition does not cease until the client closes the stream. If `true`, the recognizer will detect a single spoken utterance in input audio. Recognition ceases when it detects the audio&#x27;s voice has stopped or paused. In this case, once a detected intent is received, the client should close the stream and start a new request with a new stream as needed. Note: This setting is relevant only for streaming methods.
              },
            },
            &quot;dtmf&quot;: { # Represents the input for dtmf event. # The DTMF event to be handled.
              &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
              &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
            },
            &quot;event&quot;: { # Represents the event to trigger. # The event to be triggered.
              &quot;event&quot;: &quot;A String&quot;, # Name of the event.
            },
            &quot;intent&quot;: { # Represents the intent to trigger programmatically rather than as a result of natural language processing. # The intent to be triggered.
              &quot;intent&quot;: &quot;A String&quot;, # Required. The unique identifier of the intent. Format: `projects//locations//agents//intents/`.
            },
            &quot;languageCode&quot;: &quot;A String&quot;, # Required. The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes. Note that queries in the same session do not necessarily need to specify the same language.
            &quot;text&quot;: { # Represents the natural language text to be processed. # The natural language text to be processed.
              &quot;text&quot;: &quot;A String&quot;, # Required. The UTF-8 encoded natural language text to be processed. Text length must not exceed 256 characters.
            },
          },
          &quot;isWebhookEnabled&quot;: True or False, # If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
        },
        &quot;virtualAgentOutput&quot;: { # The output from the virtual agent. # The virtual agent output.
          &quot;currentPage&quot;: { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page). # The Page on which the utterance was spoken. Only name and displayName will be set.
            &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the flow.
            &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
              &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                  &quot;cases&quot;: [ # A list of cascading if-else conditions.
                    { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                      &quot;caseContent&quot;: [ # A list of case content.
                        { # The list of messages or conditional cases to activate for this case.
                          &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                          &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                            },
                            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                              &quot;segments&quot;: [ # Segments this audio response is composed of.
                                { # Represents one segment of audio.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                },
                              ],
                            },
                            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                            },
                            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                            },
                            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                            },
                            &quot;text&quot;: { # The text response message. # Returns a text response.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;text&quot;: [ # Required. A collection of text responses.
                                &quot;A String&quot;,
                              ],
                            },
                          },
                        },
                      ],
                      &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                    },
                  ],
                },
              ],
              &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                  },
                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                      { # Represents one segment of audio.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                      },
                    ],
                  },
                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                  },
                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                  },
                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                  },
                  &quot;text&quot;: { # The text response message. # Returns a text response.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;text&quot;: [ # Required. A collection of text responses.
                      &quot;A String&quot;,
                    ],
                  },
                },
              ],
              &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
              &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                { # Setting a parameter value.
                  &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                  &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                },
              ],
              &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
              &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
            },
            &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
              { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
            &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
              &quot;parameters&quot;: [ # Parameters to collect from the user.
                { # Represents a form parameter.
                  &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
                  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
                  &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                  &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
                    &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
                      &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                        { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                          &quot;cases&quot;: [ # A list of cascading if-else conditions.
                            { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                              &quot;caseContent&quot;: [ # A list of case content.
                                { # The list of messages or conditional cases to activate for this case.
                                  &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                  &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                    },
                                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                    },
                                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                    },
                                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                                        { # Represents one segment of audio.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                        },
                                      ],
                                    },
                                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                    },
                                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                    },
                                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                    },
                                    &quot;text&quot;: { # The text response message. # Returns a text response.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;text&quot;: [ # Required. A collection of text responses.
                                        &quot;A String&quot;,
                                      ],
                                    },
                                  },
                                },
                              ],
                              &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                            },
                          ],
                        },
                      ],
                      &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                        { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      ],
                      &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                      &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                        { # Setting a parameter value.
                          &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                          &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                        },
                      ],
                      &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                      &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                    },
                    &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
                      { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                        &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                        &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                        &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                        &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                        &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                          &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                            { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                              &quot;cases&quot;: [ # A list of cascading if-else conditions.
                                { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                                  &quot;caseContent&quot;: [ # A list of case content.
                                    { # The list of messages or conditional cases to activate for this case.
                                      &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                      &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                          },
                                        },
                                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                        },
                                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                          },
                                        },
                                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                                            { # Represents one segment of audio.
                                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                            },
                                          ],
                                        },
                                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                        },
                                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                        },
                                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                        },
                                        &quot;text&quot;: { # The text response message. # Returns a text response.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;text&quot;: [ # Required. A collection of text responses.
                                            &quot;A String&quot;,
                                          ],
                                        },
                                      },
                                    },
                                  ],
                                  &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                                },
                              ],
                            },
                          ],
                          &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                            { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          ],
                          &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                          &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                            { # Setting a parameter value.
                              &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                              &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                            },
                          ],
                          &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                          &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                        },
                      },
                    ],
                  },
                  &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                  &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
                  &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
                },
              ],
            },
            &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
            &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
              &quot;A String&quot;,
            ],
            &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
              { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
                &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
          },
          &quot;diagnosticInfo&quot;: { # Required. Input only. The diagnostic info output for the turn. Required to calculate the testing coverage.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;differences&quot;: [ # Output only. If this is part of a result conversation turn, the list of differences between the original run and the replay for this output, if any.
            { # The description of differences between original and replayed agent output.
              &quot;description&quot;: &quot;A String&quot;, # A description of the diff, showing the actual output vs expected output.
              &quot;type&quot;: &quot;A String&quot;, # The type of diff.
            },
          ],
          &quot;sessionParameters&quot;: { # The session parameters available to the bot at this point.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Response error from the agent in the test result. If set, other output is empty.
            &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
            &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
              {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
              },
            ],
            &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
          },
          &quot;textResponses&quot;: [ # The text responses from the agent for the turn.
            { # The text response message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          ],
          &quot;triggeredIntent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that triggered the response. Only name and displayName will be set.
            &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
            &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
            &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
            &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys.contextual&quot; means the intent is a contextual intent.
              &quot;a_key&quot;: &quot;A String&quot;,
            },
            &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
            &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
              { # Represents an intent parameter.
                &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
                &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
              },
            ],
            &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
            &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
              { # Represents an example that the agent is trained on to identify the intent.
                &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
                &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
                  { # Represents a part of a training phrase.
                    &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
                    &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
                  },
                ],
                &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
              },
            ],
          },
        },
      },
    ],
    &quot;environment&quot;: &quot;A String&quot;, # Environment where the test was run. If not set, it indicates the draft environment.
    &quot;name&quot;: &quot;A String&quot;, # The resource name for the test case result. Format: `projects//locations//agents//testCases/ /results/`.
    &quot;testResult&quot;: &quot;A String&quot;, # Whether the test case passed in the agent environment.
    &quot;testTime&quot;: &quot;A String&quot;, # The time that the test was run.
  },
  &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the test case. TestCases.CreateTestCase will populate the name automatically. Otherwise use format: `projects//locations//agents/ /testCases/`.
  &quot;notes&quot;: &quot;A String&quot;, # Additional freeform notes about the test case. Limit of 400 characters.
  &quot;tags&quot;: [ # Tags are short descriptions that users may apply to test cases for organizational and filtering purposes. Each tag should start with &quot;#&quot; and has a limit of 30 characters.
    &quot;A String&quot;,
  ],
  &quot;testCaseConversationTurns&quot;: [ # The conversation turns uttered when the test case was created, in chronological order. These include the canonical set of agent utterances that should occur when the agent is working properly.
    { # One interaction between a human and virtual agent. The human provides some input and the virtual agent provides a response.
      &quot;userInput&quot;: { # The input from the human user. # The user input.
        &quot;enableSentimentAnalysis&quot;: True or False, # Whether sentiment analysis is enabled.
        &quot;injectedParameters&quot;: { # Parameters that need to be injected into the conversation during intent detection.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;input&quot;: { # Represents the query input. It can contain one of: 1. A conversational query in the form of text. 2. An intent query that specifies which intent to trigger. 3. Natural language speech audio to be processed. 4. An event to be triggered. # Supports text input, event input, dtmf input in the test case.
          &quot;audio&quot;: { # Represents the natural speech audio to be processed. # The natural language speech audio to be processed.
            &quot;audio&quot;: &quot;A String&quot;, # The natural language speech audio to be processed. A single request can contain up to 1 minute of speech audio data. The transcribed text cannot contain more than 256 bytes. For non-streaming audio detect intent, both `config` and `audio` must be provided. For streaming audio detect intent, `config` must be provided in the first request and `audio` must be provided in all following requests.
            &quot;config&quot;: { # Instructs the speech recognizer on how to process the audio content. # Required. Instructs the speech recognizer how to process the speech audio.
              &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the audio content to process.
              &quot;enableWordInfo&quot;: True or False, # Optional. If `true`, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words, e.g. start and end time offsets. If false or unspecified, Speech doesn&#x27;t return any word-level information.
              &quot;model&quot;: &quot;A String&quot;, # Optional. Which Speech model to select for the given request. Select the model best suited to your domain to get best results. If a model is not explicitly specified, then we auto-select a model based on the parameters in the InputAudioConfig. If enhanced speech model is enabled for the agent and an enhanced version of the specified model for the language does not exist, then the speech is recognized using the standard version of the specified model. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics#select-model) for more details.
              &quot;modelVariant&quot;: &quot;A String&quot;, # Optional. Which variant of the Speech model to use.
              &quot;phraseHints&quot;: [ # Optional. A list of strings containing words and phrases that the speech recognizer should recognize with higher likelihood. See [the Cloud Speech documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints) for more details.
                &quot;A String&quot;,
              ],
              &quot;sampleRateHertz&quot;: 42, # Sample rate (in Hertz) of the audio content sent in the query. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics) for more details.
              &quot;singleUtterance&quot;: True or False, # Optional. If `false` (default), recognition does not cease until the client closes the stream. If `true`, the recognizer will detect a single spoken utterance in input audio. Recognition ceases when it detects the audio&#x27;s voice has stopped or paused. In this case, once a detected intent is received, the client should close the stream and start a new request with a new stream as needed. Note: This setting is relevant only for streaming methods.
            },
          },
          &quot;dtmf&quot;: { # Represents the input for dtmf event. # The DTMF event to be handled.
            &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
            &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
          },
          &quot;event&quot;: { # Represents the event to trigger. # The event to be triggered.
            &quot;event&quot;: &quot;A String&quot;, # Name of the event.
          },
          &quot;intent&quot;: { # Represents the intent to trigger programmatically rather than as a result of natural language processing. # The intent to be triggered.
            &quot;intent&quot;: &quot;A String&quot;, # Required. The unique identifier of the intent. Format: `projects//locations//agents//intents/`.
          },
          &quot;languageCode&quot;: &quot;A String&quot;, # Required. The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes. Note that queries in the same session do not necessarily need to specify the same language.
          &quot;text&quot;: { # Represents the natural language text to be processed. # The natural language text to be processed.
            &quot;text&quot;: &quot;A String&quot;, # Required. The UTF-8 encoded natural language text to be processed. Text length must not exceed 256 characters.
          },
        },
        &quot;isWebhookEnabled&quot;: True or False, # If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
      },
      &quot;virtualAgentOutput&quot;: { # The output from the virtual agent. # The virtual agent output.
        &quot;currentPage&quot;: { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page). # The Page on which the utterance was spoken. Only name and displayName will be set.
          &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the flow.
          &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text responses.
                    &quot;A String&quot;,
                  ],
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
          &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
            { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
              &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
              &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
              &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
              &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
              &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
            },
          ],
          &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
            &quot;parameters&quot;: [ # Parameters to collect from the user.
              { # Represents a form parameter.
                &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
                &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
                &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
                  &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
                    &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                      { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                        &quot;cases&quot;: [ # A list of cascading if-else conditions.
                          { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                            &quot;caseContent&quot;: [ # A list of case content.
                              { # The list of messages or conditional cases to activate for this case.
                                &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                  },
                                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                                      { # Represents one segment of audio.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                      },
                                    ],
                                  },
                                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                  },
                                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                  },
                                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                  },
                                  &quot;text&quot;: { # The text response message. # Returns a text response.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;text&quot;: [ # Required. A collection of text responses.
                                      &quot;A String&quot;,
                                    ],
                                  },
                                },
                              },
                            ],
                            &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                          },
                        ],
                      },
                    ],
                    &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text responses.
                            &quot;A String&quot;,
                          ],
                        },
                      },
                    ],
                    &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                    &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                      { # Setting a parameter value.
                        &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                        &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                      },
                    ],
                    &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                    &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                  },
                  &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
                    { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                      &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                            &quot;cases&quot;: [ # A list of cascading if-else conditions.
                              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                                &quot;caseContent&quot;: [ # A list of case content.
                                  { # The list of messages or conditional cases to activate for this case.
                                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                      },
                                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                      },
                                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                      },
                                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                                          { # Represents one segment of audio.
                                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                          },
                                        ],
                                      },
                                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                      },
                                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                      },
                                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                      },
                                      &quot;text&quot;: { # The text response message. # Returns a text response.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                        &quot;text&quot;: [ # Required. A collection of text responses.
                                          &quot;A String&quot;,
                                        ],
                                      },
                                    },
                                  },
                                ],
                                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                              },
                            ],
                          },
                        ],
                        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                            },
                            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                              &quot;segments&quot;: [ # Segments this audio response is composed of.
                                { # Represents one segment of audio.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                },
                              ],
                            },
                            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                            },
                            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                            },
                            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                            },
                            &quot;text&quot;: { # The text response message. # Returns a text response.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;text&quot;: [ # Required. A collection of text responses.
                                &quot;A String&quot;,
                              ],
                            },
                          },
                        ],
                        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                          { # Setting a parameter value.
                            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                          },
                        ],
                        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                      },
                    },
                  ],
                },
                &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
                &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
              },
            ],
          },
          &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
          &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
            &quot;A String&quot;,
          ],
          &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
            { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
              &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
              &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
              &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
              &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
              &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
              &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
            },
          ],
        },
        &quot;diagnosticInfo&quot;: { # Required. Input only. The diagnostic info output for the turn. Required to calculate the testing coverage.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;differences&quot;: [ # Output only. If this is part of a result conversation turn, the list of differences between the original run and the replay for this output, if any.
          { # The description of differences between original and replayed agent output.
            &quot;description&quot;: &quot;A String&quot;, # A description of the diff, showing the actual output vs expected output.
            &quot;type&quot;: &quot;A String&quot;, # The type of diff.
          },
        ],
        &quot;sessionParameters&quot;: { # The session parameters available to the bot at this point.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Response error from the agent in the test result. If set, other output is empty.
          &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
          &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
            {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
            },
          ],
          &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        },
        &quot;textResponses&quot;: [ # The text responses from the agent for the turn.
          { # The text response message.
            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
            &quot;text&quot;: [ # Required. A collection of text responses.
              &quot;A String&quot;,
            ],
          },
        ],
        &quot;triggeredIntent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that triggered the response. Only name and displayName will be set.
          &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
          &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
          &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
          &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys.contextual&quot; means the intent is a contextual intent.
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
          &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
            { # Represents an intent parameter.
              &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
              &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
              &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
              &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
            },
          ],
          &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
          &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
            { # Represents an example that the agent is trained on to identify the intent.
              &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
              &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
                { # Represents a part of a training phrase.
                  &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
                  &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
                },
              ],
              &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
            },
          ],
        },
      },
    },
  ],
  &quot;testConfig&quot;: { # Represents configurations for a test case. # Config for the test case.
    &quot;flow&quot;: &quot;A String&quot;, # Flow name to start the test case with. Format: `projects//locations//agents//flows/`. Only one of `flow` and `page` should be set to indicate the starting point of the test case. If both are set, `page` takes precedence over `flow`. If neither is set, the test case will start with start page on the default start flow.
    &quot;page&quot;: &quot;A String&quot;, # The page to start the test case with. Format: `projects//locations//agents//flows//pages/`. Only one of `flow` and `page` should be set to indicate the starting point of the test case. If both are set, `page` takes precedence over `flow`. If neither is set, the test case will start with start page on the default start flow.
    &quot;trackingParameters&quot;: [ # Session parameters to be compared when calculating differences.
      &quot;A String&quot;,
    ],
  },
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Represents a test case.
  &quot;creationTime&quot;: &quot;A String&quot;, # Output only. When the test was created.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the test case, unique within the agent. Limit of 200 characters.
  &quot;lastTestResult&quot;: { # Represents a result from running a test case in an agent environment. # The latest test result.
    &quot;conversationTurns&quot;: [ # The conversation turns uttered during the test case replay in chronological order.
      { # One interaction between a human and virtual agent. The human provides some input and the virtual agent provides a response.
        &quot;userInput&quot;: { # The input from the human user. # The user input.
          &quot;enableSentimentAnalysis&quot;: True or False, # Whether sentiment analysis is enabled.
          &quot;injectedParameters&quot;: { # Parameters that need to be injected into the conversation during intent detection.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;input&quot;: { # Represents the query input. It can contain one of: 1. A conversational query in the form of text. 2. An intent query that specifies which intent to trigger. 3. Natural language speech audio to be processed. 4. An event to be triggered. # Supports text input, event input, dtmf input in the test case.
            &quot;audio&quot;: { # Represents the natural speech audio to be processed. # The natural language speech audio to be processed.
              &quot;audio&quot;: &quot;A String&quot;, # The natural language speech audio to be processed. A single request can contain up to 1 minute of speech audio data. The transcribed text cannot contain more than 256 bytes. For non-streaming audio detect intent, both `config` and `audio` must be provided. For streaming audio detect intent, `config` must be provided in the first request and `audio` must be provided in all following requests.
              &quot;config&quot;: { # Instructs the speech recognizer on how to process the audio content. # Required. Instructs the speech recognizer how to process the speech audio.
                &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the audio content to process.
                &quot;enableWordInfo&quot;: True or False, # Optional. If `true`, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words, e.g. start and end time offsets. If false or unspecified, Speech doesn&#x27;t return any word-level information.
                &quot;model&quot;: &quot;A String&quot;, # Optional. Which Speech model to select for the given request. Select the model best suited to your domain to get best results. If a model is not explicitly specified, then we auto-select a model based on the parameters in the InputAudioConfig. If enhanced speech model is enabled for the agent and an enhanced version of the specified model for the language does not exist, then the speech is recognized using the standard version of the specified model. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics#select-model) for more details.
                &quot;modelVariant&quot;: &quot;A String&quot;, # Optional. Which variant of the Speech model to use.
                &quot;phraseHints&quot;: [ # Optional. A list of strings containing words and phrases that the speech recognizer should recognize with higher likelihood. See [the Cloud Speech documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints) for more details.
                  &quot;A String&quot;,
                ],
                &quot;sampleRateHertz&quot;: 42, # Sample rate (in Hertz) of the audio content sent in the query. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics) for more details.
                &quot;singleUtterance&quot;: True or False, # Optional. If `false` (default), recognition does not cease until the client closes the stream. If `true`, the recognizer will detect a single spoken utterance in input audio. Recognition ceases when it detects the audio&#x27;s voice has stopped or paused. In this case, once a detected intent is received, the client should close the stream and start a new request with a new stream as needed. Note: This setting is relevant only for streaming methods.
              },
            },
            &quot;dtmf&quot;: { # Represents the input for dtmf event. # The DTMF event to be handled.
              &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
              &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
            },
            &quot;event&quot;: { # Represents the event to trigger. # The event to be triggered.
              &quot;event&quot;: &quot;A String&quot;, # Name of the event.
            },
            &quot;intent&quot;: { # Represents the intent to trigger programmatically rather than as a result of natural language processing. # The intent to be triggered.
              &quot;intent&quot;: &quot;A String&quot;, # Required. The unique identifier of the intent. Format: `projects//locations//agents//intents/`.
            },
            &quot;languageCode&quot;: &quot;A String&quot;, # Required. The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes. Note that queries in the same session do not necessarily need to specify the same language.
            &quot;text&quot;: { # Represents the natural language text to be processed. # The natural language text to be processed.
              &quot;text&quot;: &quot;A String&quot;, # Required. The UTF-8 encoded natural language text to be processed. Text length must not exceed 256 characters.
            },
          },
          &quot;isWebhookEnabled&quot;: True or False, # If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
        },
        &quot;virtualAgentOutput&quot;: { # The output from the virtual agent. # The virtual agent output.
          &quot;currentPage&quot;: { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page). # The Page on which the utterance was spoken. Only name and displayName will be set.
            &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the flow.
            &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
              &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                  &quot;cases&quot;: [ # A list of cascading if-else conditions.
                    { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                      &quot;caseContent&quot;: [ # A list of case content.
                        { # The list of messages or conditional cases to activate for this case.
                          &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                          &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                            },
                            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                              &quot;segments&quot;: [ # Segments this audio response is composed of.
                                { # Represents one segment of audio.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                },
                              ],
                            },
                            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                            },
                            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                            },
                            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                            },
                            &quot;text&quot;: { # The text response message. # Returns a text response.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;text&quot;: [ # Required. A collection of text responses.
                                &quot;A String&quot;,
                              ],
                            },
                          },
                        },
                      ],
                      &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                    },
                  ],
                },
              ],
              &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                  },
                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                      { # Represents one segment of audio.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                      },
                    ],
                  },
                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                  },
                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                  },
                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                  },
                  &quot;text&quot;: { # The text response message. # Returns a text response.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;text&quot;: [ # Required. A collection of text responses.
                      &quot;A String&quot;,
                    ],
                  },
                },
              ],
              &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
              &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                { # Setting a parameter value.
                  &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                  &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                },
              ],
              &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
              &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
            },
            &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
              { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
            &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
              &quot;parameters&quot;: [ # Parameters to collect from the user.
                { # Represents a form parameter.
                  &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
                  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
                  &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                  &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
                    &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
                      &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                        { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                          &quot;cases&quot;: [ # A list of cascading if-else conditions.
                            { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                              &quot;caseContent&quot;: [ # A list of case content.
                                { # The list of messages or conditional cases to activate for this case.
                                  &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                  &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                    },
                                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                    },
                                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                    },
                                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                                        { # Represents one segment of audio.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                        },
                                      ],
                                    },
                                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                    },
                                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                    },
                                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                    },
                                    &quot;text&quot;: { # The text response message. # Returns a text response.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;text&quot;: [ # Required. A collection of text responses.
                                        &quot;A String&quot;,
                                      ],
                                    },
                                  },
                                },
                              ],
                              &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                            },
                          ],
                        },
                      ],
                      &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                        { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      ],
                      &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                      &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                        { # Setting a parameter value.
                          &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                          &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                        },
                      ],
                      &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                      &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                    },
                    &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
                      { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                        &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                        &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                        &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                        &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                        &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                          &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                            { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                              &quot;cases&quot;: [ # A list of cascading if-else conditions.
                                { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                                  &quot;caseContent&quot;: [ # A list of case content.
                                    { # The list of messages or conditional cases to activate for this case.
                                      &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                      &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                          },
                                        },
                                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                        },
                                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                          },
                                        },
                                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                                            { # Represents one segment of audio.
                                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                            },
                                          ],
                                        },
                                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                        },
                                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                        },
                                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                        },
                                        &quot;text&quot;: { # The text response message. # Returns a text response.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;text&quot;: [ # Required. A collection of text responses.
                                            &quot;A String&quot;,
                                          ],
                                        },
                                      },
                                    },
                                  ],
                                  &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                                },
                              ],
                            },
                          ],
                          &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                            { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          ],
                          &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                          &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                            { # Setting a parameter value.
                              &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                              &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                            },
                          ],
                          &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                          &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                        },
                      },
                    ],
                  },
                  &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                  &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
                  &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
                },
              ],
            },
            &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
            &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
              &quot;A String&quot;,
            ],
            &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
              { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
                &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
          },
          &quot;diagnosticInfo&quot;: { # Required. Input only. The diagnostic info output for the turn. Required to calculate the testing coverage.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;differences&quot;: [ # Output only. If this is part of a result conversation turn, the list of differences between the original run and the replay for this output, if any.
            { # The description of differences between original and replayed agent output.
              &quot;description&quot;: &quot;A String&quot;, # A description of the diff, showing the actual output vs expected output.
              &quot;type&quot;: &quot;A String&quot;, # The type of diff.
            },
          ],
          &quot;sessionParameters&quot;: { # The session parameters available to the bot at this point.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Response error from the agent in the test result. If set, other output is empty.
            &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
            &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
              {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
              },
            ],
            &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
          },
          &quot;textResponses&quot;: [ # The text responses from the agent for the turn.
            { # The text response message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          ],
          &quot;triggeredIntent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that triggered the response. Only name and displayName will be set.
            &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
            &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
            &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
            &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys.contextual&quot; means the intent is a contextual intent.
              &quot;a_key&quot;: &quot;A String&quot;,
            },
            &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
            &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
              { # Represents an intent parameter.
                &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
                &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
              },
            ],
            &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
            &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
              { # Represents an example that the agent is trained on to identify the intent.
                &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
                &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
                  { # Represents a part of a training phrase.
                    &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
                    &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
                  },
                ],
                &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
              },
            ],
          },
        },
      },
    ],
    &quot;environment&quot;: &quot;A String&quot;, # Environment where the test was run. If not set, it indicates the draft environment.
    &quot;name&quot;: &quot;A String&quot;, # The resource name for the test case result. Format: `projects//locations//agents//testCases/ /results/`.
    &quot;testResult&quot;: &quot;A String&quot;, # Whether the test case passed in the agent environment.
    &quot;testTime&quot;: &quot;A String&quot;, # The time that the test was run.
  },
  &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the test case. TestCases.CreateTestCase will populate the name automatically. Otherwise use format: `projects//locations//agents/ /testCases/`.
  &quot;notes&quot;: &quot;A String&quot;, # Additional freeform notes about the test case. Limit of 400 characters.
  &quot;tags&quot;: [ # Tags are short descriptions that users may apply to test cases for organizational and filtering purposes. Each tag should start with &quot;#&quot; and has a limit of 30 characters.
    &quot;A String&quot;,
  ],
  &quot;testCaseConversationTurns&quot;: [ # The conversation turns uttered when the test case was created, in chronological order. These include the canonical set of agent utterances that should occur when the agent is working properly.
    { # One interaction between a human and virtual agent. The human provides some input and the virtual agent provides a response.
      &quot;userInput&quot;: { # The input from the human user. # The user input.
        &quot;enableSentimentAnalysis&quot;: True or False, # Whether sentiment analysis is enabled.
        &quot;injectedParameters&quot;: { # Parameters that need to be injected into the conversation during intent detection.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;input&quot;: { # Represents the query input. It can contain one of: 1. A conversational query in the form of text. 2. An intent query that specifies which intent to trigger. 3. Natural language speech audio to be processed. 4. An event to be triggered. # Supports text input, event input, dtmf input in the test case.
          &quot;audio&quot;: { # Represents the natural speech audio to be processed. # The natural language speech audio to be processed.
            &quot;audio&quot;: &quot;A String&quot;, # The natural language speech audio to be processed. A single request can contain up to 1 minute of speech audio data. The transcribed text cannot contain more than 256 bytes. For non-streaming audio detect intent, both `config` and `audio` must be provided. For streaming audio detect intent, `config` must be provided in the first request and `audio` must be provided in all following requests.
            &quot;config&quot;: { # Instructs the speech recognizer on how to process the audio content. # Required. Instructs the speech recognizer how to process the speech audio.
              &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the audio content to process.
              &quot;enableWordInfo&quot;: True or False, # Optional. If `true`, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words, e.g. start and end time offsets. If false or unspecified, Speech doesn&#x27;t return any word-level information.
              &quot;model&quot;: &quot;A String&quot;, # Optional. Which Speech model to select for the given request. Select the model best suited to your domain to get best results. If a model is not explicitly specified, then we auto-select a model based on the parameters in the InputAudioConfig. If enhanced speech model is enabled for the agent and an enhanced version of the specified model for the language does not exist, then the speech is recognized using the standard version of the specified model. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics#select-model) for more details.
              &quot;modelVariant&quot;: &quot;A String&quot;, # Optional. Which variant of the Speech model to use.
              &quot;phraseHints&quot;: [ # Optional. A list of strings containing words and phrases that the speech recognizer should recognize with higher likelihood. See [the Cloud Speech documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints) for more details.
                &quot;A String&quot;,
              ],
              &quot;sampleRateHertz&quot;: 42, # Sample rate (in Hertz) of the audio content sent in the query. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics) for more details.
              &quot;singleUtterance&quot;: True or False, # Optional. If `false` (default), recognition does not cease until the client closes the stream. If `true`, the recognizer will detect a single spoken utterance in input audio. Recognition ceases when it detects the audio&#x27;s voice has stopped or paused. In this case, once a detected intent is received, the client should close the stream and start a new request with a new stream as needed. Note: This setting is relevant only for streaming methods.
            },
          },
          &quot;dtmf&quot;: { # Represents the input for dtmf event. # The DTMF event to be handled.
            &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
            &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
          },
          &quot;event&quot;: { # Represents the event to trigger. # The event to be triggered.
            &quot;event&quot;: &quot;A String&quot;, # Name of the event.
          },
          &quot;intent&quot;: { # Represents the intent to trigger programmatically rather than as a result of natural language processing. # The intent to be triggered.
            &quot;intent&quot;: &quot;A String&quot;, # Required. The unique identifier of the intent. Format: `projects//locations//agents//intents/`.
          },
          &quot;languageCode&quot;: &quot;A String&quot;, # Required. The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes. Note that queries in the same session do not necessarily need to specify the same language.
          &quot;text&quot;: { # Represents the natural language text to be processed. # The natural language text to be processed.
            &quot;text&quot;: &quot;A String&quot;, # Required. The UTF-8 encoded natural language text to be processed. Text length must not exceed 256 characters.
          },
        },
        &quot;isWebhookEnabled&quot;: True or False, # If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
      },
      &quot;virtualAgentOutput&quot;: { # The output from the virtual agent. # The virtual agent output.
        &quot;currentPage&quot;: { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page). # The Page on which the utterance was spoken. Only name and displayName will be set.
          &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the flow.
          &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text responses.
                    &quot;A String&quot;,
                  ],
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
          &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
            { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
              &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
              &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
              &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
              &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
              &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
            },
          ],
          &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
            &quot;parameters&quot;: [ # Parameters to collect from the user.
              { # Represents a form parameter.
                &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
                &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
                &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
                  &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
                    &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                      { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                        &quot;cases&quot;: [ # A list of cascading if-else conditions.
                          { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                            &quot;caseContent&quot;: [ # A list of case content.
                              { # The list of messages or conditional cases to activate for this case.
                                &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                  },
                                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                                      { # Represents one segment of audio.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                      },
                                    ],
                                  },
                                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                  },
                                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                  },
                                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                  },
                                  &quot;text&quot;: { # The text response message. # Returns a text response.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;text&quot;: [ # Required. A collection of text responses.
                                      &quot;A String&quot;,
                                    ],
                                  },
                                },
                              },
                            ],
                            &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                          },
                        ],
                      },
                    ],
                    &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text responses.
                            &quot;A String&quot;,
                          ],
                        },
                      },
                    ],
                    &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                    &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                      { # Setting a parameter value.
                        &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                        &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                      },
                    ],
                    &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                    &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                  },
                  &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
                    { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                      &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                            &quot;cases&quot;: [ # A list of cascading if-else conditions.
                              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                                &quot;caseContent&quot;: [ # A list of case content.
                                  { # The list of messages or conditional cases to activate for this case.
                                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                      },
                                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                      },
                                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                      },
                                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                                          { # Represents one segment of audio.
                                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                          },
                                        ],
                                      },
                                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                      },
                                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                      },
                                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                      },
                                      &quot;text&quot;: { # The text response message. # Returns a text response.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                        &quot;text&quot;: [ # Required. A collection of text responses.
                                          &quot;A String&quot;,
                                        ],
                                      },
                                    },
                                  },
                                ],
                                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                              },
                            ],
                          },
                        ],
                        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                            },
                            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                              &quot;segments&quot;: [ # Segments this audio response is composed of.
                                { # Represents one segment of audio.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                },
                              ],
                            },
                            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                            },
                            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                            },
                            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                            },
                            &quot;text&quot;: { # The text response message. # Returns a text response.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;text&quot;: [ # Required. A collection of text responses.
                                &quot;A String&quot;,
                              ],
                            },
                          },
                        ],
                        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                          { # Setting a parameter value.
                            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                          },
                        ],
                        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                      },
                    },
                  ],
                },
                &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
                &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
              },
            ],
          },
          &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
          &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
            &quot;A String&quot;,
          ],
          &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
            { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
              &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
              &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
              &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
              &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
              &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
              &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
            },
          ],
        },
        &quot;diagnosticInfo&quot;: { # Required. Input only. The diagnostic info output for the turn. Required to calculate the testing coverage.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;differences&quot;: [ # Output only. If this is part of a result conversation turn, the list of differences between the original run and the replay for this output, if any.
          { # The description of differences between original and replayed agent output.
            &quot;description&quot;: &quot;A String&quot;, # A description of the diff, showing the actual output vs expected output.
            &quot;type&quot;: &quot;A String&quot;, # The type of diff.
          },
        ],
        &quot;sessionParameters&quot;: { # The session parameters available to the bot at this point.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Response error from the agent in the test result. If set, other output is empty.
          &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
          &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
            {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
            },
          ],
          &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        },
        &quot;textResponses&quot;: [ # The text responses from the agent for the turn.
          { # The text response message.
            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
            &quot;text&quot;: [ # Required. A collection of text responses.
              &quot;A String&quot;,
            ],
          },
        ],
        &quot;triggeredIntent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that triggered the response. Only name and displayName will be set.
          &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
          &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
          &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
          &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys.contextual&quot; means the intent is a contextual intent.
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
          &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
            { # Represents an intent parameter.
              &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
              &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
              &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
              &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
            },
          ],
          &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
          &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
            { # Represents an example that the agent is trained on to identify the intent.
              &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
              &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
                { # Represents a part of a training phrase.
                  &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
                  &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
                },
              ],
              &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
            },
          ],
        },
      },
    },
  ],
  &quot;testConfig&quot;: { # Represents configurations for a test case. # Config for the test case.
    &quot;flow&quot;: &quot;A String&quot;, # Flow name to start the test case with. Format: `projects//locations//agents//flows/`. Only one of `flow` and `page` should be set to indicate the starting point of the test case. If both are set, `page` takes precedence over `flow`. If neither is set, the test case will start with start page on the default start flow.
    &quot;page&quot;: &quot;A String&quot;, # The page to start the test case with. Format: `projects//locations//agents//flows//pages/`. Only one of `flow` and `page` should be set to indicate the starting point of the test case. If both are set, `page` takes precedence over `flow`. If neither is set, the test case will start with start page on the default start flow.
    &quot;trackingParameters&quot;: [ # Session parameters to be compared when calculating differences.
      &quot;A String&quot;,
    ],
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="export">export(parent, body=None, x__xgafv=None)</code>
  <pre>Exports the test cases under the agent to a Cloud Storage bucket or a local file. Filter can be applied to export a subset of test cases. This method is a [long-running operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation). The returned `Operation` type has the following method-specific fields: - `metadata`: ExportTestCasesMetadata - `response`: ExportTestCasesResponse

Args:
  parent: string, Required. The agent where to export test cases from. Format: `projects//locations//agents/`. (required)
  body: object, The request body.
    The object takes the form of:

{ # The request message for TestCases.ExportTestCases.
  &quot;dataFormat&quot;: &quot;A String&quot;, # The data format of the exported test cases. If not specified, `BLOB` is assumed.
  &quot;filter&quot;: &quot;A String&quot;, # The filter expression used to filter exported test cases, see [API Filtering](https://aip.dev/160). The expression is case insensitive and supports the following syntax: name = [OR name = ] ... For example: * &quot;name = t1 OR name = t2&quot; matches the test case with the exact resource name &quot;t1&quot; or &quot;t2&quot;.
  &quot;gcsUri&quot;: &quot;A String&quot;, # The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI to export the test cases to. The format of this URI must be `gs:///`. If unspecified, the serialized test cases is returned inline. Dialogflow performs a write operation for the Cloud Storage object on the caller&#x27;s behalf, so your request authentication must have write permissions for the object. For more information, see [Dialogflow access control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal response of the operation in case of success. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="get">get(name, x__xgafv=None)</code>
  <pre>Gets a test case.

Args:
  name: string, Required. The name of the testcase. Format: `projects//locations//agents//testCases/`. (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Represents a test case.
  &quot;creationTime&quot;: &quot;A String&quot;, # Output only. When the test was created.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the test case, unique within the agent. Limit of 200 characters.
  &quot;lastTestResult&quot;: { # Represents a result from running a test case in an agent environment. # The latest test result.
    &quot;conversationTurns&quot;: [ # The conversation turns uttered during the test case replay in chronological order.
      { # One interaction between a human and virtual agent. The human provides some input and the virtual agent provides a response.
        &quot;userInput&quot;: { # The input from the human user. # The user input.
          &quot;enableSentimentAnalysis&quot;: True or False, # Whether sentiment analysis is enabled.
          &quot;injectedParameters&quot;: { # Parameters that need to be injected into the conversation during intent detection.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;input&quot;: { # Represents the query input. It can contain one of: 1. A conversational query in the form of text. 2. An intent query that specifies which intent to trigger. 3. Natural language speech audio to be processed. 4. An event to be triggered. # Supports text input, event input, dtmf input in the test case.
            &quot;audio&quot;: { # Represents the natural speech audio to be processed. # The natural language speech audio to be processed.
              &quot;audio&quot;: &quot;A String&quot;, # The natural language speech audio to be processed. A single request can contain up to 1 minute of speech audio data. The transcribed text cannot contain more than 256 bytes. For non-streaming audio detect intent, both `config` and `audio` must be provided. For streaming audio detect intent, `config` must be provided in the first request and `audio` must be provided in all following requests.
              &quot;config&quot;: { # Instructs the speech recognizer on how to process the audio content. # Required. Instructs the speech recognizer how to process the speech audio.
                &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the audio content to process.
                &quot;enableWordInfo&quot;: True or False, # Optional. If `true`, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words, e.g. start and end time offsets. If false or unspecified, Speech doesn&#x27;t return any word-level information.
                &quot;model&quot;: &quot;A String&quot;, # Optional. Which Speech model to select for the given request. Select the model best suited to your domain to get best results. If a model is not explicitly specified, then we auto-select a model based on the parameters in the InputAudioConfig. If enhanced speech model is enabled for the agent and an enhanced version of the specified model for the language does not exist, then the speech is recognized using the standard version of the specified model. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics#select-model) for more details.
                &quot;modelVariant&quot;: &quot;A String&quot;, # Optional. Which variant of the Speech model to use.
                &quot;phraseHints&quot;: [ # Optional. A list of strings containing words and phrases that the speech recognizer should recognize with higher likelihood. See [the Cloud Speech documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints) for more details.
                  &quot;A String&quot;,
                ],
                &quot;sampleRateHertz&quot;: 42, # Sample rate (in Hertz) of the audio content sent in the query. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics) for more details.
                &quot;singleUtterance&quot;: True or False, # Optional. If `false` (default), recognition does not cease until the client closes the stream. If `true`, the recognizer will detect a single spoken utterance in input audio. Recognition ceases when it detects the audio&#x27;s voice has stopped or paused. In this case, once a detected intent is received, the client should close the stream and start a new request with a new stream as needed. Note: This setting is relevant only for streaming methods.
              },
            },
            &quot;dtmf&quot;: { # Represents the input for dtmf event. # The DTMF event to be handled.
              &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
              &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
            },
            &quot;event&quot;: { # Represents the event to trigger. # The event to be triggered.
              &quot;event&quot;: &quot;A String&quot;, # Name of the event.
            },
            &quot;intent&quot;: { # Represents the intent to trigger programmatically rather than as a result of natural language processing. # The intent to be triggered.
              &quot;intent&quot;: &quot;A String&quot;, # Required. The unique identifier of the intent. Format: `projects//locations//agents//intents/`.
            },
            &quot;languageCode&quot;: &quot;A String&quot;, # Required. The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes. Note that queries in the same session do not necessarily need to specify the same language.
            &quot;text&quot;: { # Represents the natural language text to be processed. # The natural language text to be processed.
              &quot;text&quot;: &quot;A String&quot;, # Required. The UTF-8 encoded natural language text to be processed. Text length must not exceed 256 characters.
            },
          },
          &quot;isWebhookEnabled&quot;: True or False, # If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
        },
        &quot;virtualAgentOutput&quot;: { # The output from the virtual agent. # The virtual agent output.
          &quot;currentPage&quot;: { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page). # The Page on which the utterance was spoken. Only name and displayName will be set.
            &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the flow.
            &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
              &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                  &quot;cases&quot;: [ # A list of cascading if-else conditions.
                    { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                      &quot;caseContent&quot;: [ # A list of case content.
                        { # The list of messages or conditional cases to activate for this case.
                          &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                          &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                            },
                            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                              &quot;segments&quot;: [ # Segments this audio response is composed of.
                                { # Represents one segment of audio.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                },
                              ],
                            },
                            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                            },
                            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                            },
                            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                            },
                            &quot;text&quot;: { # The text response message. # Returns a text response.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;text&quot;: [ # Required. A collection of text responses.
                                &quot;A String&quot;,
                              ],
                            },
                          },
                        },
                      ],
                      &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                    },
                  ],
                },
              ],
              &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                  },
                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                      { # Represents one segment of audio.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                      },
                    ],
                  },
                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                  },
                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                  },
                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                  },
                  &quot;text&quot;: { # The text response message. # Returns a text response.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;text&quot;: [ # Required. A collection of text responses.
                      &quot;A String&quot;,
                    ],
                  },
                },
              ],
              &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
              &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                { # Setting a parameter value.
                  &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                  &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                },
              ],
              &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
              &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
            },
            &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
              { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
            &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
              &quot;parameters&quot;: [ # Parameters to collect from the user.
                { # Represents a form parameter.
                  &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
                  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
                  &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                  &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
                    &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
                      &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                        { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                          &quot;cases&quot;: [ # A list of cascading if-else conditions.
                            { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                              &quot;caseContent&quot;: [ # A list of case content.
                                { # The list of messages or conditional cases to activate for this case.
                                  &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                  &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                    },
                                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                    },
                                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                    },
                                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                                        { # Represents one segment of audio.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                        },
                                      ],
                                    },
                                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                    },
                                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                    },
                                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                    },
                                    &quot;text&quot;: { # The text response message. # Returns a text response.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;text&quot;: [ # Required. A collection of text responses.
                                        &quot;A String&quot;,
                                      ],
                                    },
                                  },
                                },
                              ],
                              &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                            },
                          ],
                        },
                      ],
                      &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                        { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      ],
                      &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                      &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                        { # Setting a parameter value.
                          &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                          &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                        },
                      ],
                      &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                      &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                    },
                    &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
                      { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                        &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                        &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                        &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                        &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                        &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                          &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                            { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                              &quot;cases&quot;: [ # A list of cascading if-else conditions.
                                { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                                  &quot;caseContent&quot;: [ # A list of case content.
                                    { # The list of messages or conditional cases to activate for this case.
                                      &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                      &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                          },
                                        },
                                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                        },
                                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                          },
                                        },
                                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                                            { # Represents one segment of audio.
                                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                            },
                                          ],
                                        },
                                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                        },
                                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                        },
                                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                        },
                                        &quot;text&quot;: { # The text response message. # Returns a text response.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;text&quot;: [ # Required. A collection of text responses.
                                            &quot;A String&quot;,
                                          ],
                                        },
                                      },
                                    },
                                  ],
                                  &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                                },
                              ],
                            },
                          ],
                          &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                            { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          ],
                          &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                          &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                            { # Setting a parameter value.
                              &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                              &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                            },
                          ],
                          &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                          &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                        },
                      },
                    ],
                  },
                  &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                  &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
                  &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
                },
              ],
            },
            &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
            &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
              &quot;A String&quot;,
            ],
            &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
              { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
                &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
          },
          &quot;diagnosticInfo&quot;: { # Required. Input only. The diagnostic info output for the turn. Required to calculate the testing coverage.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;differences&quot;: [ # Output only. If this is part of a result conversation turn, the list of differences between the original run and the replay for this output, if any.
            { # The description of differences between original and replayed agent output.
              &quot;description&quot;: &quot;A String&quot;, # A description of the diff, showing the actual output vs expected output.
              &quot;type&quot;: &quot;A String&quot;, # The type of diff.
            },
          ],
          &quot;sessionParameters&quot;: { # The session parameters available to the bot at this point.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Response error from the agent in the test result. If set, other output is empty.
            &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
            &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
              {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
              },
            ],
            &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
          },
          &quot;textResponses&quot;: [ # The text responses from the agent for the turn.
            { # The text response message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          ],
          &quot;triggeredIntent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that triggered the response. Only name and displayName will be set.
            &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
            &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
            &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
            &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys.contextual&quot; means the intent is a contextual intent.
              &quot;a_key&quot;: &quot;A String&quot;,
            },
            &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
            &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
              { # Represents an intent parameter.
                &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
                &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
              },
            ],
            &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
            &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
              { # Represents an example that the agent is trained on to identify the intent.
                &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
                &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
                  { # Represents a part of a training phrase.
                    &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
                    &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
                  },
                ],
                &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
              },
            ],
          },
        },
      },
    ],
    &quot;environment&quot;: &quot;A String&quot;, # Environment where the test was run. If not set, it indicates the draft environment.
    &quot;name&quot;: &quot;A String&quot;, # The resource name for the test case result. Format: `projects//locations//agents//testCases/ /results/`.
    &quot;testResult&quot;: &quot;A String&quot;, # Whether the test case passed in the agent environment.
    &quot;testTime&quot;: &quot;A String&quot;, # The time that the test was run.
  },
  &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the test case. TestCases.CreateTestCase will populate the name automatically. Otherwise use format: `projects//locations//agents/ /testCases/`.
  &quot;notes&quot;: &quot;A String&quot;, # Additional freeform notes about the test case. Limit of 400 characters.
  &quot;tags&quot;: [ # Tags are short descriptions that users may apply to test cases for organizational and filtering purposes. Each tag should start with &quot;#&quot; and has a limit of 30 characters.
    &quot;A String&quot;,
  ],
  &quot;testCaseConversationTurns&quot;: [ # The conversation turns uttered when the test case was created, in chronological order. These include the canonical set of agent utterances that should occur when the agent is working properly.
    { # One interaction between a human and virtual agent. The human provides some input and the virtual agent provides a response.
      &quot;userInput&quot;: { # The input from the human user. # The user input.
        &quot;enableSentimentAnalysis&quot;: True or False, # Whether sentiment analysis is enabled.
        &quot;injectedParameters&quot;: { # Parameters that need to be injected into the conversation during intent detection.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;input&quot;: { # Represents the query input. It can contain one of: 1. A conversational query in the form of text. 2. An intent query that specifies which intent to trigger. 3. Natural language speech audio to be processed. 4. An event to be triggered. # Supports text input, event input, dtmf input in the test case.
          &quot;audio&quot;: { # Represents the natural speech audio to be processed. # The natural language speech audio to be processed.
            &quot;audio&quot;: &quot;A String&quot;, # The natural language speech audio to be processed. A single request can contain up to 1 minute of speech audio data. The transcribed text cannot contain more than 256 bytes. For non-streaming audio detect intent, both `config` and `audio` must be provided. For streaming audio detect intent, `config` must be provided in the first request and `audio` must be provided in all following requests.
            &quot;config&quot;: { # Instructs the speech recognizer on how to process the audio content. # Required. Instructs the speech recognizer how to process the speech audio.
              &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the audio content to process.
              &quot;enableWordInfo&quot;: True or False, # Optional. If `true`, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words, e.g. start and end time offsets. If false or unspecified, Speech doesn&#x27;t return any word-level information.
              &quot;model&quot;: &quot;A String&quot;, # Optional. Which Speech model to select for the given request. Select the model best suited to your domain to get best results. If a model is not explicitly specified, then we auto-select a model based on the parameters in the InputAudioConfig. If enhanced speech model is enabled for the agent and an enhanced version of the specified model for the language does not exist, then the speech is recognized using the standard version of the specified model. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics#select-model) for more details.
              &quot;modelVariant&quot;: &quot;A String&quot;, # Optional. Which variant of the Speech model to use.
              &quot;phraseHints&quot;: [ # Optional. A list of strings containing words and phrases that the speech recognizer should recognize with higher likelihood. See [the Cloud Speech documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints) for more details.
                &quot;A String&quot;,
              ],
              &quot;sampleRateHertz&quot;: 42, # Sample rate (in Hertz) of the audio content sent in the query. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics) for more details.
              &quot;singleUtterance&quot;: True or False, # Optional. If `false` (default), recognition does not cease until the client closes the stream. If `true`, the recognizer will detect a single spoken utterance in input audio. Recognition ceases when it detects the audio&#x27;s voice has stopped or paused. In this case, once a detected intent is received, the client should close the stream and start a new request with a new stream as needed. Note: This setting is relevant only for streaming methods.
            },
          },
          &quot;dtmf&quot;: { # Represents the input for dtmf event. # The DTMF event to be handled.
            &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
            &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
          },
          &quot;event&quot;: { # Represents the event to trigger. # The event to be triggered.
            &quot;event&quot;: &quot;A String&quot;, # Name of the event.
          },
          &quot;intent&quot;: { # Represents the intent to trigger programmatically rather than as a result of natural language processing. # The intent to be triggered.
            &quot;intent&quot;: &quot;A String&quot;, # Required. The unique identifier of the intent. Format: `projects//locations//agents//intents/`.
          },
          &quot;languageCode&quot;: &quot;A String&quot;, # Required. The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes. Note that queries in the same session do not necessarily need to specify the same language.
          &quot;text&quot;: { # Represents the natural language text to be processed. # The natural language text to be processed.
            &quot;text&quot;: &quot;A String&quot;, # Required. The UTF-8 encoded natural language text to be processed. Text length must not exceed 256 characters.
          },
        },
        &quot;isWebhookEnabled&quot;: True or False, # If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
      },
      &quot;virtualAgentOutput&quot;: { # The output from the virtual agent. # The virtual agent output.
        &quot;currentPage&quot;: { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page). # The Page on which the utterance was spoken. Only name and displayName will be set.
          &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the flow.
          &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text responses.
                    &quot;A String&quot;,
                  ],
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
          &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
            { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
              &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
              &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
              &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
              &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
              &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
            },
          ],
          &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
            &quot;parameters&quot;: [ # Parameters to collect from the user.
              { # Represents a form parameter.
                &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
                &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
                &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
                  &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
                    &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                      { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                        &quot;cases&quot;: [ # A list of cascading if-else conditions.
                          { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                            &quot;caseContent&quot;: [ # A list of case content.
                              { # The list of messages or conditional cases to activate for this case.
                                &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                  },
                                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                                      { # Represents one segment of audio.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                      },
                                    ],
                                  },
                                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                  },
                                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                  },
                                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                  },
                                  &quot;text&quot;: { # The text response message. # Returns a text response.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;text&quot;: [ # Required. A collection of text responses.
                                      &quot;A String&quot;,
                                    ],
                                  },
                                },
                              },
                            ],
                            &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                          },
                        ],
                      },
                    ],
                    &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text responses.
                            &quot;A String&quot;,
                          ],
                        },
                      },
                    ],
                    &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                    &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                      { # Setting a parameter value.
                        &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                        &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                      },
                    ],
                    &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                    &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                  },
                  &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
                    { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                      &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                            &quot;cases&quot;: [ # A list of cascading if-else conditions.
                              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                                &quot;caseContent&quot;: [ # A list of case content.
                                  { # The list of messages or conditional cases to activate for this case.
                                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                      },
                                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                      },
                                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                      },
                                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                                          { # Represents one segment of audio.
                                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                          },
                                        ],
                                      },
                                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                      },
                                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                      },
                                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                      },
                                      &quot;text&quot;: { # The text response message. # Returns a text response.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                        &quot;text&quot;: [ # Required. A collection of text responses.
                                          &quot;A String&quot;,
                                        ],
                                      },
                                    },
                                  },
                                ],
                                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                              },
                            ],
                          },
                        ],
                        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                            },
                            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                              &quot;segments&quot;: [ # Segments this audio response is composed of.
                                { # Represents one segment of audio.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                },
                              ],
                            },
                            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                            },
                            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                            },
                            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                            },
                            &quot;text&quot;: { # The text response message. # Returns a text response.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;text&quot;: [ # Required. A collection of text responses.
                                &quot;A String&quot;,
                              ],
                            },
                          },
                        ],
                        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                          { # Setting a parameter value.
                            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                          },
                        ],
                        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                      },
                    },
                  ],
                },
                &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
                &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
              },
            ],
          },
          &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
          &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
            &quot;A String&quot;,
          ],
          &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
            { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
              &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
              &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
              &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
              &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
              &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
              &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
            },
          ],
        },
        &quot;diagnosticInfo&quot;: { # Required. Input only. The diagnostic info output for the turn. Required to calculate the testing coverage.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;differences&quot;: [ # Output only. If this is part of a result conversation turn, the list of differences between the original run and the replay for this output, if any.
          { # The description of differences between original and replayed agent output.
            &quot;description&quot;: &quot;A String&quot;, # A description of the diff, showing the actual output vs expected output.
            &quot;type&quot;: &quot;A String&quot;, # The type of diff.
          },
        ],
        &quot;sessionParameters&quot;: { # The session parameters available to the bot at this point.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Response error from the agent in the test result. If set, other output is empty.
          &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
          &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
            {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
            },
          ],
          &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        },
        &quot;textResponses&quot;: [ # The text responses from the agent for the turn.
          { # The text response message.
            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
            &quot;text&quot;: [ # Required. A collection of text responses.
              &quot;A String&quot;,
            ],
          },
        ],
        &quot;triggeredIntent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that triggered the response. Only name and displayName will be set.
          &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
          &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
          &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
          &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys.contextual&quot; means the intent is a contextual intent.
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
          &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
            { # Represents an intent parameter.
              &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
              &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
              &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
              &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
            },
          ],
          &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
          &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
            { # Represents an example that the agent is trained on to identify the intent.
              &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
              &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
                { # Represents a part of a training phrase.
                  &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
                  &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
                },
              ],
              &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
            },
          ],
        },
      },
    },
  ],
  &quot;testConfig&quot;: { # Represents configurations for a test case. # Config for the test case.
    &quot;flow&quot;: &quot;A String&quot;, # Flow name to start the test case with. Format: `projects//locations//agents//flows/`. Only one of `flow` and `page` should be set to indicate the starting point of the test case. If both are set, `page` takes precedence over `flow`. If neither is set, the test case will start with start page on the default start flow.
    &quot;page&quot;: &quot;A String&quot;, # The page to start the test case with. Format: `projects//locations//agents//flows//pages/`. Only one of `flow` and `page` should be set to indicate the starting point of the test case. If both are set, `page` takes precedence over `flow`. If neither is set, the test case will start with start page on the default start flow.
    &quot;trackingParameters&quot;: [ # Session parameters to be compared when calculating differences.
      &quot;A String&quot;,
    ],
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="import_">import_(parent, body=None, x__xgafv=None)</code>
  <pre>Imports the test cases from a Cloud Storage bucket or a local file. It always creates new test cases and won&#x27;t overwrite any existing ones. The provided ID in the imported test case is neglected. This method is a [long-running operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation). The returned `Operation` type has the following method-specific fields: - `metadata`: ImportTestCasesMetadata - `response`: ImportTestCasesResponse

Args:
  parent: string, Required. The agent to import test cases to. Format: `projects//locations//agents/`. (required)
  body: object, The request body.
    The object takes the form of:

{ # The request message for TestCases.ImportTestCases.
  &quot;content&quot;: &quot;A String&quot;, # Uncompressed raw byte content for test cases.
  &quot;gcsUri&quot;: &quot;A String&quot;, # The [Google Cloud Storage](https://cloud.google.com/storage/docs/) URI to import test cases from. The format of this URI must be `gs:///`. Dialogflow performs a read operation for the Cloud Storage object on the caller&#x27;s behalf, so your request authentication must have read permissions for the object. For more information, see [Dialogflow access control](https://cloud.google.com/dialogflow/cx/docs/concept/access-control#storage).
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal response of the operation in case of success. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="list">list(parent, pageSize=None, pageToken=None, view=None, x__xgafv=None)</code>
  <pre>Fetches a list of test cases for a given agent.

Args:
  parent: string, Required. The agent to list all pages for. Format: `projects//locations//agents/`. (required)
  pageSize: integer, The maximum number of items to return in a single page. By default 20. Note that when TestCaseView = FULL, the maximum page size allowed is 20. When TestCaseView = BASIC, the maximum page size allowed is 500.
  pageToken: string, The next_page_token value returned from a previous list request.
  view: string, Specifies whether response should include all fields or just the metadata.
    Allowed values
      TEST_CASE_VIEW_UNSPECIFIED - The default / unset value. The API will default to the BASIC view.
      BASIC - Include basic metadata about the test case, but not the conversation turns. This is the default value.
      FULL - Include everything.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response message for TestCases.ListTestCases.
  &quot;nextPageToken&quot;: &quot;A String&quot;, # Token to retrieve the next page of results, or empty if there are no more results in the list.
  &quot;testCases&quot;: [ # The list of test cases. There will be a maximum number of items returned based on the page_size field in the request.
    { # Represents a test case.
      &quot;creationTime&quot;: &quot;A String&quot;, # Output only. When the test was created.
      &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the test case, unique within the agent. Limit of 200 characters.
      &quot;lastTestResult&quot;: { # Represents a result from running a test case in an agent environment. # The latest test result.
        &quot;conversationTurns&quot;: [ # The conversation turns uttered during the test case replay in chronological order.
          { # One interaction between a human and virtual agent. The human provides some input and the virtual agent provides a response.
            &quot;userInput&quot;: { # The input from the human user. # The user input.
              &quot;enableSentimentAnalysis&quot;: True or False, # Whether sentiment analysis is enabled.
              &quot;injectedParameters&quot;: { # Parameters that need to be injected into the conversation during intent detection.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;input&quot;: { # Represents the query input. It can contain one of: 1. A conversational query in the form of text. 2. An intent query that specifies which intent to trigger. 3. Natural language speech audio to be processed. 4. An event to be triggered. # Supports text input, event input, dtmf input in the test case.
                &quot;audio&quot;: { # Represents the natural speech audio to be processed. # The natural language speech audio to be processed.
                  &quot;audio&quot;: &quot;A String&quot;, # The natural language speech audio to be processed. A single request can contain up to 1 minute of speech audio data. The transcribed text cannot contain more than 256 bytes. For non-streaming audio detect intent, both `config` and `audio` must be provided. For streaming audio detect intent, `config` must be provided in the first request and `audio` must be provided in all following requests.
                  &quot;config&quot;: { # Instructs the speech recognizer on how to process the audio content. # Required. Instructs the speech recognizer how to process the speech audio.
                    &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the audio content to process.
                    &quot;enableWordInfo&quot;: True or False, # Optional. If `true`, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words, e.g. start and end time offsets. If false or unspecified, Speech doesn&#x27;t return any word-level information.
                    &quot;model&quot;: &quot;A String&quot;, # Optional. Which Speech model to select for the given request. Select the model best suited to your domain to get best results. If a model is not explicitly specified, then we auto-select a model based on the parameters in the InputAudioConfig. If enhanced speech model is enabled for the agent and an enhanced version of the specified model for the language does not exist, then the speech is recognized using the standard version of the specified model. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics#select-model) for more details.
                    &quot;modelVariant&quot;: &quot;A String&quot;, # Optional. Which variant of the Speech model to use.
                    &quot;phraseHints&quot;: [ # Optional. A list of strings containing words and phrases that the speech recognizer should recognize with higher likelihood. See [the Cloud Speech documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints) for more details.
                      &quot;A String&quot;,
                    ],
                    &quot;sampleRateHertz&quot;: 42, # Sample rate (in Hertz) of the audio content sent in the query. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics) for more details.
                    &quot;singleUtterance&quot;: True or False, # Optional. If `false` (default), recognition does not cease until the client closes the stream. If `true`, the recognizer will detect a single spoken utterance in input audio. Recognition ceases when it detects the audio&#x27;s voice has stopped or paused. In this case, once a detected intent is received, the client should close the stream and start a new request with a new stream as needed. Note: This setting is relevant only for streaming methods.
                  },
                },
                &quot;dtmf&quot;: { # Represents the input for dtmf event. # The DTMF event to be handled.
                  &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
                  &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
                },
                &quot;event&quot;: { # Represents the event to trigger. # The event to be triggered.
                  &quot;event&quot;: &quot;A String&quot;, # Name of the event.
                },
                &quot;intent&quot;: { # Represents the intent to trigger programmatically rather than as a result of natural language processing. # The intent to be triggered.
                  &quot;intent&quot;: &quot;A String&quot;, # Required. The unique identifier of the intent. Format: `projects//locations//agents//intents/`.
                },
                &quot;languageCode&quot;: &quot;A String&quot;, # Required. The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes. Note that queries in the same session do not necessarily need to specify the same language.
                &quot;text&quot;: { # Represents the natural language text to be processed. # The natural language text to be processed.
                  &quot;text&quot;: &quot;A String&quot;, # Required. The UTF-8 encoded natural language text to be processed. Text length must not exceed 256 characters.
                },
              },
              &quot;isWebhookEnabled&quot;: True or False, # If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
            },
            &quot;virtualAgentOutput&quot;: { # The output from the virtual agent. # The virtual agent output.
              &quot;currentPage&quot;: { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page). # The Page on which the utterance was spoken. Only name and displayName will be set.
                &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the flow.
                &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
                &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
                  { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                    &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                    &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                    &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                    &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                    &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                      &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                        { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                          &quot;cases&quot;: [ # A list of cascading if-else conditions.
                            { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                              &quot;caseContent&quot;: [ # A list of case content.
                                { # The list of messages or conditional cases to activate for this case.
                                  &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                  &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                    },
                                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                    },
                                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                    },
                                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                                        { # Represents one segment of audio.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                        },
                                      ],
                                    },
                                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                    },
                                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                    },
                                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                    },
                                    &quot;text&quot;: { # The text response message. # Returns a text response.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;text&quot;: [ # Required. A collection of text responses.
                                        &quot;A String&quot;,
                                      ],
                                    },
                                  },
                                },
                              ],
                              &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                            },
                          ],
                        },
                      ],
                      &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                        { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      ],
                      &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                      &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                        { # Setting a parameter value.
                          &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                          &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                        },
                      ],
                      &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                      &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                    },
                  },
                ],
                &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
                  &quot;parameters&quot;: [ # Parameters to collect from the user.
                    { # Represents a form parameter.
                      &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
                      &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
                      &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                      &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
                        &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
                          &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                            { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                              &quot;cases&quot;: [ # A list of cascading if-else conditions.
                                { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                                  &quot;caseContent&quot;: [ # A list of case content.
                                    { # The list of messages or conditional cases to activate for this case.
                                      &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                      &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                          },
                                        },
                                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                        },
                                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                          },
                                        },
                                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                                            { # Represents one segment of audio.
                                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                            },
                                          ],
                                        },
                                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                        },
                                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                        },
                                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                        },
                                        &quot;text&quot;: { # The text response message. # Returns a text response.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;text&quot;: [ # Required. A collection of text responses.
                                            &quot;A String&quot;,
                                          ],
                                        },
                                      },
                                    },
                                  ],
                                  &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                                },
                              ],
                            },
                          ],
                          &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                            { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          ],
                          &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                          &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                            { # Setting a parameter value.
                              &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                              &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                            },
                          ],
                          &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                          &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                        },
                        &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
                          { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                            &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                            &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                            &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                            &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                            &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                              &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                                { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                                  &quot;cases&quot;: [ # A list of cascading if-else conditions.
                                    { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                                      &quot;caseContent&quot;: [ # A list of case content.
                                        { # The list of messages or conditional cases to activate for this case.
                                          &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                          &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                              },
                                            },
                                            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                            },
                                            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                              },
                                            },
                                            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                              &quot;segments&quot;: [ # Segments this audio response is composed of.
                                                { # Represents one segment of audio.
                                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                                },
                                              ],
                                            },
                                            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                            },
                                            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                            },
                                            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                            },
                                            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                            },
                                            &quot;text&quot;: { # The text response message. # Returns a text response.
                                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                              &quot;text&quot;: [ # Required. A collection of text responses.
                                                &quot;A String&quot;,
                                              ],
                                            },
                                          },
                                        },
                                      ],
                                      &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                                    },
                                  ],
                                },
                              ],
                              &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                                { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                  },
                                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                                      { # Represents one segment of audio.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                      },
                                    ],
                                  },
                                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                  },
                                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                  },
                                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                  },
                                  &quot;text&quot;: { # The text response message. # Returns a text response.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;text&quot;: [ # Required. A collection of text responses.
                                      &quot;A String&quot;,
                                    ],
                                  },
                                },
                              ],
                              &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                              &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                                { # Setting a parameter value.
                                  &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                                  &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                                },
                              ],
                              &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                              &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                            },
                          },
                        ],
                      },
                      &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                      &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
                      &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
                    },
                  ],
                },
                &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
                &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
                  &quot;A String&quot;,
                ],
                &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
                  { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                    &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                    &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
                    &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                    &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                    &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
                      &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                        { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                          &quot;cases&quot;: [ # A list of cascading if-else conditions.
                            { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                              &quot;caseContent&quot;: [ # A list of case content.
                                { # The list of messages or conditional cases to activate for this case.
                                  &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                  &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                    },
                                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                    },
                                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                    },
                                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                                        { # Represents one segment of audio.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                        },
                                      ],
                                    },
                                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                    },
                                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                    },
                                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                    },
                                    &quot;text&quot;: { # The text response message. # Returns a text response.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;text&quot;: [ # Required. A collection of text responses.
                                        &quot;A String&quot;,
                                      ],
                                    },
                                  },
                                },
                              ],
                              &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                            },
                          ],
                        },
                      ],
                      &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                        { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      ],
                      &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                      &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                        { # Setting a parameter value.
                          &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                          &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                        },
                      ],
                      &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                      &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                    },
                  },
                ],
              },
              &quot;diagnosticInfo&quot;: { # Required. Input only. The diagnostic info output for the turn. Required to calculate the testing coverage.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;differences&quot;: [ # Output only. If this is part of a result conversation turn, the list of differences between the original run and the replay for this output, if any.
                { # The description of differences between original and replayed agent output.
                  &quot;description&quot;: &quot;A String&quot;, # A description of the diff, showing the actual output vs expected output.
                  &quot;type&quot;: &quot;A String&quot;, # The type of diff.
                },
              ],
              &quot;sessionParameters&quot;: { # The session parameters available to the bot at this point.
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
              },
              &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Response error from the agent in the test result. If set, other output is empty.
                &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
                &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
                  {
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                  },
                ],
                &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
              },
              &quot;textResponses&quot;: [ # The text responses from the agent for the turn.
                { # The text response message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text responses.
                    &quot;A String&quot;,
                  ],
                },
              ],
              &quot;triggeredIntent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that triggered the response. Only name and displayName will be set.
                &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
                &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
                &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
                &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys.contextual&quot; means the intent is a contextual intent.
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
                &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
                  { # Represents an intent parameter.
                    &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                    &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
                    &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                    &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
                  },
                ],
                &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
                &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
                  { # Represents an example that the agent is trained on to identify the intent.
                    &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
                    &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
                      { # Represents a part of a training phrase.
                        &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
                        &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
                      },
                    ],
                    &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
                  },
                ],
              },
            },
          },
        ],
        &quot;environment&quot;: &quot;A String&quot;, # Environment where the test was run. If not set, it indicates the draft environment.
        &quot;name&quot;: &quot;A String&quot;, # The resource name for the test case result. Format: `projects//locations//agents//testCases/ /results/`.
        &quot;testResult&quot;: &quot;A String&quot;, # Whether the test case passed in the agent environment.
        &quot;testTime&quot;: &quot;A String&quot;, # The time that the test was run.
      },
      &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the test case. TestCases.CreateTestCase will populate the name automatically. Otherwise use format: `projects//locations//agents/ /testCases/`.
      &quot;notes&quot;: &quot;A String&quot;, # Additional freeform notes about the test case. Limit of 400 characters.
      &quot;tags&quot;: [ # Tags are short descriptions that users may apply to test cases for organizational and filtering purposes. Each tag should start with &quot;#&quot; and has a limit of 30 characters.
        &quot;A String&quot;,
      ],
      &quot;testCaseConversationTurns&quot;: [ # The conversation turns uttered when the test case was created, in chronological order. These include the canonical set of agent utterances that should occur when the agent is working properly.
        { # One interaction between a human and virtual agent. The human provides some input and the virtual agent provides a response.
          &quot;userInput&quot;: { # The input from the human user. # The user input.
            &quot;enableSentimentAnalysis&quot;: True or False, # Whether sentiment analysis is enabled.
            &quot;injectedParameters&quot;: { # Parameters that need to be injected into the conversation during intent detection.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;input&quot;: { # Represents the query input. It can contain one of: 1. A conversational query in the form of text. 2. An intent query that specifies which intent to trigger. 3. Natural language speech audio to be processed. 4. An event to be triggered. # Supports text input, event input, dtmf input in the test case.
              &quot;audio&quot;: { # Represents the natural speech audio to be processed. # The natural language speech audio to be processed.
                &quot;audio&quot;: &quot;A String&quot;, # The natural language speech audio to be processed. A single request can contain up to 1 minute of speech audio data. The transcribed text cannot contain more than 256 bytes. For non-streaming audio detect intent, both `config` and `audio` must be provided. For streaming audio detect intent, `config` must be provided in the first request and `audio` must be provided in all following requests.
                &quot;config&quot;: { # Instructs the speech recognizer on how to process the audio content. # Required. Instructs the speech recognizer how to process the speech audio.
                  &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the audio content to process.
                  &quot;enableWordInfo&quot;: True or False, # Optional. If `true`, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words, e.g. start and end time offsets. If false or unspecified, Speech doesn&#x27;t return any word-level information.
                  &quot;model&quot;: &quot;A String&quot;, # Optional. Which Speech model to select for the given request. Select the model best suited to your domain to get best results. If a model is not explicitly specified, then we auto-select a model based on the parameters in the InputAudioConfig. If enhanced speech model is enabled for the agent and an enhanced version of the specified model for the language does not exist, then the speech is recognized using the standard version of the specified model. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics#select-model) for more details.
                  &quot;modelVariant&quot;: &quot;A String&quot;, # Optional. Which variant of the Speech model to use.
                  &quot;phraseHints&quot;: [ # Optional. A list of strings containing words and phrases that the speech recognizer should recognize with higher likelihood. See [the Cloud Speech documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints) for more details.
                    &quot;A String&quot;,
                  ],
                  &quot;sampleRateHertz&quot;: 42, # Sample rate (in Hertz) of the audio content sent in the query. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics) for more details.
                  &quot;singleUtterance&quot;: True or False, # Optional. If `false` (default), recognition does not cease until the client closes the stream. If `true`, the recognizer will detect a single spoken utterance in input audio. Recognition ceases when it detects the audio&#x27;s voice has stopped or paused. In this case, once a detected intent is received, the client should close the stream and start a new request with a new stream as needed. Note: This setting is relevant only for streaming methods.
                },
              },
              &quot;dtmf&quot;: { # Represents the input for dtmf event. # The DTMF event to be handled.
                &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
                &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
              },
              &quot;event&quot;: { # Represents the event to trigger. # The event to be triggered.
                &quot;event&quot;: &quot;A String&quot;, # Name of the event.
              },
              &quot;intent&quot;: { # Represents the intent to trigger programmatically rather than as a result of natural language processing. # The intent to be triggered.
                &quot;intent&quot;: &quot;A String&quot;, # Required. The unique identifier of the intent. Format: `projects//locations//agents//intents/`.
              },
              &quot;languageCode&quot;: &quot;A String&quot;, # Required. The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes. Note that queries in the same session do not necessarily need to specify the same language.
              &quot;text&quot;: { # Represents the natural language text to be processed. # The natural language text to be processed.
                &quot;text&quot;: &quot;A String&quot;, # Required. The UTF-8 encoded natural language text to be processed. Text length must not exceed 256 characters.
              },
            },
            &quot;isWebhookEnabled&quot;: True or False, # If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
          },
          &quot;virtualAgentOutput&quot;: { # The output from the virtual agent. # The virtual agent output.
            &quot;currentPage&quot;: { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page). # The Page on which the utterance was spoken. Only name and displayName will be set.
              &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the flow.
              &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
              &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
                { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                  &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                  &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                  &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                  &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                  &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                    &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                      { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                        &quot;cases&quot;: [ # A list of cascading if-else conditions.
                          { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                            &quot;caseContent&quot;: [ # A list of case content.
                              { # The list of messages or conditional cases to activate for this case.
                                &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                  },
                                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                                      { # Represents one segment of audio.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                      },
                                    ],
                                  },
                                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                  },
                                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                  },
                                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                  },
                                  &quot;text&quot;: { # The text response message. # Returns a text response.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;text&quot;: [ # Required. A collection of text responses.
                                      &quot;A String&quot;,
                                    ],
                                  },
                                },
                              },
                            ],
                            &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                          },
                        ],
                      },
                    ],
                    &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text responses.
                            &quot;A String&quot;,
                          ],
                        },
                      },
                    ],
                    &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                    &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                      { # Setting a parameter value.
                        &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                        &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                      },
                    ],
                    &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                    &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                  },
                },
              ],
              &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
                &quot;parameters&quot;: [ # Parameters to collect from the user.
                  { # Represents a form parameter.
                    &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
                    &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
                    &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                    &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
                      &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
                        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                            &quot;cases&quot;: [ # A list of cascading if-else conditions.
                              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                                &quot;caseContent&quot;: [ # A list of case content.
                                  { # The list of messages or conditional cases to activate for this case.
                                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                      },
                                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                      },
                                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                      },
                                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                                          { # Represents one segment of audio.
                                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                          },
                                        ],
                                      },
                                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                      },
                                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                      },
                                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                      },
                                      &quot;text&quot;: { # The text response message. # Returns a text response.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                        &quot;text&quot;: [ # Required. A collection of text responses.
                                          &quot;A String&quot;,
                                        ],
                                      },
                                    },
                                  },
                                ],
                                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                              },
                            ],
                          },
                        ],
                        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                            },
                            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                              &quot;segments&quot;: [ # Segments this audio response is composed of.
                                { # Represents one segment of audio.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                },
                              ],
                            },
                            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                            },
                            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                            },
                            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                            },
                            &quot;text&quot;: { # The text response message. # Returns a text response.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;text&quot;: [ # Required. A collection of text responses.
                                &quot;A String&quot;,
                              ],
                            },
                          },
                        ],
                        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                          { # Setting a parameter value.
                            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                          },
                        ],
                        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                      },
                      &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
                        { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                          &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                          &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                          &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                          &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                          &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                                    &quot;caseContent&quot;: [ # A list of case content.
                                      { # The list of messages or conditional cases to activate for this case.
                                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                            },
                                          },
                                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                          },
                                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                            },
                                          },
                                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                                              { # Represents one segment of audio.
                                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                              },
                                            ],
                                          },
                                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                          },
                                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                          },
                                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                          },
                                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                          },
                                          &quot;text&quot;: { # The text response message. # Returns a text response.
                                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                            &quot;text&quot;: [ # Required. A collection of text responses.
                                              &quot;A String&quot;,
                                            ],
                                          },
                                        },
                                      },
                                    ],
                                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                                  },
                                ],
                              },
                            ],
                            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            ],
                            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                              { # Setting a parameter value.
                                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                              },
                            ],
                            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                          },
                        },
                      ],
                    },
                    &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                    &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
                    &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
                  },
                ],
              },
              &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
              &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
                &quot;A String&quot;,
              ],
              &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
                { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
                  &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                  &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                  &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
                  &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                  &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                  &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
                    &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                      { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                        &quot;cases&quot;: [ # A list of cascading if-else conditions.
                          { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                            &quot;caseContent&quot;: [ # A list of case content.
                              { # The list of messages or conditional cases to activate for this case.
                                &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                  },
                                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                                      { # Represents one segment of audio.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                      },
                                    ],
                                  },
                                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                  },
                                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                  },
                                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                  },
                                  &quot;text&quot;: { # The text response message. # Returns a text response.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;text&quot;: [ # Required. A collection of text responses.
                                      &quot;A String&quot;,
                                    ],
                                  },
                                },
                              },
                            ],
                            &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                          },
                        ],
                      },
                    ],
                    &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text responses.
                            &quot;A String&quot;,
                          ],
                        },
                      },
                    ],
                    &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                    &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                      { # Setting a parameter value.
                        &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                        &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                      },
                    ],
                    &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                    &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                  },
                },
              ],
            },
            &quot;diagnosticInfo&quot;: { # Required. Input only. The diagnostic info output for the turn. Required to calculate the testing coverage.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;differences&quot;: [ # Output only. If this is part of a result conversation turn, the list of differences between the original run and the replay for this output, if any.
              { # The description of differences between original and replayed agent output.
                &quot;description&quot;: &quot;A String&quot;, # A description of the diff, showing the actual output vs expected output.
                &quot;type&quot;: &quot;A String&quot;, # The type of diff.
              },
            ],
            &quot;sessionParameters&quot;: { # The session parameters available to the bot at this point.
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
            },
            &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Response error from the agent in the test result. If set, other output is empty.
              &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
              &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
                {
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
                },
              ],
              &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
            },
            &quot;textResponses&quot;: [ # The text responses from the agent for the turn.
              { # The text response message.
                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                &quot;text&quot;: [ # Required. A collection of text responses.
                  &quot;A String&quot;,
                ],
              },
            ],
            &quot;triggeredIntent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that triggered the response. Only name and displayName will be set.
              &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
              &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
              &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
              &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys.contextual&quot; means the intent is a contextual intent.
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
              &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
                { # Represents an intent parameter.
                  &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                  &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
                  &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                  &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
                },
              ],
              &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
              &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
                { # Represents an example that the agent is trained on to identify the intent.
                  &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
                  &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
                    { # Represents a part of a training phrase.
                      &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
                      &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
                    },
                  ],
                  &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
                },
              ],
            },
          },
        },
      ],
      &quot;testConfig&quot;: { # Represents configurations for a test case. # Config for the test case.
        &quot;flow&quot;: &quot;A String&quot;, # Flow name to start the test case with. Format: `projects//locations//agents//flows/`. Only one of `flow` and `page` should be set to indicate the starting point of the test case. If both are set, `page` takes precedence over `flow`. If neither is set, the test case will start with start page on the default start flow.
        &quot;page&quot;: &quot;A String&quot;, # The page to start the test case with. Format: `projects//locations//agents//flows//pages/`. Only one of `flow` and `page` should be set to indicate the starting point of the test case. If both are set, `page` takes precedence over `flow`. If neither is set, the test case will start with start page on the default start flow.
        &quot;trackingParameters&quot;: [ # Session parameters to be compared when calculating differences.
          &quot;A String&quot;,
        ],
      },
    },
  ],
}</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next()</code>
  <pre>Retrieves the next page of results.

        Args:
          previous_request: The request for the previous page. (required)
          previous_response: The response from the request for the previous page. (required)

        Returns:
          A request object that you can call &#x27;execute()&#x27; on to request the next
          page. Returns None if there are no more items in the collection.
        </pre>
</div>

<div class="method">
    <code class="details" id="patch">patch(name, body=None, updateMask=None, x__xgafv=None)</code>
  <pre>Updates the specified test case.

Args:
  name: string, The unique identifier of the test case. TestCases.CreateTestCase will populate the name automatically. Otherwise use format: `projects//locations//agents/ /testCases/`. (required)
  body: object, The request body.
    The object takes the form of:

{ # Represents a test case.
  &quot;creationTime&quot;: &quot;A String&quot;, # Output only. When the test was created.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the test case, unique within the agent. Limit of 200 characters.
  &quot;lastTestResult&quot;: { # Represents a result from running a test case in an agent environment. # The latest test result.
    &quot;conversationTurns&quot;: [ # The conversation turns uttered during the test case replay in chronological order.
      { # One interaction between a human and virtual agent. The human provides some input and the virtual agent provides a response.
        &quot;userInput&quot;: { # The input from the human user. # The user input.
          &quot;enableSentimentAnalysis&quot;: True or False, # Whether sentiment analysis is enabled.
          &quot;injectedParameters&quot;: { # Parameters that need to be injected into the conversation during intent detection.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;input&quot;: { # Represents the query input. It can contain one of: 1. A conversational query in the form of text. 2. An intent query that specifies which intent to trigger. 3. Natural language speech audio to be processed. 4. An event to be triggered. # Supports text input, event input, dtmf input in the test case.
            &quot;audio&quot;: { # Represents the natural speech audio to be processed. # The natural language speech audio to be processed.
              &quot;audio&quot;: &quot;A String&quot;, # The natural language speech audio to be processed. A single request can contain up to 1 minute of speech audio data. The transcribed text cannot contain more than 256 bytes. For non-streaming audio detect intent, both `config` and `audio` must be provided. For streaming audio detect intent, `config` must be provided in the first request and `audio` must be provided in all following requests.
              &quot;config&quot;: { # Instructs the speech recognizer on how to process the audio content. # Required. Instructs the speech recognizer how to process the speech audio.
                &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the audio content to process.
                &quot;enableWordInfo&quot;: True or False, # Optional. If `true`, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words, e.g. start and end time offsets. If false or unspecified, Speech doesn&#x27;t return any word-level information.
                &quot;model&quot;: &quot;A String&quot;, # Optional. Which Speech model to select for the given request. Select the model best suited to your domain to get best results. If a model is not explicitly specified, then we auto-select a model based on the parameters in the InputAudioConfig. If enhanced speech model is enabled for the agent and an enhanced version of the specified model for the language does not exist, then the speech is recognized using the standard version of the specified model. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics#select-model) for more details.
                &quot;modelVariant&quot;: &quot;A String&quot;, # Optional. Which variant of the Speech model to use.
                &quot;phraseHints&quot;: [ # Optional. A list of strings containing words and phrases that the speech recognizer should recognize with higher likelihood. See [the Cloud Speech documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints) for more details.
                  &quot;A String&quot;,
                ],
                &quot;sampleRateHertz&quot;: 42, # Sample rate (in Hertz) of the audio content sent in the query. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics) for more details.
                &quot;singleUtterance&quot;: True or False, # Optional. If `false` (default), recognition does not cease until the client closes the stream. If `true`, the recognizer will detect a single spoken utterance in input audio. Recognition ceases when it detects the audio&#x27;s voice has stopped or paused. In this case, once a detected intent is received, the client should close the stream and start a new request with a new stream as needed. Note: This setting is relevant only for streaming methods.
              },
            },
            &quot;dtmf&quot;: { # Represents the input for dtmf event. # The DTMF event to be handled.
              &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
              &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
            },
            &quot;event&quot;: { # Represents the event to trigger. # The event to be triggered.
              &quot;event&quot;: &quot;A String&quot;, # Name of the event.
            },
            &quot;intent&quot;: { # Represents the intent to trigger programmatically rather than as a result of natural language processing. # The intent to be triggered.
              &quot;intent&quot;: &quot;A String&quot;, # Required. The unique identifier of the intent. Format: `projects//locations//agents//intents/`.
            },
            &quot;languageCode&quot;: &quot;A String&quot;, # Required. The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes. Note that queries in the same session do not necessarily need to specify the same language.
            &quot;text&quot;: { # Represents the natural language text to be processed. # The natural language text to be processed.
              &quot;text&quot;: &quot;A String&quot;, # Required. The UTF-8 encoded natural language text to be processed. Text length must not exceed 256 characters.
            },
          },
          &quot;isWebhookEnabled&quot;: True or False, # If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
        },
        &quot;virtualAgentOutput&quot;: { # The output from the virtual agent. # The virtual agent output.
          &quot;currentPage&quot;: { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page). # The Page on which the utterance was spoken. Only name and displayName will be set.
            &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the flow.
            &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
              &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                  &quot;cases&quot;: [ # A list of cascading if-else conditions.
                    { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                      &quot;caseContent&quot;: [ # A list of case content.
                        { # The list of messages or conditional cases to activate for this case.
                          &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                          &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                            },
                            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                              &quot;segments&quot;: [ # Segments this audio response is composed of.
                                { # Represents one segment of audio.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                },
                              ],
                            },
                            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                            },
                            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                            },
                            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                            },
                            &quot;text&quot;: { # The text response message. # Returns a text response.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;text&quot;: [ # Required. A collection of text responses.
                                &quot;A String&quot;,
                              ],
                            },
                          },
                        },
                      ],
                      &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                    },
                  ],
                },
              ],
              &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                  },
                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                      { # Represents one segment of audio.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                      },
                    ],
                  },
                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                  },
                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                  },
                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                  },
                  &quot;text&quot;: { # The text response message. # Returns a text response.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;text&quot;: [ # Required. A collection of text responses.
                      &quot;A String&quot;,
                    ],
                  },
                },
              ],
              &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
              &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                { # Setting a parameter value.
                  &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                  &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                },
              ],
              &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
              &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
            },
            &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
              { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
            &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
              &quot;parameters&quot;: [ # Parameters to collect from the user.
                { # Represents a form parameter.
                  &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
                  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
                  &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                  &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
                    &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
                      &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                        { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                          &quot;cases&quot;: [ # A list of cascading if-else conditions.
                            { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                              &quot;caseContent&quot;: [ # A list of case content.
                                { # The list of messages or conditional cases to activate for this case.
                                  &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                  &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                    },
                                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                    },
                                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                    },
                                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                                        { # Represents one segment of audio.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                        },
                                      ],
                                    },
                                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                    },
                                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                    },
                                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                    },
                                    &quot;text&quot;: { # The text response message. # Returns a text response.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;text&quot;: [ # Required. A collection of text responses.
                                        &quot;A String&quot;,
                                      ],
                                    },
                                  },
                                },
                              ],
                              &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                            },
                          ],
                        },
                      ],
                      &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                        { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      ],
                      &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                      &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                        { # Setting a parameter value.
                          &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                          &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                        },
                      ],
                      &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                      &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                    },
                    &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
                      { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                        &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                        &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                        &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                        &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                        &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                          &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                            { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                              &quot;cases&quot;: [ # A list of cascading if-else conditions.
                                { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                                  &quot;caseContent&quot;: [ # A list of case content.
                                    { # The list of messages or conditional cases to activate for this case.
                                      &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                      &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                          },
                                        },
                                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                        },
                                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                          },
                                        },
                                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                                            { # Represents one segment of audio.
                                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                            },
                                          ],
                                        },
                                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                        },
                                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                        },
                                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                        },
                                        &quot;text&quot;: { # The text response message. # Returns a text response.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;text&quot;: [ # Required. A collection of text responses.
                                            &quot;A String&quot;,
                                          ],
                                        },
                                      },
                                    },
                                  ],
                                  &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                                },
                              ],
                            },
                          ],
                          &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                            { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          ],
                          &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                          &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                            { # Setting a parameter value.
                              &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                              &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                            },
                          ],
                          &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                          &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                        },
                      },
                    ],
                  },
                  &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                  &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
                  &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
                },
              ],
            },
            &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
            &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
              &quot;A String&quot;,
            ],
            &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
              { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
                &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
          },
          &quot;diagnosticInfo&quot;: { # Required. Input only. The diagnostic info output for the turn. Required to calculate the testing coverage.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;differences&quot;: [ # Output only. If this is part of a result conversation turn, the list of differences between the original run and the replay for this output, if any.
            { # The description of differences between original and replayed agent output.
              &quot;description&quot;: &quot;A String&quot;, # A description of the diff, showing the actual output vs expected output.
              &quot;type&quot;: &quot;A String&quot;, # The type of diff.
            },
          ],
          &quot;sessionParameters&quot;: { # The session parameters available to the bot at this point.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Response error from the agent in the test result. If set, other output is empty.
            &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
            &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
              {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
              },
            ],
            &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
          },
          &quot;textResponses&quot;: [ # The text responses from the agent for the turn.
            { # The text response message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          ],
          &quot;triggeredIntent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that triggered the response. Only name and displayName will be set.
            &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
            &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
            &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
            &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys.contextual&quot; means the intent is a contextual intent.
              &quot;a_key&quot;: &quot;A String&quot;,
            },
            &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
            &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
              { # Represents an intent parameter.
                &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
                &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
              },
            ],
            &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
            &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
              { # Represents an example that the agent is trained on to identify the intent.
                &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
                &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
                  { # Represents a part of a training phrase.
                    &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
                    &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
                  },
                ],
                &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
              },
            ],
          },
        },
      },
    ],
    &quot;environment&quot;: &quot;A String&quot;, # Environment where the test was run. If not set, it indicates the draft environment.
    &quot;name&quot;: &quot;A String&quot;, # The resource name for the test case result. Format: `projects//locations//agents//testCases/ /results/`.
    &quot;testResult&quot;: &quot;A String&quot;, # Whether the test case passed in the agent environment.
    &quot;testTime&quot;: &quot;A String&quot;, # The time that the test was run.
  },
  &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the test case. TestCases.CreateTestCase will populate the name automatically. Otherwise use format: `projects//locations//agents/ /testCases/`.
  &quot;notes&quot;: &quot;A String&quot;, # Additional freeform notes about the test case. Limit of 400 characters.
  &quot;tags&quot;: [ # Tags are short descriptions that users may apply to test cases for organizational and filtering purposes. Each tag should start with &quot;#&quot; and has a limit of 30 characters.
    &quot;A String&quot;,
  ],
  &quot;testCaseConversationTurns&quot;: [ # The conversation turns uttered when the test case was created, in chronological order. These include the canonical set of agent utterances that should occur when the agent is working properly.
    { # One interaction between a human and virtual agent. The human provides some input and the virtual agent provides a response.
      &quot;userInput&quot;: { # The input from the human user. # The user input.
        &quot;enableSentimentAnalysis&quot;: True or False, # Whether sentiment analysis is enabled.
        &quot;injectedParameters&quot;: { # Parameters that need to be injected into the conversation during intent detection.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;input&quot;: { # Represents the query input. It can contain one of: 1. A conversational query in the form of text. 2. An intent query that specifies which intent to trigger. 3. Natural language speech audio to be processed. 4. An event to be triggered. # Supports text input, event input, dtmf input in the test case.
          &quot;audio&quot;: { # Represents the natural speech audio to be processed. # The natural language speech audio to be processed.
            &quot;audio&quot;: &quot;A String&quot;, # The natural language speech audio to be processed. A single request can contain up to 1 minute of speech audio data. The transcribed text cannot contain more than 256 bytes. For non-streaming audio detect intent, both `config` and `audio` must be provided. For streaming audio detect intent, `config` must be provided in the first request and `audio` must be provided in all following requests.
            &quot;config&quot;: { # Instructs the speech recognizer on how to process the audio content. # Required. Instructs the speech recognizer how to process the speech audio.
              &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the audio content to process.
              &quot;enableWordInfo&quot;: True or False, # Optional. If `true`, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words, e.g. start and end time offsets. If false or unspecified, Speech doesn&#x27;t return any word-level information.
              &quot;model&quot;: &quot;A String&quot;, # Optional. Which Speech model to select for the given request. Select the model best suited to your domain to get best results. If a model is not explicitly specified, then we auto-select a model based on the parameters in the InputAudioConfig. If enhanced speech model is enabled for the agent and an enhanced version of the specified model for the language does not exist, then the speech is recognized using the standard version of the specified model. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics#select-model) for more details.
              &quot;modelVariant&quot;: &quot;A String&quot;, # Optional. Which variant of the Speech model to use.
              &quot;phraseHints&quot;: [ # Optional. A list of strings containing words and phrases that the speech recognizer should recognize with higher likelihood. See [the Cloud Speech documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints) for more details.
                &quot;A String&quot;,
              ],
              &quot;sampleRateHertz&quot;: 42, # Sample rate (in Hertz) of the audio content sent in the query. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics) for more details.
              &quot;singleUtterance&quot;: True or False, # Optional. If `false` (default), recognition does not cease until the client closes the stream. If `true`, the recognizer will detect a single spoken utterance in input audio. Recognition ceases when it detects the audio&#x27;s voice has stopped or paused. In this case, once a detected intent is received, the client should close the stream and start a new request with a new stream as needed. Note: This setting is relevant only for streaming methods.
            },
          },
          &quot;dtmf&quot;: { # Represents the input for dtmf event. # The DTMF event to be handled.
            &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
            &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
          },
          &quot;event&quot;: { # Represents the event to trigger. # The event to be triggered.
            &quot;event&quot;: &quot;A String&quot;, # Name of the event.
          },
          &quot;intent&quot;: { # Represents the intent to trigger programmatically rather than as a result of natural language processing. # The intent to be triggered.
            &quot;intent&quot;: &quot;A String&quot;, # Required. The unique identifier of the intent. Format: `projects//locations//agents//intents/`.
          },
          &quot;languageCode&quot;: &quot;A String&quot;, # Required. The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes. Note that queries in the same session do not necessarily need to specify the same language.
          &quot;text&quot;: { # Represents the natural language text to be processed. # The natural language text to be processed.
            &quot;text&quot;: &quot;A String&quot;, # Required. The UTF-8 encoded natural language text to be processed. Text length must not exceed 256 characters.
          },
        },
        &quot;isWebhookEnabled&quot;: True or False, # If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
      },
      &quot;virtualAgentOutput&quot;: { # The output from the virtual agent. # The virtual agent output.
        &quot;currentPage&quot;: { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page). # The Page on which the utterance was spoken. Only name and displayName will be set.
          &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the flow.
          &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text responses.
                    &quot;A String&quot;,
                  ],
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
          &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
            { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
              &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
              &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
              &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
              &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
              &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
            },
          ],
          &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
            &quot;parameters&quot;: [ # Parameters to collect from the user.
              { # Represents a form parameter.
                &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
                &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
                &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
                  &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
                    &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                      { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                        &quot;cases&quot;: [ # A list of cascading if-else conditions.
                          { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                            &quot;caseContent&quot;: [ # A list of case content.
                              { # The list of messages or conditional cases to activate for this case.
                                &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                  },
                                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                                      { # Represents one segment of audio.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                      },
                                    ],
                                  },
                                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                  },
                                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                  },
                                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                  },
                                  &quot;text&quot;: { # The text response message. # Returns a text response.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;text&quot;: [ # Required. A collection of text responses.
                                      &quot;A String&quot;,
                                    ],
                                  },
                                },
                              },
                            ],
                            &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                          },
                        ],
                      },
                    ],
                    &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text responses.
                            &quot;A String&quot;,
                          ],
                        },
                      },
                    ],
                    &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                    &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                      { # Setting a parameter value.
                        &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                        &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                      },
                    ],
                    &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                    &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                  },
                  &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
                    { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                      &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                            &quot;cases&quot;: [ # A list of cascading if-else conditions.
                              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                                &quot;caseContent&quot;: [ # A list of case content.
                                  { # The list of messages or conditional cases to activate for this case.
                                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                      },
                                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                      },
                                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                      },
                                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                                          { # Represents one segment of audio.
                                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                          },
                                        ],
                                      },
                                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                      },
                                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                      },
                                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                      },
                                      &quot;text&quot;: { # The text response message. # Returns a text response.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                        &quot;text&quot;: [ # Required. A collection of text responses.
                                          &quot;A String&quot;,
                                        ],
                                      },
                                    },
                                  },
                                ],
                                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                              },
                            ],
                          },
                        ],
                        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                            },
                            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                              &quot;segments&quot;: [ # Segments this audio response is composed of.
                                { # Represents one segment of audio.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                },
                              ],
                            },
                            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                            },
                            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                            },
                            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                            },
                            &quot;text&quot;: { # The text response message. # Returns a text response.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;text&quot;: [ # Required. A collection of text responses.
                                &quot;A String&quot;,
                              ],
                            },
                          },
                        ],
                        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                          { # Setting a parameter value.
                            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                          },
                        ],
                        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                      },
                    },
                  ],
                },
                &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
                &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
              },
            ],
          },
          &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
          &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
            &quot;A String&quot;,
          ],
          &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
            { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
              &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
              &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
              &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
              &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
              &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
              &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
            },
          ],
        },
        &quot;diagnosticInfo&quot;: { # Required. Input only. The diagnostic info output for the turn. Required to calculate the testing coverage.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;differences&quot;: [ # Output only. If this is part of a result conversation turn, the list of differences between the original run and the replay for this output, if any.
          { # The description of differences between original and replayed agent output.
            &quot;description&quot;: &quot;A String&quot;, # A description of the diff, showing the actual output vs expected output.
            &quot;type&quot;: &quot;A String&quot;, # The type of diff.
          },
        ],
        &quot;sessionParameters&quot;: { # The session parameters available to the bot at this point.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Response error from the agent in the test result. If set, other output is empty.
          &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
          &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
            {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
            },
          ],
          &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        },
        &quot;textResponses&quot;: [ # The text responses from the agent for the turn.
          { # The text response message.
            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
            &quot;text&quot;: [ # Required. A collection of text responses.
              &quot;A String&quot;,
            ],
          },
        ],
        &quot;triggeredIntent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that triggered the response. Only name and displayName will be set.
          &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
          &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
          &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
          &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys.contextual&quot; means the intent is a contextual intent.
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
          &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
            { # Represents an intent parameter.
              &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
              &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
              &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
              &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
            },
          ],
          &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
          &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
            { # Represents an example that the agent is trained on to identify the intent.
              &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
              &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
                { # Represents a part of a training phrase.
                  &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
                  &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
                },
              ],
              &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
            },
          ],
        },
      },
    },
  ],
  &quot;testConfig&quot;: { # Represents configurations for a test case. # Config for the test case.
    &quot;flow&quot;: &quot;A String&quot;, # Flow name to start the test case with. Format: `projects//locations//agents//flows/`. Only one of `flow` and `page` should be set to indicate the starting point of the test case. If both are set, `page` takes precedence over `flow`. If neither is set, the test case will start with start page on the default start flow.
    &quot;page&quot;: &quot;A String&quot;, # The page to start the test case with. Format: `projects//locations//agents//flows//pages/`. Only one of `flow` and `page` should be set to indicate the starting point of the test case. If both are set, `page` takes precedence over `flow`. If neither is set, the test case will start with start page on the default start flow.
    &quot;trackingParameters&quot;: [ # Session parameters to be compared when calculating differences.
      &quot;A String&quot;,
    ],
  },
}

  updateMask: string, Required. The mask to specify which fields should be updated. The `creationTime` and `lastTestResult` cannot be updated.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Represents a test case.
  &quot;creationTime&quot;: &quot;A String&quot;, # Output only. When the test was created.
  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the test case, unique within the agent. Limit of 200 characters.
  &quot;lastTestResult&quot;: { # Represents a result from running a test case in an agent environment. # The latest test result.
    &quot;conversationTurns&quot;: [ # The conversation turns uttered during the test case replay in chronological order.
      { # One interaction between a human and virtual agent. The human provides some input and the virtual agent provides a response.
        &quot;userInput&quot;: { # The input from the human user. # The user input.
          &quot;enableSentimentAnalysis&quot;: True or False, # Whether sentiment analysis is enabled.
          &quot;injectedParameters&quot;: { # Parameters that need to be injected into the conversation during intent detection.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;input&quot;: { # Represents the query input. It can contain one of: 1. A conversational query in the form of text. 2. An intent query that specifies which intent to trigger. 3. Natural language speech audio to be processed. 4. An event to be triggered. # Supports text input, event input, dtmf input in the test case.
            &quot;audio&quot;: { # Represents the natural speech audio to be processed. # The natural language speech audio to be processed.
              &quot;audio&quot;: &quot;A String&quot;, # The natural language speech audio to be processed. A single request can contain up to 1 minute of speech audio data. The transcribed text cannot contain more than 256 bytes. For non-streaming audio detect intent, both `config` and `audio` must be provided. For streaming audio detect intent, `config` must be provided in the first request and `audio` must be provided in all following requests.
              &quot;config&quot;: { # Instructs the speech recognizer on how to process the audio content. # Required. Instructs the speech recognizer how to process the speech audio.
                &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the audio content to process.
                &quot;enableWordInfo&quot;: True or False, # Optional. If `true`, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words, e.g. start and end time offsets. If false or unspecified, Speech doesn&#x27;t return any word-level information.
                &quot;model&quot;: &quot;A String&quot;, # Optional. Which Speech model to select for the given request. Select the model best suited to your domain to get best results. If a model is not explicitly specified, then we auto-select a model based on the parameters in the InputAudioConfig. If enhanced speech model is enabled for the agent and an enhanced version of the specified model for the language does not exist, then the speech is recognized using the standard version of the specified model. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics#select-model) for more details.
                &quot;modelVariant&quot;: &quot;A String&quot;, # Optional. Which variant of the Speech model to use.
                &quot;phraseHints&quot;: [ # Optional. A list of strings containing words and phrases that the speech recognizer should recognize with higher likelihood. See [the Cloud Speech documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints) for more details.
                  &quot;A String&quot;,
                ],
                &quot;sampleRateHertz&quot;: 42, # Sample rate (in Hertz) of the audio content sent in the query. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics) for more details.
                &quot;singleUtterance&quot;: True or False, # Optional. If `false` (default), recognition does not cease until the client closes the stream. If `true`, the recognizer will detect a single spoken utterance in input audio. Recognition ceases when it detects the audio&#x27;s voice has stopped or paused. In this case, once a detected intent is received, the client should close the stream and start a new request with a new stream as needed. Note: This setting is relevant only for streaming methods.
              },
            },
            &quot;dtmf&quot;: { # Represents the input for dtmf event. # The DTMF event to be handled.
              &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
              &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
            },
            &quot;event&quot;: { # Represents the event to trigger. # The event to be triggered.
              &quot;event&quot;: &quot;A String&quot;, # Name of the event.
            },
            &quot;intent&quot;: { # Represents the intent to trigger programmatically rather than as a result of natural language processing. # The intent to be triggered.
              &quot;intent&quot;: &quot;A String&quot;, # Required. The unique identifier of the intent. Format: `projects//locations//agents//intents/`.
            },
            &quot;languageCode&quot;: &quot;A String&quot;, # Required. The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes. Note that queries in the same session do not necessarily need to specify the same language.
            &quot;text&quot;: { # Represents the natural language text to be processed. # The natural language text to be processed.
              &quot;text&quot;: &quot;A String&quot;, # Required. The UTF-8 encoded natural language text to be processed. Text length must not exceed 256 characters.
            },
          },
          &quot;isWebhookEnabled&quot;: True or False, # If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
        },
        &quot;virtualAgentOutput&quot;: { # The output from the virtual agent. # The virtual agent output.
          &quot;currentPage&quot;: { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page). # The Page on which the utterance was spoken. Only name and displayName will be set.
            &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the flow.
            &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
              &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                  &quot;cases&quot;: [ # A list of cascading if-else conditions.
                    { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                      &quot;caseContent&quot;: [ # A list of case content.
                        { # The list of messages or conditional cases to activate for this case.
                          &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                          &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                            },
                            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                              &quot;segments&quot;: [ # Segments this audio response is composed of.
                                { # Represents one segment of audio.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                },
                              ],
                            },
                            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                            },
                            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                            },
                            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                            },
                            &quot;text&quot;: { # The text response message. # Returns a text response.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;text&quot;: [ # Required. A collection of text responses.
                                &quot;A String&quot;,
                              ],
                            },
                          },
                        },
                      ],
                      &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                    },
                  ],
                },
              ],
              &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                  },
                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                  },
                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                      { # Represents one segment of audio.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                      },
                    ],
                  },
                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                  },
                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                  },
                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                  },
                  &quot;text&quot;: { # The text response message. # Returns a text response.
                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                    &quot;text&quot;: [ # Required. A collection of text responses.
                      &quot;A String&quot;,
                    ],
                  },
                },
              ],
              &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
              &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                { # Setting a parameter value.
                  &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                  &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                },
              ],
              &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
              &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
            },
            &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
              { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
            &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
              &quot;parameters&quot;: [ # Parameters to collect from the user.
                { # Represents a form parameter.
                  &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
                  &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
                  &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                  &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
                    &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
                      &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                        { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                          &quot;cases&quot;: [ # A list of cascading if-else conditions.
                            { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                              &quot;caseContent&quot;: [ # A list of case content.
                                { # The list of messages or conditional cases to activate for this case.
                                  &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                  &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                    },
                                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                    },
                                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                    },
                                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                                        { # Represents one segment of audio.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                        },
                                      ],
                                    },
                                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                    },
                                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                    },
                                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                    },
                                    &quot;text&quot;: { # The text response message. # Returns a text response.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                      &quot;text&quot;: [ # Required. A collection of text responses.
                                        &quot;A String&quot;,
                                      ],
                                    },
                                  },
                                },
                              ],
                              &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                            },
                          ],
                        },
                      ],
                      &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                        { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      ],
                      &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                      &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                        { # Setting a parameter value.
                          &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                          &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                        },
                      ],
                      &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                      &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                    },
                    &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
                      { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                        &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                        &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                        &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                        &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                        &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                          &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                            { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                              &quot;cases&quot;: [ # A list of cascading if-else conditions.
                                { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                                  &quot;caseContent&quot;: [ # A list of case content.
                                    { # The list of messages or conditional cases to activate for this case.
                                      &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                      &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                          },
                                        },
                                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                        },
                                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                          },
                                        },
                                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                                            { # Represents one segment of audio.
                                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                            },
                                          ],
                                        },
                                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                        },
                                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                        },
                                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                        },
                                        &quot;text&quot;: { # The text response message. # Returns a text response.
                                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                          &quot;text&quot;: [ # Required. A collection of text responses.
                                            &quot;A String&quot;,
                                          ],
                                        },
                                      },
                                    },
                                  ],
                                  &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                                },
                              ],
                            },
                          ],
                          &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                            { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          ],
                          &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                          &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                            { # Setting a parameter value.
                              &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                              &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                            },
                          ],
                          &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                          &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                        },
                      },
                    ],
                  },
                  &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                  &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
                  &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
                },
              ],
            },
            &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
            &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
              &quot;A String&quot;,
            ],
            &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
              { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
                &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
                &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
                &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
                  &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                    { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                      &quot;cases&quot;: [ # A list of cascading if-else conditions.
                        { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                          &quot;caseContent&quot;: [ # A list of case content.
                            { # The list of messages or conditional cases to activate for this case.
                              &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                              &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                },
                                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                },
                                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                                    { # Represents one segment of audio.
                                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                    },
                                  ],
                                },
                                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                },
                                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                },
                                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                },
                                &quot;text&quot;: { # The text response message. # Returns a text response.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                  &quot;text&quot;: [ # Required. A collection of text responses.
                                    &quot;A String&quot;,
                                  ],
                                },
                              },
                            },
                          ],
                          &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                        },
                      ],
                    },
                  ],
                  &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                    { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                      },
                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                      },
                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                          { # Represents one segment of audio.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                          },
                        ],
                      },
                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                      },
                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                      },
                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                      },
                      &quot;text&quot;: { # The text response message. # Returns a text response.
                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                        &quot;text&quot;: [ # Required. A collection of text responses.
                          &quot;A String&quot;,
                        ],
                      },
                    },
                  ],
                  &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                  &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                    { # Setting a parameter value.
                      &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                      &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                    },
                  ],
                  &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                  &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                },
              },
            ],
          },
          &quot;diagnosticInfo&quot;: { # Required. Input only. The diagnostic info output for the turn. Required to calculate the testing coverage.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;differences&quot;: [ # Output only. If this is part of a result conversation turn, the list of differences between the original run and the replay for this output, if any.
            { # The description of differences between original and replayed agent output.
              &quot;description&quot;: &quot;A String&quot;, # A description of the diff, showing the actual output vs expected output.
              &quot;type&quot;: &quot;A String&quot;, # The type of diff.
            },
          ],
          &quot;sessionParameters&quot;: { # The session parameters available to the bot at this point.
            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
          },
          &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Response error from the agent in the test result. If set, other output is empty.
            &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
            &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
              {
                &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
              },
            ],
            &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
          },
          &quot;textResponses&quot;: [ # The text responses from the agent for the turn.
            { # The text response message.
              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
              &quot;text&quot;: [ # Required. A collection of text responses.
                &quot;A String&quot;,
              ],
            },
          ],
          &quot;triggeredIntent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that triggered the response. Only name and displayName will be set.
            &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
            &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
            &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
            &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys.contextual&quot; means the intent is a contextual intent.
              &quot;a_key&quot;: &quot;A String&quot;,
            },
            &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
            &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
              { # Represents an intent parameter.
                &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
                &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
              },
            ],
            &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
            &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
              { # Represents an example that the agent is trained on to identify the intent.
                &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
                &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
                  { # Represents a part of a training phrase.
                    &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
                    &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
                  },
                ],
                &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
              },
            ],
          },
        },
      },
    ],
    &quot;environment&quot;: &quot;A String&quot;, # Environment where the test was run. If not set, it indicates the draft environment.
    &quot;name&quot;: &quot;A String&quot;, # The resource name for the test case result. Format: `projects//locations//agents//testCases/ /results/`.
    &quot;testResult&quot;: &quot;A String&quot;, # Whether the test case passed in the agent environment.
    &quot;testTime&quot;: &quot;A String&quot;, # The time that the test was run.
  },
  &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the test case. TestCases.CreateTestCase will populate the name automatically. Otherwise use format: `projects//locations//agents/ /testCases/`.
  &quot;notes&quot;: &quot;A String&quot;, # Additional freeform notes about the test case. Limit of 400 characters.
  &quot;tags&quot;: [ # Tags are short descriptions that users may apply to test cases for organizational and filtering purposes. Each tag should start with &quot;#&quot; and has a limit of 30 characters.
    &quot;A String&quot;,
  ],
  &quot;testCaseConversationTurns&quot;: [ # The conversation turns uttered when the test case was created, in chronological order. These include the canonical set of agent utterances that should occur when the agent is working properly.
    { # One interaction between a human and virtual agent. The human provides some input and the virtual agent provides a response.
      &quot;userInput&quot;: { # The input from the human user. # The user input.
        &quot;enableSentimentAnalysis&quot;: True or False, # Whether sentiment analysis is enabled.
        &quot;injectedParameters&quot;: { # Parameters that need to be injected into the conversation during intent detection.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;input&quot;: { # Represents the query input. It can contain one of: 1. A conversational query in the form of text. 2. An intent query that specifies which intent to trigger. 3. Natural language speech audio to be processed. 4. An event to be triggered. # Supports text input, event input, dtmf input in the test case.
          &quot;audio&quot;: { # Represents the natural speech audio to be processed. # The natural language speech audio to be processed.
            &quot;audio&quot;: &quot;A String&quot;, # The natural language speech audio to be processed. A single request can contain up to 1 minute of speech audio data. The transcribed text cannot contain more than 256 bytes. For non-streaming audio detect intent, both `config` and `audio` must be provided. For streaming audio detect intent, `config` must be provided in the first request and `audio` must be provided in all following requests.
            &quot;config&quot;: { # Instructs the speech recognizer on how to process the audio content. # Required. Instructs the speech recognizer how to process the speech audio.
              &quot;audioEncoding&quot;: &quot;A String&quot;, # Required. Audio encoding of the audio content to process.
              &quot;enableWordInfo&quot;: True or False, # Optional. If `true`, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words, e.g. start and end time offsets. If false or unspecified, Speech doesn&#x27;t return any word-level information.
              &quot;model&quot;: &quot;A String&quot;, # Optional. Which Speech model to select for the given request. Select the model best suited to your domain to get best results. If a model is not explicitly specified, then we auto-select a model based on the parameters in the InputAudioConfig. If enhanced speech model is enabled for the agent and an enhanced version of the specified model for the language does not exist, then the speech is recognized using the standard version of the specified model. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics#select-model) for more details.
              &quot;modelVariant&quot;: &quot;A String&quot;, # Optional. Which variant of the Speech model to use.
              &quot;phraseHints&quot;: [ # Optional. A list of strings containing words and phrases that the speech recognizer should recognize with higher likelihood. See [the Cloud Speech documentation](https://cloud.google.com/speech-to-text/docs/basics#phrase-hints) for more details.
                &quot;A String&quot;,
              ],
              &quot;sampleRateHertz&quot;: 42, # Sample rate (in Hertz) of the audio content sent in the query. Refer to [Cloud Speech API documentation](https://cloud.google.com/speech-to-text/docs/basics) for more details.
              &quot;singleUtterance&quot;: True or False, # Optional. If `false` (default), recognition does not cease until the client closes the stream. If `true`, the recognizer will detect a single spoken utterance in input audio. Recognition ceases when it detects the audio&#x27;s voice has stopped or paused. In this case, once a detected intent is received, the client should close the stream and start a new request with a new stream as needed. Note: This setting is relevant only for streaming methods.
            },
          },
          &quot;dtmf&quot;: { # Represents the input for dtmf event. # The DTMF event to be handled.
            &quot;digits&quot;: &quot;A String&quot;, # The dtmf digits.
            &quot;finishDigit&quot;: &quot;A String&quot;, # The finish digit (if any).
          },
          &quot;event&quot;: { # Represents the event to trigger. # The event to be triggered.
            &quot;event&quot;: &quot;A String&quot;, # Name of the event.
          },
          &quot;intent&quot;: { # Represents the intent to trigger programmatically rather than as a result of natural language processing. # The intent to be triggered.
            &quot;intent&quot;: &quot;A String&quot;, # Required. The unique identifier of the intent. Format: `projects//locations//agents//intents/`.
          },
          &quot;languageCode&quot;: &quot;A String&quot;, # Required. The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes. Note that queries in the same session do not necessarily need to specify the same language.
          &quot;text&quot;: { # Represents the natural language text to be processed. # The natural language text to be processed.
            &quot;text&quot;: &quot;A String&quot;, # Required. The UTF-8 encoded natural language text to be processed. Text length must not exceed 256 characters.
          },
        },
        &quot;isWebhookEnabled&quot;: True or False, # If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
      },
      &quot;virtualAgentOutput&quot;: { # The output from the virtual agent. # The virtual agent output.
        &quot;currentPage&quot;: { # A Dialogflow CX conversation (session) can be described and visualized as a state machine. The states of a CX session are represented by pages. For each flow, you define many pages, where your combined pages can handle a complete conversation on the topics the flow is designed for. At any given moment, exactly one page is the current page, the current page is considered active, and the flow associated with that page is considered active. Every flow has a special start page. When a flow initially becomes active, the start page page becomes the current page. For each conversational turn, the current page will either stay the same or transition to another page. You configure each page to collect information from the end-user that is relevant for the conversational state represented by the page. For more information, see the [Page guide](https://cloud.google.com/dialogflow/cx/docs/concept/page). # The Page on which the utterance was spoken. Only name and displayName will be set.
          &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the page, unique within the flow.
          &quot;entryFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the session is entering the page.
            &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
              { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                &quot;cases&quot;: [ # A list of cascading if-else conditions.
                  { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                    &quot;caseContent&quot;: [ # A list of case content.
                      { # The list of messages or conditional cases to activate for this case.
                        &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                        &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                          &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                          &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                            &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                          },
                          &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                            &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                          },
                          &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                            &quot;segments&quot;: [ # Segments this audio response is composed of.
                              { # Represents one segment of audio.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                              },
                            ],
                          },
                          &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                            &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                          },
                          &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                          &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                          },
                          &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                            &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                          },
                          &quot;text&quot;: { # The text response message. # Returns a text response.
                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                            &quot;text&quot;: [ # Required. A collection of text responses.
                              &quot;A String&quot;,
                            ],
                          },
                        },
                      },
                    ],
                    &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                  },
                ],
              },
            ],
            &quot;messages&quot;: [ # The list of rich message responses to present to the user.
              { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                  &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                },
                &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                  &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                  },
                },
                &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                  &quot;segments&quot;: [ # Segments this audio response is composed of.
                    { # Represents one segment of audio.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                      &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                      &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                    },
                  ],
                },
                &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                  &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                },
                &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                },
                &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                },
                &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                  &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                },
                &quot;text&quot;: { # The text response message. # Returns a text response.
                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                  &quot;text&quot;: [ # Required. A collection of text responses.
                    &quot;A String&quot;,
                  ],
                },
              },
            ],
            &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
            &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
              { # Setting a parameter value.
                &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
              },
            ],
            &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
            &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
          },
          &quot;eventHandlers&quot;: [ # Handlers associated with the page to handle events such as webhook errors, no match or no input.
            { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
              &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
              &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
              &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
              &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
              &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
            },
          ],
          &quot;form&quot;: { # A form is a data model that groups related parameters that can be collected from the user. The process in which the agent prompts the user and collects parameter values from the user is called form filling. A form can be added to a page. When form filling is done, the filled parameters will be written to the session. # The form associated with the page, used for collecting parameters relevant to the page.
            &quot;parameters&quot;: [ # Parameters to collect from the user.
              { # Represents a form parameter.
                &quot;defaultValue&quot;: &quot;&quot;, # The default value of an optional parameter. If the parameter is required, the default value will be ignored.
                &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the parameter, unique within the form.
                &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
                &quot;fillBehavior&quot;: { # Configuration for how the filling of a parameter should be handled. # Required. Defines fill behavior for the parameter.
                  &quot;initialPromptFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # Required. The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
                    &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                      { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                        &quot;cases&quot;: [ # A list of cascading if-else conditions.
                          { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                            &quot;caseContent&quot;: [ # A list of case content.
                              { # The list of messages or conditional cases to activate for this case.
                                &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                  &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                  &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                    &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                  },
                                  &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                    &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                    },
                                  },
                                  &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                    &quot;segments&quot;: [ # Segments this audio response is composed of.
                                      { # Represents one segment of audio.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                        &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                        &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                      },
                                    ],
                                  },
                                  &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                    &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                  },
                                  &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                    &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                  },
                                  &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                  },
                                  &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                    &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                  },
                                  &quot;text&quot;: { # The text response message. # Returns a text response.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                    &quot;text&quot;: [ # Required. A collection of text responses.
                                      &quot;A String&quot;,
                                    ],
                                  },
                                },
                              },
                            ],
                            &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                          },
                        ],
                      },
                    ],
                    &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                      { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                        &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                        &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                          &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                        },
                        &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                          &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                            &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                          },
                        },
                        &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                          &quot;segments&quot;: [ # Segments this audio response is composed of.
                            { # Represents one segment of audio.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                              &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                              &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                            },
                          ],
                        },
                        &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                          &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                        },
                        &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                        },
                        &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                        },
                        &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                          &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                        },
                        &quot;text&quot;: { # The text response message. # Returns a text response.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                          &quot;text&quot;: [ # Required. A collection of text responses.
                            &quot;A String&quot;,
                          ],
                        },
                      },
                    ],
                    &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                    &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                      { # Setting a parameter value.
                        &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                        &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                      },
                    ],
                    &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                    &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                  },
                  &quot;repromptEventHandlers&quot;: [ # The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are: * `sys.no-match-`, where N can be from 1 to 6 * `sys.no-match-default` * `sys.no-input-`, where N can be from 1 to 6 * `sys.no-input-default` * `sys.invalid-parameter` `initial_prompt_fulfillment` provides the first prompt for the parameter. If the user&#x27;s response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the `sys.no-match-1`/`sys.no-input-1` handler (if defined) will be called to provide a prompt. The `sys.no-match-2`/`sys.no-input-2` handler (if defined) will respond to the next no-match/no-input event, and so on. A `sys.no-match-default` or `sys.no-input-default` handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed. A `sys.invalid-parameter` handler can be defined to handle the case where the parameter values have been `invalidated` by webhook. For example, if the user&#x27;s response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the `sys.invalid-parameter` handler (if defined) will be called to provide a prompt. If the event handler for the corresponding event can&#x27;t be found on the parameter, `initial_prompt_fulfillment` will be re-prompted.
                    { # An event handler specifies an event that can be handled during a session. When the specified event happens, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the event, it will be called. * If there is a `target_page` associated with the event, the session will transition into the specified page. * If there is a `target_flow` associated with the event, the session will transition into the specified flow.
                      &quot;event&quot;: &quot;A String&quot;, # Required. The name of the event to handle.
                      &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this event handler.
                      &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
                      &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
                      &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
                        &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                          { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                            &quot;cases&quot;: [ # A list of cascading if-else conditions.
                              { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                                &quot;caseContent&quot;: [ # A list of case content.
                                  { # The list of messages or conditional cases to activate for this case.
                                    &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                                    &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                                      &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                                      &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                        &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                      },
                                      &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                                      },
                                      &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                        &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                        },
                                      },
                                      &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                        &quot;segments&quot;: [ # Segments this audio response is composed of.
                                          { # Represents one segment of audio.
                                            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                            &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                            &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                          },
                                        ],
                                      },
                                      &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                        &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                        &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                                      },
                                      &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                      },
                                      &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                        &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                                      },
                                      &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                        &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                                      },
                                      &quot;text&quot;: { # The text response message. # Returns a text response.
                                        &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                        &quot;text&quot;: [ # Required. A collection of text responses.
                                          &quot;A String&quot;,
                                        ],
                                      },
                                    },
                                  },
                                ],
                                &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                              },
                            ],
                          },
                        ],
                        &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                          { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                            &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                            &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                              &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                            },
                            &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                              &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                            },
                            &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                              &quot;segments&quot;: [ # Segments this audio response is composed of.
                                { # Represents one segment of audio.
                                  &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                  &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                  &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                },
                              ],
                            },
                            &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                              &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                            },
                            &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                              &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                            },
                            &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                            },
                            &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                              &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                            },
                            &quot;text&quot;: { # The text response message. # Returns a text response.
                              &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                              &quot;text&quot;: [ # Required. A collection of text responses.
                                &quot;A String&quot;,
                              ],
                            },
                          },
                        ],
                        &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                        &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                          { # Setting a parameter value.
                            &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                            &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                          },
                        ],
                        &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                        &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
                      },
                    },
                  ],
                },
                &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
                &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
                &quot;required&quot;: True or False, # Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them. Required parameters must be filled before form filling concludes.
              },
            ],
          },
          &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the page. Required for the Pages.UpdatePage method. Pages.CreatePage populates the name automatically. Format: `projects//locations//agents//flows//pages/`.
          &quot;transitionRouteGroups&quot;: [ # Ordered list of `TransitionRouteGroups` associated with the page. Transition route groups must be unique within a page. * If multiple transition routes within a page scope refer to the same intent, then the precedence order is: page&#x27;s transition route -&gt; page&#x27;s transition route group -&gt; flow&#x27;s transition routes. * If multiple transition route groups within a page contain the same intent, then the first group in the ordered list takes precedence. Format:`projects//locations//agents//flows//transitionRouteGroups/`.
            &quot;A String&quot;,
          ],
          &quot;transitionRoutes&quot;: [ # A list of transitions for the transition rules of this page. They route the conversation to another page in the same flow, or another flow. When we are in a certain page, the TransitionRoutes are evalauted in the following order: * TransitionRoutes defined in the page with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in flow with intent specified. * TransitionRoutes defined in the transition route groups with intent specified. * TransitionRoutes defined in the page with only condition specified. * TransitionRoutes defined in the transition route groups with only condition specified.
            { # A transition route specifies a intent that can be matched and/or a data condition that can be evaluated during a session. When a specified transition is matched, the following actions are taken in order: * If there is a `trigger_fulfillment` associated with the transition, it will be called. * If there is a `target_page` associated with the transition, the session will transition into the specified page. * If there is a `target_flow` associated with the transition, the session will transition into the specified flow.
              &quot;condition&quot;: &quot;A String&quot;, # The condition to evaluate against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition). At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
              &quot;intent&quot;: &quot;A String&quot;, # The unique identifier of an Intent. Format: `projects//locations//agents//intents/`. Indicates that the transition can only happen when the given intent is matched. At least one of `intent` or `condition` must be specified. When both `intent` and `condition` are specified, the transition can only happen when both are fulfilled.
              &quot;name&quot;: &quot;A String&quot;, # Output only. The unique identifier of this transition route.
              &quot;targetFlow&quot;: &quot;A String&quot;, # The target flow to transition to. Format: `projects//locations//agents//flows/`.
              &quot;targetPage&quot;: &quot;A String&quot;, # The target page to transition to. Format: `projects//locations//agents//flows//pages/`.
              &quot;triggerFulfillment&quot;: { # A fulfillment can do one or more of the following actions at the same time: * Generate rich message responses. * Set parameter values. * Call the webhook. Fulfillments can be called at various stages in the Page or Form lifecycle. For example, when a DetectIntentRequest drives a session to enter a new page, the page&#x27;s entry fulfillment can add a static response to the QueryResult in the returning DetectIntentResponse, call the webhook (for example, to load user data from a database), or both. # The fulfillment to call when the condition is satisfied. At least one of `trigger_fulfillment` and `target` must be specified. When both are defined, `trigger_fulfillment` is executed first.
                &quot;conditionalCases&quot;: [ # Conditional cases for this fulfillment.
                  { # A list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
                    &quot;cases&quot;: [ # A list of cascading if-else conditions.
                      { # Each case has a Boolean condition. When it is evaluated to be True, the corresponding messages will be selected and evaluated recursively.
                        &quot;caseContent&quot;: [ # A list of case content.
                          { # The list of messages or conditional cases to activate for this case.
                            &quot;additionalCases&quot;: # Object with schema name: GoogleCloudDialogflowCxV3FulfillmentConditionalCases # Additional cases to be evaluated.
                            &quot;message&quot;: { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard. # Returned message.
                              &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                              &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                                &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                              },
                              &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                                &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                                  &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                                },
                              },
                              &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                                &quot;segments&quot;: [ # Segments this audio response is composed of.
                                  { # Represents one segment of audio.
                                    &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                                    &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                                    &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                                  },
                                ],
                              },
                              &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                                &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                              },
                              &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                                &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                              },
                              &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                              },
                              &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                                &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                              },
                              &quot;text&quot;: { # The text response message. # Returns a text response.
                                &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                                &quot;text&quot;: [ # Required. A collection of text responses.
                                  &quot;A String&quot;,
                                ],
                              },
                            },
                          },
                        ],
                        &quot;condition&quot;: &quot;A String&quot;, # The condition to activate and select this case. Empty means the condition is always true. The condition is evaluated against form parameters or session parameters. See the [conditions reference](https://cloud.google.com/dialogflow/cx/docs/reference/condition).
                      },
                    ],
                  },
                ],
                &quot;messages&quot;: [ # The list of rich message responses to present to the user.
                  { # Represents a response message that can be returned by a conversational agent. Response messages are also used for output audio synthesis. The approach is as follows: * If at least one OutputAudioText response is present, then all OutputAudioText responses are linearly concatenated, and the result is used for output audio synthesis. * If the OutputAudioText responses are a mixture of text and SSML, then the concatenated result is treated as SSML; otherwise, the result is treated as either text or SSML as appropriate. The agent designer should ideally use either text or SSML consistently throughout the bot design. * Otherwise, all Text responses are linearly concatenated, and the result is used for output audio synthesis. This approach allows for more sophisticated user experience scenarios, where the text displayed to the user may differ from what is heard.
                    &quot;channel&quot;: &quot;A String&quot;, # The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
                    &quot;conversationSuccess&quot;: { # Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about. Dialogflow only uses this to determine which conversations should be counted as successful and doesn&#x27;t process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don&#x27;t return ConversationSuccess. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates that the conversation succeeded. * In a webhook response when you determine that you handled the customer issue. # Indicates that the conversation succeeded.
                      &quot;metadata&quot;: { # Custom metadata. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;endInteraction&quot;: { # Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. A signal that indicates the interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only when the conversation reaches `END_SESSION` page. It is not supposed to be defined by the user. It&#x27;s guaranteed that there is at most one such message in each response.
                    },
                    &quot;liveAgentHandoff&quot;: { # Indicates that the conversation should be handed off to a live agent. Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures. You may set this, for example: * In the entry_fulfillment of a Page if entering the page indicates something went extremely wrong in the conversation. * In a webhook response when you determine that the customer issue can only be handled by a human. # Hands off conversation to a human agent.
                      &quot;metadata&quot;: { # Custom metadata for your handoff procedure. Dialogflow doesn&#x27;t impose any structure on this.
                        &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                      },
                    },
                    &quot;mixedAudio&quot;: { # Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user. # Output only. An audio response message composed of both the synthesized Dialogflow agent responses and responses defined via play_audio. This message is generated by Dialogflow only and not supposed to be defined by the user.
                      &quot;segments&quot;: [ # Segments this audio response is composed of.
                        { # Represents one segment of audio.
                          &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this segment can be interrupted by the end user&#x27;s speech and the client should then start the next Dialogflow request.
                          &quot;audio&quot;: &quot;A String&quot;, # Raw audio synthesized from the Dialogflow agent&#x27;s response using the output config specified in the request.
                          &quot;uri&quot;: &quot;A String&quot;, # Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
                        },
                      ],
                    },
                    &quot;outputAudioText&quot;: { # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message. # A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;ssml&quot;: &quot;A String&quot;, # The SSML text to be synthesized. For more information, see [SSML](/speech/text-to-speech/docs/ssml).
                      &quot;text&quot;: &quot;A String&quot;, # The raw text to be synthesized.
                    },
                    &quot;payload&quot;: { # Returns a response containing a custom, platform-specific payload.
                      &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
                    },
                    &quot;playAudio&quot;: { # Specifies an audio clip to be played by the client as part of the response. # Signal that the client should play an audio clip hosted at a client-specific URI. Dialogflow uses this to construct mixed_audio. However, Dialogflow itself does not try to read or process the URI in any way.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;audioUri&quot;: &quot;A String&quot;, # Required. URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
                    },
                    &quot;telephonyTransferCall&quot;: { # Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint. # A signal that the client should transfer the phone call connected to this agent to a third-party endpoint.
                      &quot;phoneNumber&quot;: &quot;A String&quot;, # Transfer the call to a phone number in [E.164 format](https://en.wikipedia.org/wiki/E.164).
                    },
                    &quot;text&quot;: { # The text response message. # Returns a text response.
                      &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
                      &quot;text&quot;: [ # Required. A collection of text responses.
                        &quot;A String&quot;,
                      ],
                    },
                  },
                ],
                &quot;returnPartialResponses&quot;: True or False, # Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
                &quot;setParameterActions&quot;: [ # Set parameter values before executing the webhook.
                  { # Setting a parameter value.
                    &quot;parameter&quot;: &quot;A String&quot;, # Display name of the parameter.
                    &quot;value&quot;: &quot;&quot;, # The new value of the parameter. A null value clears the parameter.
                  },
                ],
                &quot;tag&quot;: &quot;A String&quot;, # The value of this field will be populated in the WebhookRequest `fulfillmentInfo.tag` field by Dialogflow when the associated webhook is called. The tag is typically used by the webhook service to identify which fulfillment is being called, but it could be used for other purposes. This field is required if `webhook` is specified.
                &quot;webhook&quot;: &quot;A String&quot;, # The webhook to call. Format: `projects//locations//agents//webhooks/`.
              },
            },
          ],
        },
        &quot;diagnosticInfo&quot;: { # Required. Input only. The diagnostic info output for the turn. Required to calculate the testing coverage.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;differences&quot;: [ # Output only. If this is part of a result conversation turn, the list of differences between the original run and the replay for this output, if any.
          { # The description of differences between original and replayed agent output.
            &quot;description&quot;: &quot;A String&quot;, # A description of the diff, showing the actual output vs expected output.
            &quot;type&quot;: &quot;A String&quot;, # The type of diff.
          },
        ],
        &quot;sessionParameters&quot;: { # The session parameters available to the bot at this point.
          &quot;a_key&quot;: &quot;&quot;, # Properties of the object.
        },
        &quot;status&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # Response error from the agent in the test result. If set, other output is empty.
          &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
          &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
            {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
            },
          ],
          &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        },
        &quot;textResponses&quot;: [ # The text responses from the agent for the turn.
          { # The text response message.
            &quot;allowPlaybackInterruption&quot;: True or False, # Output only. Whether the playback of this message can be interrupted by the end user&#x27;s speech and the client can then starts the next Dialogflow request.
            &quot;text&quot;: [ # Required. A collection of text responses.
              &quot;A String&quot;,
            ],
          },
        ],
        &quot;triggeredIntent&quot;: { # An intent represents a user&#x27;s intent to interact with a conversational agent. You can provide information for the Dialogflow API to use to match user input to an intent by adding training phrases (i.e., examples of user input) to your intent. # The Intent that triggered the response. Only name and displayName will be set.
          &quot;description&quot;: &quot;A String&quot;, # Human readable description for better understanding an intent like its scope, content, result etc. Maximum character limit: 140 characters.
          &quot;displayName&quot;: &quot;A String&quot;, # Required. The human-readable name of the intent, unique within the agent.
          &quot;isFallback&quot;: True or False, # Indicates whether this is a fallback intent. Currently only default fallback intent is allowed in the agent, which is added upon agent creation. Adding training phrases to fallback intent is useful in the case of requests that are mistakenly matched, since training phrases assigned to fallback intents act as negative examples that triggers no-match event.
          &quot;labels&quot;: { # The key/value metadata to label an intent. Labels can contain lowercase letters, digits and the symbols &#x27;-&#x27; and &#x27;_&#x27;. International characters are allowed, including letters from unicase alphabets. Keys must start with a letter. Keys and values can be no longer than 63 characters and no more than 128 bytes. Prefix &quot;sys-&quot; is reserved for Dialogflow defined labels. Currently allowed Dialogflow defined labels include: * sys-head * sys-contextual The above labels do not require value. &quot;sys-head&quot; means the intent is a head intent. &quot;sys.contextual&quot; means the intent is a contextual intent.
            &quot;a_key&quot;: &quot;A String&quot;,
          },
          &quot;name&quot;: &quot;A String&quot;, # The unique identifier of the intent. Required for the Intents.UpdateIntent method. Intents.CreateIntent populates the name automatically. Format: `projects//locations//agents//intents/`.
          &quot;parameters&quot;: [ # The collection of parameters associated with the intent.
            { # Represents an intent parameter.
              &quot;entityType&quot;: &quot;A String&quot;, # Required. The entity type of the parameter. Format: `projects/-/locations/-/agents/-/entityTypes/` for system entity types (for example, `projects/-/locations/-/agents/-/entityTypes/sys.date`), or `projects//locations//agents//entityTypes/` for developer entity types.
              &quot;id&quot;: &quot;A String&quot;, # Required. The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
              &quot;isList&quot;: True or False, # Indicates whether the parameter represents a list of values.
              &quot;redact&quot;: True or False, # Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
            },
          ],
          &quot;priority&quot;: 42, # The priority of this intent. Higher numbers represent higher priorities. - If the supplied value is unspecified or 0, the service translates the value to 500,000, which corresponds to the `Normal` priority in the console. - If the supplied value is negative, the intent is ignored in runtime detect intent requests.
          &quot;trainingPhrases&quot;: [ # The collection of training phrases the agent is trained on to identify the intent.
            { # Represents an example that the agent is trained on to identify the intent.
              &quot;id&quot;: &quot;A String&quot;, # Output only. The unique identifier of the training phrase.
              &quot;parts&quot;: [ # Required. The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase. Note: The API does not automatically annotate training phrases like the Dialogflow Console does. Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated. If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set. If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways: - `Part.text` is set to a part of the phrase that has no parameters. - `Part.text` is set to a part of the phrase that you want to annotate, and the `parameter_id` field is set.
                { # Represents a part of a training phrase.
                  &quot;parameterId&quot;: &quot;A String&quot;, # The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
                  &quot;text&quot;: &quot;A String&quot;, # Required. The text for this part.
                },
              ],
              &quot;repeatCount&quot;: 42, # Indicates how many times this example was added to the intent.
            },
          ],
        },
      },
    },
  ],
  &quot;testConfig&quot;: { # Represents configurations for a test case. # Config for the test case.
    &quot;flow&quot;: &quot;A String&quot;, # Flow name to start the test case with. Format: `projects//locations//agents//flows/`. Only one of `flow` and `page` should be set to indicate the starting point of the test case. If both are set, `page` takes precedence over `flow`. If neither is set, the test case will start with start page on the default start flow.
    &quot;page&quot;: &quot;A String&quot;, # The page to start the test case with. Format: `projects//locations//agents//flows//pages/`. Only one of `flow` and `page` should be set to indicate the starting point of the test case. If both are set, `page` takes precedence over `flow`. If neither is set, the test case will start with start page on the default start flow.
    &quot;trackingParameters&quot;: [ # Session parameters to be compared when calculating differences.
      &quot;A String&quot;,
    ],
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="run">run(name, body=None, x__xgafv=None)</code>
  <pre>Kicks off a test case run. This method is a [long-running operation](https://cloud.google.com/dialogflow/cx/docs/how/long-running-operation). The returned `Operation` type has the following method-specific fields: - `metadata`: RunTestCaseMetadata - `response`: RunTestCaseResponse

Args:
  name: string, Required. Format of test case name to run: `projects//locations/ /agents//testCases/`. (required)
  body: object, The request body.
    The object takes the form of:

{ # The request message for TestCases.RunTestCase.
  &quot;environment&quot;: &quot;A String&quot;, # Optional. Environment name. If not set, draft environment is assumed. Format: `projects//locations//agents//environments/`.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # This resource represents a long-running operation that is the result of a network API call.
  &quot;done&quot;: True or False, # If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available.
  &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # The error result of the operation in case of failure or cancellation.
    &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
    &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
      {
        &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
  },
  &quot;metadata&quot;: { # Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
  &quot;name&quot;: &quot;A String&quot;, # The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending with `operations/{unique_id}`.
  &quot;response&quot;: { # The normal response of the operation in case of success. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
    &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
  },
}</pre>
</div>

</body></html>