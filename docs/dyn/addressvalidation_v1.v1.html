<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="addressvalidation_v1.html">Address Validation API</a> . <a href="addressvalidation_v1.v1.html">v1</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#provideValidationFeedback">provideValidationFeedback(body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Feedback about the outcome of the sequence of validation attempts. This should be the last call made after a sequence of validation calls for the same address, and should be called once the transaction is concluded. This should only be sent once for the sequence of `ValidateAddress` requests needed to validate an address fully.</p>
<p class="toc_element">
  <code><a href="#validateAddress">validateAddress(body=None, x__xgafv=None)</a></code></p>
<p class="firstline">Validates an address.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="provideValidationFeedback">provideValidationFeedback(body=None, x__xgafv=None)</code>
  <pre>Feedback about the outcome of the sequence of validation attempts. This should be the last call made after a sequence of validation calls for the same address, and should be called once the transaction is concluded. This should only be sent once for the sequence of `ValidateAddress` requests needed to validate an address fully.

Args:
  body: object, The request body.
    The object takes the form of:

{ # The request for sending validation feedback.
  &quot;conclusion&quot;: &quot;A String&quot;, # Required. The outcome of the sequence of validation attempts. If this field is set to `VALIDATION_CONCLUSION_UNSPECIFIED`, an `INVALID_ARGUMENT` error will be returned.
  &quot;responseId&quot;: &quot;A String&quot;, # Required. The ID of the response that this feedback is for. This should be the response_id from the first response in a series of address validation attempts.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response for validation feedback. The response is empty if the feedback is sent successfully.
}</pre>
</div>

<div class="method">
    <code class="details" id="validateAddress">validateAddress(body=None, x__xgafv=None)</code>
  <pre>Validates an address.

Args:
  body: object, The request body.
    The object takes the form of:

{ # The request for validating an address.
  &quot;address&quot;: { # Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains). In typical usage an address would be created via user input or from importing existing data, depending on the type of process. Advice on address input / editing: - Use an internationalization-ready address widget such as https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used. For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478 # Required. The address being validated. Unformatted addresses should be submitted via `address_lines`. The total length of the fields in this input must not exceed 280 characters. Supported regions can be found [here](https://developers.google.com/maps/documentation/address-validation/coverage). The language_code value in the input address is reserved for future uses and is ignored today. The validated address result will be populated based on the preferred language for the given address, as identified by the system. The Address Validation API ignores the values in recipients and organization. Any values in those fields will be discarded and not returned. Please do not set them.
    &quot;addressLines&quot;: [ # Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. &quot;Austin, TX&quot;), it is important that the line order is clear. The order of address lines should be &quot;envelope order&quot; for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. &quot;ja&quot; for large-to-small ordering and &quot;ja-Latn&quot; or &quot;en&quot; for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
      &quot;A String&quot;,
    ],
    &quot;administrativeArea&quot;: &quot;A String&quot;, # Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. &quot;Barcelona&quot; and not &quot;Catalonia&quot;). Many countries don&#x27;t use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
    &quot;languageCode&quot;: &quot;A String&quot;, # Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address&#x27; country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: &quot;zh-Hant&quot;, &quot;ja&quot;, &quot;ja-Latn&quot;, &quot;en&quot;.
    &quot;locality&quot;: &quot;A String&quot;, # Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
    &quot;organization&quot;: &quot;A String&quot;, # Optional. The name of the organization at the address.
    &quot;postalCode&quot;: &quot;A String&quot;, # Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
    &quot;recipients&quot;: [ # Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain &quot;care of&quot; information.
      &quot;A String&quot;,
    ],
    &quot;regionCode&quot;: &quot;A String&quot;, # Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See https://cldr.unicode.org/ and https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: &quot;CH&quot; for Switzerland.
    &quot;revision&quot;: 42, # The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
    &quot;sortingCode&quot;: &quot;A String&quot;, # Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like &quot;CEDEX&quot;, optionally followed by a number (e.g. &quot;CEDEX 7&quot;), or just a number alone, representing the &quot;sector code&quot; (Jamaica), &quot;delivery area indicator&quot; (Malawi) or &quot;post office indicator&quot; (e.g. CÃ´te d&#x27;Ivoire).
    &quot;sublocality&quot;: &quot;A String&quot;, # Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
  },
  &quot;enableUspsCass&quot;: True or False, # Enables USPS CASS compatible mode. This affects _only_ the [google.maps.addressvalidation.v1.ValidationResult.usps_data] field of [google.maps.addressvalidation.v1.ValidationResult]. Note: for USPS CASS enabled requests for addresses in Puerto Rico, a [google.type.PostalAddress.region_code] of the `address` must be provided as &quot;PR&quot;, or an [google.type.PostalAddress.administrative_area] of the `address` must be provided as &quot;Puerto Rico&quot; (case-insensitive) or &quot;PR&quot;. It&#x27;s recommended to use a componentized `address`, or alternatively specify at least two [google.type.PostalAddress.address_lines] where the first line contains the street number and name and the second line contains the city, state, and zip code.
  &quot;languageOptions&quot;: { # Preview: This feature is in Preview (pre-GA). Pre-GA products and features might have limited support, and changes to pre-GA products and features might not be compatible with other pre-GA versions. Pre-GA Offerings are covered by the [Google Maps Platform Service Specific Terms](https://cloud.google.com/maps-platform/terms/maps-service-terms). For more information, see the [launch stage descriptions](https://developers.google.com/maps/launch-stages). Enables the Address Validation API to include additional information in the response. # Optional. Preview: This feature is in Preview (pre-GA). Pre-GA products and features might have limited support, and changes to pre-GA products and features might not be compatible with other pre-GA versions. Pre-GA Offerings are covered by the [Google Maps Platform Service Specific Terms](https://cloud.google.com/maps-platform/terms/maps-service-terms). For more information, see the [launch stage descriptions](https://developers.google.com/maps/launch-stages). Enables the Address Validation API to include additional information in the response.
    &quot;returnEnglishLatinAddress&quot;: True or False, # Preview: Return a [google.maps.addressvalidation.v1.Address] in English. See [google.maps.addressvalidation.v1.ValidationResult.english_latin_address] for details.
  },
  &quot;previousResponseId&quot;: &quot;A String&quot;, # This field must be empty for the first address validation request. If more requests are necessary to fully validate a single address (for example if the changes the user makes after the initial validation need to be re-validated), then each followup request must populate this field with the response_id from the very first response in the validation sequence.
  &quot;sessionToken&quot;: &quot;A String&quot;, # Optional. A string which identifies an Autocomplete session for billing purposes. Must be a URL and filename safe base64 string with at most 36 ASCII characters in length. Otherwise an INVALID_ARGUMENT error is returned. The session begins when the user makes an Autocomplete query, and concludes when they select a place and a call to Place Details or Address Validation is made. Each session can have multiple Autocomplete queries, followed by one Place Details or Address Validation request. The credentials used for each request within a session must belong to the same Google Cloud Console project. Once a session has concluded, the token is no longer valid; your app must generate a fresh token for each session. If the `sessionToken` parameter is omitted, or if you reuse a session token, the session is charged as if no session token was provided (each request is billed separately). Note: Address Validation can only be used in sessions with the Autocomplete (New) API, not the Autocomplete API. See https://developers.google.com/maps/documentation/places/web-service/session-pricing for more details.
}

  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # The response to an address validation request.
  &quot;responseId&quot;: &quot;A String&quot;, # The UUID that identifies this response. If the address needs to be re-validated, this UUID *must* accompany the new request.
  &quot;result&quot;: { # The result of validating an address. # The result of the address validation.
    &quot;address&quot;: { # Details of the post-processed address. Post-processing includes correcting misspelled parts of the address, replacing incorrect parts, and inferring missing parts. # Information about the address itself as opposed to the geocode.
      &quot;addressComponents&quot;: [ # Unordered list. The individual address components of the formatted and corrected address, along with validation information. This provides information on the validation status of the individual components. Address components are not ordered in a particular way. Do not make any assumptions on the ordering of the address components in the list.
        { # Represents an address component, such as a street, city, or state.
          &quot;componentName&quot;: { # A wrapper for the name of the component. # The name for this component.
            &quot;languageCode&quot;: &quot;A String&quot;, # The BCP-47 language code. This will not be present if the component name is not associated with a language, such as a street number.
            &quot;text&quot;: &quot;A String&quot;, # The name text. For example, &quot;5th Avenue&quot; for a street name or &quot;1253&quot; for a street number.
          },
          &quot;componentType&quot;: &quot;A String&quot;, # The type of the address component. See [Table 2: Additional types returned by the Places service](https://developers.google.com/places/web-service/supported_types#table2) for a list of possible types.
          &quot;confirmationLevel&quot;: &quot;A String&quot;, # Indicates the level of certainty that we have that the component is correct.
          &quot;inferred&quot;: True or False, # Indicates that the component was not part of the input, but we inferred it for the address location and believe it should be provided for a complete address.
          &quot;replaced&quot;: True or False, # Indicates the name of the component was replaced with a completely different one, for example a wrong postal code being replaced with one that is correct for the address. This is not a cosmetic change, the input component has been changed to a different one.
          &quot;spellCorrected&quot;: True or False, # Indicates a correction to a misspelling in the component name. The API does not always flag changes from one spelling variant to another, such as when changing &quot;centre&quot; to &quot;center&quot;. It also does not always flag common misspellings, such as when changing &quot;Amphitheater Pkwy&quot; to &quot;Amphitheatre Pkwy&quot;.
          &quot;unexpected&quot;: True or False, # Indicates an address component that is not expected to be present in a postal address for the given region. We have retained it only because it was part of the input.
        },
      ],
      &quot;formattedAddress&quot;: &quot;A String&quot;, # The post-processed address, formatted as a single-line address following the address formatting rules of the region where the address is located.
      &quot;missingComponentTypes&quot;: [ # The types of components that were expected to be present in a correctly formatted mailing address but were not found in the input AND could not be inferred. Components of this type are not present in `formatted_address`, `postal_address`, or `address_components`. An example might be `[&#x27;street_number&#x27;, &#x27;route&#x27;]` for an input like &quot;Boulder, Colorado, 80301, USA&quot;. The list of possible types can be found [here](https://developers.google.com/maps/documentation/geocoding/requests-geocoding#Types).
        &quot;A String&quot;,
      ],
      &quot;postalAddress&quot;: { # Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains). In typical usage an address would be created via user input or from importing existing data, depending on the type of process. Advice on address input / editing: - Use an internationalization-ready address widget such as https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used. For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478 # The post-processed address represented as a postal address.
        &quot;addressLines&quot;: [ # Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. &quot;Austin, TX&quot;), it is important that the line order is clear. The order of address lines should be &quot;envelope order&quot; for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. &quot;ja&quot; for large-to-small ordering and &quot;ja-Latn&quot; or &quot;en&quot; for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
          &quot;A String&quot;,
        ],
        &quot;administrativeArea&quot;: &quot;A String&quot;, # Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. &quot;Barcelona&quot; and not &quot;Catalonia&quot;). Many countries don&#x27;t use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
        &quot;languageCode&quot;: &quot;A String&quot;, # Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address&#x27; country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: &quot;zh-Hant&quot;, &quot;ja&quot;, &quot;ja-Latn&quot;, &quot;en&quot;.
        &quot;locality&quot;: &quot;A String&quot;, # Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
        &quot;organization&quot;: &quot;A String&quot;, # Optional. The name of the organization at the address.
        &quot;postalCode&quot;: &quot;A String&quot;, # Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
        &quot;recipients&quot;: [ # Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain &quot;care of&quot; information.
          &quot;A String&quot;,
        ],
        &quot;regionCode&quot;: &quot;A String&quot;, # Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See https://cldr.unicode.org/ and https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: &quot;CH&quot; for Switzerland.
        &quot;revision&quot;: 42, # The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
        &quot;sortingCode&quot;: &quot;A String&quot;, # Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like &quot;CEDEX&quot;, optionally followed by a number (e.g. &quot;CEDEX 7&quot;), or just a number alone, representing the &quot;sector code&quot; (Jamaica), &quot;delivery area indicator&quot; (Malawi) or &quot;post office indicator&quot; (e.g. CÃ´te d&#x27;Ivoire).
        &quot;sublocality&quot;: &quot;A String&quot;, # Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
      },
      &quot;unconfirmedComponentTypes&quot;: [ # The types of the components that are present in the `address_components` but could not be confirmed to be correct. This field is provided for the sake of convenience: its contents are equivalent to iterating through the `address_components` to find the types of all the components where the confirmation_level is not CONFIRMED or the inferred flag is not set to `true`. The list of possible types can be found [here](https://developers.google.com/maps/documentation/geocoding/requests-geocoding#Types).
        &quot;A String&quot;,
      ],
      &quot;unresolvedTokens&quot;: [ # Any tokens in the input that could not be resolved. This might be an input that was not recognized as a valid part of an address (for example in an input like &quot;123235253253 Main St, San Francisco, CA, 94105&quot;, the unresolved tokens may look like `[&quot;123235253253&quot;]` since that does not look like a valid street number.
        &quot;A String&quot;,
      ],
    },
    &quot;englishLatinAddress&quot;: { # Details of the post-processed address. Post-processing includes correcting misspelled parts of the address, replacing incorrect parts, and inferring missing parts. # Preview: This feature is in Preview (pre-GA). Pre-GA products and features might have limited support, and changes to pre-GA products and features might not be compatible with other pre-GA versions. Pre-GA Offerings are covered by the [Google Maps Platform Service Specific Terms](https://cloud.google.com/maps-platform/terms/maps-service-terms). For more information, see the [launch stage descriptions](https://developers.google.com/maps/launch-stages). The address translated to English. Translated addresses are not reusable as API input. The service provides them so that the user can use their native language to confirm or deny the validation of the originally-provided address. If part of the address doesn&#x27;t have an English translation, the service returns that part in an alternate language that uses a Latin script. See [here](https://developers.google.com/maps/documentation/address-validation/convert-addresses-english) for an explanation of how the alternate language is selected. If part of the address doesn&#x27;t have any translations or transliterations in a language that uses a Latin script, the service returns that part in the local language associated with the address. Enable this output by using the [google.maps.addressvalidation.v1.LanguageOptions.return_english_latin_address] flag. Note: the [google.maps.addressvalidation.v1.Address.unconfirmed_component_types] field in the `english_latin_address` and the [google.maps.addressvalidation.v1.AddressComponent.confirmation_level] fields in `english_latin_address.address_components` are not populated.
      &quot;addressComponents&quot;: [ # Unordered list. The individual address components of the formatted and corrected address, along with validation information. This provides information on the validation status of the individual components. Address components are not ordered in a particular way. Do not make any assumptions on the ordering of the address components in the list.
        { # Represents an address component, such as a street, city, or state.
          &quot;componentName&quot;: { # A wrapper for the name of the component. # The name for this component.
            &quot;languageCode&quot;: &quot;A String&quot;, # The BCP-47 language code. This will not be present if the component name is not associated with a language, such as a street number.
            &quot;text&quot;: &quot;A String&quot;, # The name text. For example, &quot;5th Avenue&quot; for a street name or &quot;1253&quot; for a street number.
          },
          &quot;componentType&quot;: &quot;A String&quot;, # The type of the address component. See [Table 2: Additional types returned by the Places service](https://developers.google.com/places/web-service/supported_types#table2) for a list of possible types.
          &quot;confirmationLevel&quot;: &quot;A String&quot;, # Indicates the level of certainty that we have that the component is correct.
          &quot;inferred&quot;: True or False, # Indicates that the component was not part of the input, but we inferred it for the address location and believe it should be provided for a complete address.
          &quot;replaced&quot;: True or False, # Indicates the name of the component was replaced with a completely different one, for example a wrong postal code being replaced with one that is correct for the address. This is not a cosmetic change, the input component has been changed to a different one.
          &quot;spellCorrected&quot;: True or False, # Indicates a correction to a misspelling in the component name. The API does not always flag changes from one spelling variant to another, such as when changing &quot;centre&quot; to &quot;center&quot;. It also does not always flag common misspellings, such as when changing &quot;Amphitheater Pkwy&quot; to &quot;Amphitheatre Pkwy&quot;.
          &quot;unexpected&quot;: True or False, # Indicates an address component that is not expected to be present in a postal address for the given region. We have retained it only because it was part of the input.
        },
      ],
      &quot;formattedAddress&quot;: &quot;A String&quot;, # The post-processed address, formatted as a single-line address following the address formatting rules of the region where the address is located.
      &quot;missingComponentTypes&quot;: [ # The types of components that were expected to be present in a correctly formatted mailing address but were not found in the input AND could not be inferred. Components of this type are not present in `formatted_address`, `postal_address`, or `address_components`. An example might be `[&#x27;street_number&#x27;, &#x27;route&#x27;]` for an input like &quot;Boulder, Colorado, 80301, USA&quot;. The list of possible types can be found [here](https://developers.google.com/maps/documentation/geocoding/requests-geocoding#Types).
        &quot;A String&quot;,
      ],
      &quot;postalAddress&quot;: { # Represents a postal address, e.g. for postal delivery or payments addresses. Given a postal address, a postal service can deliver items to a premise, P.O. Box or similar. It is not intended to model geographical locations (roads, towns, mountains). In typical usage an address would be created via user input or from importing existing data, depending on the type of process. Advice on address input / editing: - Use an internationalization-ready address widget such as https://github.com/google/libaddressinput) - Users should not be presented with UI elements for input or editing of fields outside countries where that field is used. For more guidance on how to use this schema, please see: https://support.google.com/business/answer/6397478 # The post-processed address represented as a postal address.
        &quot;addressLines&quot;: [ # Unstructured address lines describing the lower levels of an address. Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. &quot;Austin, TX&quot;), it is important that the line order is clear. The order of address lines should be &quot;envelope order&quot; for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. &quot;ja&quot; for large-to-small ordering and &quot;ja-Latn&quot; or &quot;en&quot; for small-to-large). This way, the most specific line of an address can be selected based on the language. The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved. Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
          &quot;A String&quot;,
        ],
        &quot;administrativeArea&quot;: &quot;A String&quot;, # Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. &quot;Barcelona&quot; and not &quot;Catalonia&quot;). Many countries don&#x27;t use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
        &quot;languageCode&quot;: &quot;A String&quot;, # Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address&#x27; country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations. If this value is not known, it should be omitted (rather than specifying a possibly incorrect default). Examples: &quot;zh-Hant&quot;, &quot;ja&quot;, &quot;ja-Latn&quot;, &quot;en&quot;.
        &quot;locality&quot;: &quot;A String&quot;, # Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
        &quot;organization&quot;: &quot;A String&quot;, # Optional. The name of the organization at the address.
        &quot;postalCode&quot;: &quot;A String&quot;, # Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
        &quot;recipients&quot;: [ # Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain &quot;care of&quot; information.
          &quot;A String&quot;,
        ],
        &quot;regionCode&quot;: &quot;A String&quot;, # Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See https://cldr.unicode.org/ and https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: &quot;CH&quot; for Switzerland.
        &quot;revision&quot;: 42, # The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision. All new revisions **must** be backward compatible with old revisions.
        &quot;sortingCode&quot;: &quot;A String&quot;, # Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like &quot;CEDEX&quot;, optionally followed by a number (e.g. &quot;CEDEX 7&quot;), or just a number alone, representing the &quot;sector code&quot; (Jamaica), &quot;delivery area indicator&quot; (Malawi) or &quot;post office indicator&quot; (e.g. CÃ´te d&#x27;Ivoire).
        &quot;sublocality&quot;: &quot;A String&quot;, # Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
      },
      &quot;unconfirmedComponentTypes&quot;: [ # The types of the components that are present in the `address_components` but could not be confirmed to be correct. This field is provided for the sake of convenience: its contents are equivalent to iterating through the `address_components` to find the types of all the components where the confirmation_level is not CONFIRMED or the inferred flag is not set to `true`. The list of possible types can be found [here](https://developers.google.com/maps/documentation/geocoding/requests-geocoding#Types).
        &quot;A String&quot;,
      ],
      &quot;unresolvedTokens&quot;: [ # Any tokens in the input that could not be resolved. This might be an input that was not recognized as a valid part of an address (for example in an input like &quot;123235253253 Main St, San Francisco, CA, 94105&quot;, the unresolved tokens may look like `[&quot;123235253253&quot;]` since that does not look like a valid street number.
        &quot;A String&quot;,
      ],
    },
    &quot;geocode&quot;: { # Contains information about the place the input was geocoded to. # Information about the location and place that the address geocoded to.
      &quot;bounds&quot;: { # A latitude-longitude viewport, represented as two diagonally opposite `low` and `high` points. A viewport is considered a closed region, i.e. it includes its boundary. The latitude bounds must range between -90 to 90 degrees inclusive, and the longitude bounds must range between -180 to 180 degrees inclusive. Various cases include: - If `low` = `high`, the viewport consists of that single point. - If `low.longitude` &gt; `high.longitude`, the longitude range is inverted (the viewport crosses the 180 degree longitude line). - If `low.longitude` = -180 degrees and `high.longitude` = 180 degrees, the viewport includes all longitudes. - If `low.longitude` = 180 degrees and `high.longitude` = -180 degrees, the longitude range is empty. - If `low.latitude` &gt; `high.latitude`, the latitude range is empty. Both `low` and `high` must be populated, and the represented box cannot be empty (as specified by the definitions above). An empty viewport will result in an error. For example, this viewport fully encloses New York City: { &quot;low&quot;: { &quot;latitude&quot;: 40.477398, &quot;longitude&quot;: -74.259087 }, &quot;high&quot;: { &quot;latitude&quot;: 40.91618, &quot;longitude&quot;: -73.70018 } } # The bounds of the geocoded place.
        &quot;high&quot;: { # An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this object must conform to the WGS84 standard. Values must be within normalized ranges. # Required. The high point of the viewport.
          &quot;latitude&quot;: 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
          &quot;longitude&quot;: 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
        },
        &quot;low&quot;: { # An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this object must conform to the WGS84 standard. Values must be within normalized ranges. # Required. The low point of the viewport.
          &quot;latitude&quot;: 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
          &quot;longitude&quot;: 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
        },
      },
      &quot;featureSizeMeters&quot;: 3.14, # The size of the geocoded place, in meters. This is another measure of the coarseness of the geocoded location, but in physical size rather than in semantic meaning.
      &quot;location&quot;: { # An object that represents a latitude/longitude pair. This is expressed as a pair of doubles to represent degrees latitude and degrees longitude. Unless specified otherwise, this object must conform to the WGS84 standard. Values must be within normalized ranges. # The geocoded location of the input. Using place IDs is preferred over using addresses, latitude/longitude coordinates, or plus codes. Using coordinates when routing or calculating driving directions will always result in the point being snapped to the road nearest to those coordinates. This may not be a road that will quickly or safely lead to the destination and may not be near an access point to the property. Additionally, when a location is reverse geocoded, there is no guarantee that the returned address will match the original.
        &quot;latitude&quot;: 3.14, # The latitude in degrees. It must be in the range [-90.0, +90.0].
        &quot;longitude&quot;: 3.14, # The longitude in degrees. It must be in the range [-180.0, +180.0].
      },
      &quot;placeId&quot;: &quot;A String&quot;, # The PlaceID of the place this input geocodes to. For more information about Place IDs see [here](https://developers.google.com/maps/documentation/places/web-service/place-id).
      &quot;placeTypes&quot;: [ # The type(s) of place that the input geocoded to. For example, `[&#x27;locality&#x27;, &#x27;political&#x27;]`. The full list of types can be found [here](https://developers.google.com/maps/documentation/geocoding/requests-geocoding#Types).
        &quot;A String&quot;,
      ],
      &quot;plusCode&quot;: { # Plus code (http://plus.codes) is a location reference with two formats: global code defining a 14mx14m (1/8000th of a degree) or smaller rectangle, and compound code, replacing the prefix with a reference location. # The plus code corresponding to the `location`.
        &quot;compoundCode&quot;: &quot;A String&quot;, # Place&#x27;s compound code, such as &quot;33GV+HQ, Ramberg, Norway&quot;, containing the suffix of the global code and replacing the prefix with a formatted name of a reference entity.
        &quot;globalCode&quot;: &quot;A String&quot;, # Place&#x27;s global (full) code, such as &quot;9FWM33GV+HQ&quot;, representing an 1/8000 by 1/8000 degree area (~14 by 14 meters).
      },
    },
    &quot;metadata&quot;: { # The metadata for the address. `metadata` is not guaranteed to be fully populated for every address sent to the Address Validation API. # Other information relevant to deliverability. `metadata` is not guaranteed to be fully populated for every address sent to the Address Validation API.
      &quot;business&quot;: True or False, # Indicates that this is the address of a business. If unset, indicates that the value is unknown.
      &quot;poBox&quot;: True or False, # Indicates that the address of a PO box. If unset, indicates that the value is unknown.
      &quot;residential&quot;: True or False, # Indicates that this is the address of a residence. If unset, indicates that the value is unknown.
    },
    &quot;uspsData&quot;: { # The USPS data for the address. `uspsData` is not guaranteed to be fully populated for every US or PR address sent to the Address Validation API. It&#x27;s recommended to integrate the backup address fields in the response if you utilize uspsData as the primary part of the response. # Extra deliverability flags provided by USPS. Only provided in region `US` and `PR`.
      &quot;abbreviatedCity&quot;: &quot;A String&quot;, # Abbreviated city.
      &quot;addressRecordType&quot;: &quot;A String&quot;, # Type of the address record that matches the input address. * `F`: FIRM. This is a match to a Firm Record, which is the finest level of match available for an address. * `G`: GENERAL DELIVERY. This is a match to a General Delivery record. * `H`: BUILDING / APARTMENT. This is a match to a Building or Apartment record. * `P`: POST OFFICE BOX. This is a match to a Post Office Box. * `R`: RURAL ROUTE or HIGHWAY CONTRACT: This is a match to either a Rural Route or a Highway Contract record, both of which may have associated Box Number ranges. * `S`: STREET RECORD: This is a match to a Street record containing a valid primary number range.
      &quot;carrierRoute&quot;: &quot;A String&quot;, # The carrier route code. A four character code consisting of a one letter prefix and a three digit route designator. Prefixes: * `C`: Carrier route (or city route) * `R`: Rural route * `H`: Highway Contract Route * `B`: Post Office Box Section * `G`: General delivery unit
      &quot;carrierRouteIndicator&quot;: &quot;A String&quot;, # Carrier route rate sort indicator.
      &quot;cassProcessed&quot;: True or False, # Indicator that the request has been CASS processed.
      &quot;county&quot;: &quot;A String&quot;, # County name.
      &quot;defaultAddress&quot;: True or False, # Indicator that a default address was found, but more specific addresses exists.
      &quot;deliveryPointCheckDigit&quot;: &quot;A String&quot;, # The delivery point check digit. This number is added to the end of the delivery_point_barcode for mechanically scanned mail. Adding all the digits of the delivery_point_barcode, delivery_point_check_digit, postal code, and ZIP+4 together should yield a number divisible by 10.
      &quot;deliveryPointCode&quot;: &quot;A String&quot;, # 2 digit delivery point code
      &quot;dpvCmra&quot;: &quot;A String&quot;, # Indicates if the address is a CMRA (Commercial Mail Receiving Agency)--a private business receiving mail for clients. Returns a single character. * `Y`: The address is a CMRA * `N`: The address is not a CMRA
      &quot;dpvConfirmation&quot;: &quot;A String&quot;, # The possible values for DPV confirmation. Returns a single character or returns no value. * `N`: Primary and any secondary number information failed to DPV confirm. * `D`: Address was DPV confirmed for the primary number only, and the secondary number information was missing. * `S`: Address was DPV confirmed for the primary number only, and the secondary number information was present but not confirmed. * `Y`: Address was DPV confirmed for primary and any secondary numbers. * Empty: If the response does not contain a `dpv_confirmation` value, the address was not submitted for DPV confirmation.
      &quot;dpvDoorNotAccessible&quot;: &quot;A String&quot;, # Flag indicates addresses where USPS cannot knock on a door to deliver mail. Returns a single character. * `Y`: The door is not accessible. * `N`: No indication the door is not accessible.
      &quot;dpvDrop&quot;: &quot;A String&quot;, # Flag indicates mail is delivered to a single receptable at a site. Returns a single character. * `Y`: The mail is delivered to a single receptable at a site. * `N`: The mail is not delivered to a single receptable at a site.
      &quot;dpvEnhancedDeliveryCode&quot;: &quot;A String&quot;, # Indicates that more than one DPV return code is valid for the address. Returns a single character. * `Y`: Address was DPV confirmed for primary and any secondary numbers. * `N`: Primary and any secondary number information failed to DPV confirm. * `S`: Address was DPV confirmed for the primary number only, and the secondary number information was present but not confirmed, or a single trailing alpha on a primary number was dropped to make a DPV match and secondary information required. * `D`: Address was DPV confirmed for the primary number only, and the secondary number information was missing. * `R`: Address confirmed but assigned to phantom route R777 and R779 and USPS delivery is not provided.
      &quot;dpvFootnote&quot;: &quot;A String&quot;, # The footnotes from delivery point validation. Multiple footnotes may be strung together in the same string. * `AA`: Input address matched to the ZIP+4 file * `A1`: Input address was not matched to the ZIP+4 file * `BB`: Matched to DPV (all components) * `CC`: Secondary number not matched and not required * `C1`: Secondary number not matched but required * `N1`: High-rise address missing secondary number * `M1`: Primary number missing * `M3`: Primary number invalid * `P1`: Input address PO, RR or HC box number missing * `P3`: Input address PO, RR, or HC Box number invalid * `F1`: Input address matched to a military address * `G1`: Input address matched to a general delivery address * `U1`: Input address matched to a unique ZIP code * `PB`: Input address matched to PBSA record * `RR`: DPV confirmed address with PMB information * `R1`: DPV confirmed address without PMB information * `R7`: Carrier Route R777 or R779 record * `IA`: Informed Address identified * `TA`: Primary number matched by dropping a trailing alpha
      &quot;dpvNoSecureLocation&quot;: &quot;A String&quot;, # Flag indicates door is accessible, but package will not be left due to security concerns. Returns a single character. * `Y`: The package will not be left due to security concerns. * `N`: No indication the package will not be left due to security concerns.
      &quot;dpvNoStat&quot;: &quot;A String&quot;, # Is this a no stat address or an active address? No stat addresses are ones which are not continuously occupied or addresses that the USPS does not service. Returns a single character. * `Y`: The address is not active * `N`: The address is active
      &quot;dpvNoStatReasonCode&quot;: 42, # Indicates the NoStat type. Returns a reason code as int. * `1`: IDA (Internal Drop Address) â Addresses that do not receive mail directly from the USPS but are delivered to a drop address that services them. * `2`: CDS - Addresses that have not yet become deliverable. For example, a new subdivision where lots and primary numbers have been determined, but no structure exists yet for occupancy. * `3`: Collision - Addresses that do not actually DPV confirm. * `4`: CMZ (College, Military and Other Types) - ZIP + 4 records USPS has incorporated into the data. * `5`: Regular - Indicates addresses not receiving delivery and the addresses are not counted as possible deliveries. * `6`: Secondary Required - The address requires secondary information.
      &quot;dpvNonDeliveryDays&quot;: &quot;A String&quot;, # Flag indicates mail delivery is not performed every day of the week. Returns a single character. * `Y`: The mail delivery is not performed every day of the week. * `N`: No indication the mail delivery is not performed every day of the week.
      &quot;dpvNonDeliveryDaysValues&quot;: 42, # Integer identifying non-delivery days. It can be interrogated using bit flags: 0x40 â Sunday is a non-delivery day 0x20 â Monday is a non-delivery day 0x10 â Tuesday is a non-delivery day 0x08 â Wednesday is a non-delivery day 0x04 â Thursday is a non-delivery day 0x02 â Friday is a non-delivery day 0x01 â Saturday is a non-delivery day
      &quot;dpvPbsa&quot;: &quot;A String&quot;, # Indicates the address was matched to PBSA record. Returns a single character. * `Y`: The address was matched to PBSA record. * `N`: The address was not matched to PBSA record.
      &quot;dpvThrowback&quot;: &quot;A String&quot;, # Indicates that mail is not delivered to the street address. Returns a single character. * `Y`: The mail is not delivered to the street address. * `N`: The mail is delivered to the street address.
      &quot;dpvVacant&quot;: &quot;A String&quot;, # Is this place vacant? Returns a single character. * `Y`: The address is vacant * `N`: The address is not vacant
      &quot;elotFlag&quot;: &quot;A String&quot;, # eLOT Ascending/Descending Flag (A/D).
      &quot;elotNumber&quot;: &quot;A String&quot;, # Enhanced Line of Travel (eLOT) number.
      &quot;errorMessage&quot;: &quot;A String&quot;, # Error message for USPS data retrieval. This is populated when USPS processing is suspended because of the detection of artificially created addresses. The USPS data fields might not be populated when this error is present.
      &quot;ewsNoMatch&quot;: True or False, # The delivery address is matchable, but the EWS file indicates that an exact match will be available soon.
      &quot;fipsCountyCode&quot;: &quot;A String&quot;, # FIPS county code.
      &quot;lacsLinkIndicator&quot;: &quot;A String&quot;, # LACSLink indicator.
      &quot;lacsLinkReturnCode&quot;: &quot;A String&quot;, # LACSLink return code.
      &quot;pmbDesignator&quot;: &quot;A String&quot;, # PMB (Private Mail Box) unit designator.
      &quot;pmbNumber&quot;: &quot;A String&quot;, # PMB (Private Mail Box) number;
      &quot;poBoxOnlyPostalCode&quot;: True or False, # PO Box only postal code.
      &quot;postOfficeCity&quot;: &quot;A String&quot;, # Main post office city.
      &quot;postOfficeState&quot;: &quot;A String&quot;, # Main post office state.
      &quot;standardizedAddress&quot;: { # USPS representation of a US address. # USPS standardized address.
        &quot;city&quot;: &quot;A String&quot;, # City name.
        &quot;cityStateZipAddressLine&quot;: &quot;A String&quot;, # City + state + postal code.
        &quot;firm&quot;: &quot;A String&quot;, # Firm name.
        &quot;firstAddressLine&quot;: &quot;A String&quot;, # First address line.
        &quot;secondAddressLine&quot;: &quot;A String&quot;, # Second address line.
        &quot;state&quot;: &quot;A String&quot;, # 2 letter state code.
        &quot;urbanization&quot;: &quot;A String&quot;, # Puerto Rican urbanization name.
        &quot;zipCode&quot;: &quot;A String&quot;, # Postal code e.g. 10009.
        &quot;zipCodeExtension&quot;: &quot;A String&quot;, # 4-digit postal code extension e.g. 5023.
      },
      &quot;suitelinkFootnote&quot;: &quot;A String&quot;, # Footnotes from matching a street or highrise record to suite information. If business name match is found, the secondary number is returned. * `A`: SuiteLink record match, business address improved. * `00`: No match, business address is not improved.
    },
    &quot;verdict&quot;: { # High level overview of the address validation result and geocode. # Overall verdict flags
      &quot;addressComplete&quot;: True or False, # The address is considered complete if there are no unresolved tokens, no unexpected or missing address components. If unset, indicates that the value is `false`. See `missing_component_types`, `unresolved_tokens` or `unexpected` fields for more details.
      &quot;geocodeGranularity&quot;: &quot;A String&quot;, # Information about the granularity of the `geocode`. This can be understood as the semantic meaning of how coarse or fine the geocoded location is. This can differ from the `validation_granularity` above occasionally. For example, our database might record the existence of an apartment number but do not have a precise location for the apartment within a big apartment complex. In that case, the `validation_granularity` will be `SUB_PREMISE` but the `geocode_granularity` will be `PREMISE`.
      &quot;hasInferredComponents&quot;: True or False, # At least one address component was inferred (added) that wasn&#x27;t in the input, see [google.maps.addressvalidation.v1.Address.address_components] for details.
      &quot;hasReplacedComponents&quot;: True or False, # At least one address component was replaced, see [google.maps.addressvalidation.v1.Address.address_components] for details.
      &quot;hasUnconfirmedComponents&quot;: True or False, # At least one address component cannot be categorized or validated, see [google.maps.addressvalidation.v1.Address.address_components] for details.
      &quot;inputGranularity&quot;: &quot;A String&quot;, # The granularity of the **input** address. This is the result of parsing the input address and does not give any validation signals. For validation signals, refer to `validation_granularity` below. For example, if the input address includes a specific apartment number, then the `input_granularity` here will be `SUB_PREMISE`. If we cannot match the apartment number in the databases or the apartment number is invalid, the `validation_granularity` will likely be `PREMISE` or below.
      &quot;validationGranularity&quot;: &quot;A String&quot;, # The granularity level that the API can fully **validate** the address to. For example, an `validation_granularity` of `PREMISE` indicates all address components at the level of `PREMISE` or more coarse can be validated. Per address component validation result can be found in [google.maps.addressvalidation.v1.Address.address_components].
    },
  },
}</pre>
</div>

</body></html>