<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="clouddebugger_v2.html">Stackdriver Debugger API</a> . <a href="clouddebugger_v2.debugger.html">debugger</a> . <a href="clouddebugger_v2.debugger.debuggees.html">debuggees</a> . <a href="clouddebugger_v2.debugger.debuggees.breakpoints.html">breakpoints</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#delete">delete(debuggeeId, breakpointId, clientVersion=None, x__xgafv=None)</a></code></p>
<p class="firstline">Deletes the breakpoint from the debuggee.</p>
<p class="toc_element">
  <code><a href="#get">get(debuggeeId, breakpointId, clientVersion=None, x__xgafv=None)</a></code></p>
<p class="firstline">Gets breakpoint information.</p>
<p class="toc_element">
  <code><a href="#list">list(debuggeeId, includeAllUsers=None, includeInactive=None, x__xgafv=None, clientVersion=None, stripResults=None, action_value=None, waitToken=None)</a></code></p>
<p class="firstline">Lists all breakpoints for the debuggee.</p>
<p class="toc_element">
  <code><a href="#set">set(debuggeeId, body, clientVersion=None, x__xgafv=None)</a></code></p>
<p class="firstline">Sets the breakpoint to the debuggee.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="delete">delete(debuggeeId, breakpointId, clientVersion=None, x__xgafv=None)</code>
  <pre>Deletes the breakpoint from the debuggee.

Args:
  debuggeeId: string, ID of the debuggee whose breakpoint to delete. (required)
  breakpointId: string, ID of the breakpoint to delete. (required)
  clientVersion: string, The client version making the call.
Following: `domain/type/version` (e.g., `google.com/intellij/v1`).
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # A generic empty message that you can re-use to avoid defining duplicated
      # empty messages in your APIs. A typical example is to use it as the request
      # or the response type of an API method. For instance:
      #
      #     service Foo {
      #       rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
      #     }
      #
      # The JSON representation for `Empty` is empty JSON object `{}`.
  }</pre>
</div>

<div class="method">
    <code class="details" id="get">get(debuggeeId, breakpointId, clientVersion=None, x__xgafv=None)</code>
  <pre>Gets breakpoint information.

Args:
  debuggeeId: string, ID of the debuggee whose breakpoint to get. (required)
  breakpointId: string, ID of the breakpoint to get. (required)
  clientVersion: string, The client version making the call.
Following: `domain/type/version` (e.g., `google.com/intellij/v1`).
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response for getting breakpoint information.
    "breakpoint": { # Represents the breakpoint specification, status and results. # Complete breakpoint state.
        # The fields `id` and `location` are guaranteed to be set.
      "status": { # Represents a contextual status message. # Breakpoint status.
          #
          # The status includes an error flag and a human readable message.
          # This field is usually unset. The message can be either
          # informational or an error message. Regardless, clients should always
          # display the text message back to the user.
          #
          # Error status indicates complete failure of the breakpoint.
          #
          # Example (non-final state): `Still loading symbols...`
          #
          # Examples (final state):
          #
          # *   `Invalid line number` referring to location
          # *   `Field f not found in class C` referring to condition
          # The message can indicate an error or informational status, and refer to
          # specific parts of the containing object.
          # For example, the `Breakpoint.status` field can indicate an error referring
          # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
        "isError": True or False, # Distinguishes errors from informational messages.
        "refersTo": "A String", # Reference to which the message applies.
        "description": { # Represents a message with parameters. # Status message text.
          "parameters": [ # Optional parameters to be embedded into the message.
            "A String",
          ],
          "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
              # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
              # character.
              #
              # Examples:
              #
              # *   `Failed to load '$0' which helps debug $1 the first time it
              #     is loaded.  Again, $0 is very important.`
              # *   `Please pay $$10 to use $0 instead of $1.`
        },
      },
      "variableTable": [ # The `variable_table` exists to aid with computation, memory and network
          # traffic optimization.  It enables storing a variable once and reference
          # it from multiple variables, including variables stored in the
          # `variable_table` itself.
          # For example, the same `this` object, which may appear at many levels of
          # the stack, can have all of its data stored once in this table.  The
          # stack frame variables then would hold only a reference to it.
          #
          # The variable `var_table_index` field is an index into this repeated field.
          # The stored objects are nameless and get their name from the referencing
          # variable. The effective variable is a merge of the referencing variable
          # and the referenced variable.
        { # Represents a variable or an argument possibly of a compound object type.
            # Note how the following variables are represented:
            #
            # 1) A simple variable:
            #
            #     int x = 5
            #
            #     { name: "x", value: "5", type: "int" }  // Captured variable
            #
            # 2) A compound object:
            #
            #     struct T {
            #         int m1;
            #         int m2;
            #     };
            #     T x = { 3, 7 };
            #
            #     {  // Captured variable
            #         name: "x",
            #         type: "T",
            #         members { name: "m1", value: "3", type: "int" },
            #         members { name: "m2", value: "7", type: "int" }
            #     }
            #
            # 3) A pointer where the pointee was captured:
            #
            #     T x = { 3, 7 };
            #     T* p = &x;
            #
            #     {   // Captured variable
            #         name: "p",
            #         type: "T*",
            #         value: "0x00500500",
            #         members { name: "m1", value: "3", type: "int" },
            #         members { name: "m2", value: "7", type: "int" }
            #     }
            #
            # 4) A pointer where the pointee was not captured:
            #
            #     T* p = new T;
            #
            #     {   // Captured variable
            #         name: "p",
            #         type: "T*",
            #         value: "0x00400400"
            #         status { is_error: true, description { format: "unavailable" } }
            #     }
            #
            # The status should describe the reason for the missing value,
            # such as `<optimized out>`, `<inaccessible>`, `<pointers limit reached>`.
            #
            # Note that a null pointer should not have members.
            #
            # 5) An unnamed value:
            #
            #     int* p = new int(7);
            #
            #     {   // Captured variable
            #         name: "p",
            #         value: "0x00500500",
            #         type: "int*",
            #         members { value: "7", type: "int" } }
            #
            # 6) An unnamed pointer where the pointee was not captured:
            #
            #     int* p = new int(7);
            #     int** pp = &p;
            #
            #     {  // Captured variable
            #         name: "pp",
            #         value: "0x00500500",
            #         type: "int**",
            #         members {
            #             value: "0x00400400",
            #             type: "int*"
            #             status {
            #                 is_error: true,
            #                 description: { format: "unavailable" } }
            #             }
            #         }
            #     }
            #
            # To optimize computation, memory and network traffic, variables that
            # repeat in the output multiple times can be stored once in a shared
            # variable table and be referenced using the `var_table_index` field.  The
            # variables stored in the shared table are nameless and are essentially
            # a partition of the complete variable. To reconstruct the complete
            # variable, merge the referencing variable with the referenced variable.
            #
            # When using the shared variable table, the following variables:
            #
            #     T x = { 3, 7 };
            #     T* p = &x;
            #     T& r = x;
            #
            #     { name: "x", var_table_index: 3, type: "T" }  // Captured variables
            #     { name: "p", value "0x00500500", type="T*", var_table_index: 3 }
            #     { name: "r", type="T&", var_table_index: 3 }
            #
            #     {  // Shared variable table entry #3:
            #         members { name: "m1", value: "3", type: "int" },
            #         members { name: "m2", value: "7", type: "int" }
            #     }
            #
            # Note that the pointer address is stored with the referencing variable
            # and not with the referenced variable. This allows the referenced variable
            # to be shared between pointers and references.
            #
            # The type field is optional. The debugger agent may or may not support it.
          "status": { # Represents a contextual status message. # Status associated with the variable. This field will usually stay
              # unset. A status of a single variable only applies to that variable or
              # expression. The rest of breakpoint data still remains valid. Variables
              # might be reported in error state even when breakpoint is not in final
              # state.
              #
              # The message may refer to variable name with `refers_to` set to
              # `VARIABLE_NAME`. Alternatively `refers_to` will be set to `VARIABLE_VALUE`.
              # In either case variable value and members will be unset.
              #
              # Example of error message applied to name: `Invalid expression syntax`.
              #
              # Example of information message applied to value: `Not captured`.
              #
              # Examples of error message applied to value:
              #
              # *   `Malformed string`,
              # *   `Field f not found in class C`
              # *   `Null pointer dereference`
              # The message can indicate an error or informational status, and refer to
              # specific parts of the containing object.
              # For example, the `Breakpoint.status` field can indicate an error referring
              # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
            "isError": True or False, # Distinguishes errors from informational messages.
            "refersTo": "A String", # Reference to which the message applies.
            "description": { # Represents a message with parameters. # Status message text.
              "parameters": [ # Optional parameters to be embedded into the message.
                "A String",
              ],
              "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
                  # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
                  # character.
                  #
                  # Examples:
                  #
                  # *   `Failed to load '$0' which helps debug $1 the first time it
                  #     is loaded.  Again, $0 is very important.`
                  # *   `Please pay $$10 to use $0 instead of $1.`
            },
          },
          "name": "A String", # Name of the variable, if any.
          "varTableIndex": 42, # Reference to a variable in the shared variable table. More than
              # one variable can reference the same variable in the table. The
              # `var_table_index` field is an index into `variable_table` in Breakpoint.
          "value": "A String", # Simple value of the variable.
          "members": [ # Members contained or pointed to by the variable.
            # Object with schema name: Variable
          ],
          "type": "A String", # Variable type (e.g. `MyClass`). If the variable is split with
              # `var_table_index`, `type` goes next to `value`. The interpretation of
              # a type is agent specific. It is recommended to include the dynamic type
              # rather than a static type of an object.
        },
      ],
      "userEmail": "A String", # E-mail address of the user that created this breakpoint
      "logLevel": "A String", # Indicates the severity of the log. Only relevant when action is `LOG`.
      "labels": { # A set of custom breakpoint properties, populated by the agent, to be
          # displayed to the user.
        "a_key": "A String",
      },
      "stackFrames": [ # The stack at breakpoint time.
        { # Represents a stack frame context.
          "function": "A String", # Demangled function name at the call site.
          "arguments": [ # Set of arguments passed to this function.
              # Note that this might not be populated for all stack frames.
            { # Represents a variable or an argument possibly of a compound object type.
                # Note how the following variables are represented:
                #
                # 1) A simple variable:
                #
                #     int x = 5
                #
                #     { name: "x", value: "5", type: "int" }  // Captured variable
                #
                # 2) A compound object:
                #
                #     struct T {
                #         int m1;
                #         int m2;
                #     };
                #     T x = { 3, 7 };
                #
                #     {  // Captured variable
                #         name: "x",
                #         type: "T",
                #         members { name: "m1", value: "3", type: "int" },
                #         members { name: "m2", value: "7", type: "int" }
                #     }
                #
                # 3) A pointer where the pointee was captured:
                #
                #     T x = { 3, 7 };
                #     T* p = &x;
                #
                #     {   // Captured variable
                #         name: "p",
                #         type: "T*",
                #         value: "0x00500500",
                #         members { name: "m1", value: "3", type: "int" },
                #         members { name: "m2", value: "7", type: "int" }
                #     }
                #
                # 4) A pointer where the pointee was not captured:
                #
                #     T* p = new T;
                #
                #     {   // Captured variable
                #         name: "p",
                #         type: "T*",
                #         value: "0x00400400"
                #         status { is_error: true, description { format: "unavailable" } }
                #     }
                #
                # The status should describe the reason for the missing value,
                # such as `<optimized out>`, `<inaccessible>`, `<pointers limit reached>`.
                #
                # Note that a null pointer should not have members.
                #
                # 5) An unnamed value:
                #
                #     int* p = new int(7);
                #
                #     {   // Captured variable
                #         name: "p",
                #         value: "0x00500500",
                #         type: "int*",
                #         members { value: "7", type: "int" } }
                #
                # 6) An unnamed pointer where the pointee was not captured:
                #
                #     int* p = new int(7);
                #     int** pp = &p;
                #
                #     {  // Captured variable
                #         name: "pp",
                #         value: "0x00500500",
                #         type: "int**",
                #         members {
                #             value: "0x00400400",
                #             type: "int*"
                #             status {
                #                 is_error: true,
                #                 description: { format: "unavailable" } }
                #             }
                #         }
                #     }
                #
                # To optimize computation, memory and network traffic, variables that
                # repeat in the output multiple times can be stored once in a shared
                # variable table and be referenced using the `var_table_index` field.  The
                # variables stored in the shared table are nameless and are essentially
                # a partition of the complete variable. To reconstruct the complete
                # variable, merge the referencing variable with the referenced variable.
                #
                # When using the shared variable table, the following variables:
                #
                #     T x = { 3, 7 };
                #     T* p = &x;
                #     T& r = x;
                #
                #     { name: "x", var_table_index: 3, type: "T" }  // Captured variables
                #     { name: "p", value "0x00500500", type="T*", var_table_index: 3 }
                #     { name: "r", type="T&", var_table_index: 3 }
                #
                #     {  // Shared variable table entry #3:
                #         members { name: "m1", value: "3", type: "int" },
                #         members { name: "m2", value: "7", type: "int" }
                #     }
                #
                # Note that the pointer address is stored with the referencing variable
                # and not with the referenced variable. This allows the referenced variable
                # to be shared between pointers and references.
                #
                # The type field is optional. The debugger agent may or may not support it.
              "status": { # Represents a contextual status message. # Status associated with the variable. This field will usually stay
                  # unset. A status of a single variable only applies to that variable or
                  # expression. The rest of breakpoint data still remains valid. Variables
                  # might be reported in error state even when breakpoint is not in final
                  # state.
                  #
                  # The message may refer to variable name with `refers_to` set to
                  # `VARIABLE_NAME`. Alternatively `refers_to` will be set to `VARIABLE_VALUE`.
                  # In either case variable value and members will be unset.
                  #
                  # Example of error message applied to name: `Invalid expression syntax`.
                  #
                  # Example of information message applied to value: `Not captured`.
                  #
                  # Examples of error message applied to value:
                  #
                  # *   `Malformed string`,
                  # *   `Field f not found in class C`
                  # *   `Null pointer dereference`
                  # The message can indicate an error or informational status, and refer to
                  # specific parts of the containing object.
                  # For example, the `Breakpoint.status` field can indicate an error referring
                  # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
                "isError": True or False, # Distinguishes errors from informational messages.
                "refersTo": "A String", # Reference to which the message applies.
                "description": { # Represents a message with parameters. # Status message text.
                  "parameters": [ # Optional parameters to be embedded into the message.
                    "A String",
                  ],
                  "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
                      # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
                      # character.
                      #
                      # Examples:
                      #
                      # *   `Failed to load '$0' which helps debug $1 the first time it
                      #     is loaded.  Again, $0 is very important.`
                      # *   `Please pay $$10 to use $0 instead of $1.`
                },
              },
              "name": "A String", # Name of the variable, if any.
              "varTableIndex": 42, # Reference to a variable in the shared variable table. More than
                  # one variable can reference the same variable in the table. The
                  # `var_table_index` field is an index into `variable_table` in Breakpoint.
              "value": "A String", # Simple value of the variable.
              "members": [ # Members contained or pointed to by the variable.
                # Object with schema name: Variable
              ],
              "type": "A String", # Variable type (e.g. `MyClass`). If the variable is split with
                  # `var_table_index`, `type` goes next to `value`. The interpretation of
                  # a type is agent specific. It is recommended to include the dynamic type
                  # rather than a static type of an object.
            },
          ],
          "locals": [ # Set of local variables at the stack frame location.
              # Note that this might not be populated for all stack frames.
            { # Represents a variable or an argument possibly of a compound object type.
                # Note how the following variables are represented:
                #
                # 1) A simple variable:
                #
                #     int x = 5
                #
                #     { name: "x", value: "5", type: "int" }  // Captured variable
                #
                # 2) A compound object:
                #
                #     struct T {
                #         int m1;
                #         int m2;
                #     };
                #     T x = { 3, 7 };
                #
                #     {  // Captured variable
                #         name: "x",
                #         type: "T",
                #         members { name: "m1", value: "3", type: "int" },
                #         members { name: "m2", value: "7", type: "int" }
                #     }
                #
                # 3) A pointer where the pointee was captured:
                #
                #     T x = { 3, 7 };
                #     T* p = &x;
                #
                #     {   // Captured variable
                #         name: "p",
                #         type: "T*",
                #         value: "0x00500500",
                #         members { name: "m1", value: "3", type: "int" },
                #         members { name: "m2", value: "7", type: "int" }
                #     }
                #
                # 4) A pointer where the pointee was not captured:
                #
                #     T* p = new T;
                #
                #     {   // Captured variable
                #         name: "p",
                #         type: "T*",
                #         value: "0x00400400"
                #         status { is_error: true, description { format: "unavailable" } }
                #     }
                #
                # The status should describe the reason for the missing value,
                # such as `<optimized out>`, `<inaccessible>`, `<pointers limit reached>`.
                #
                # Note that a null pointer should not have members.
                #
                # 5) An unnamed value:
                #
                #     int* p = new int(7);
                #
                #     {   // Captured variable
                #         name: "p",
                #         value: "0x00500500",
                #         type: "int*",
                #         members { value: "7", type: "int" } }
                #
                # 6) An unnamed pointer where the pointee was not captured:
                #
                #     int* p = new int(7);
                #     int** pp = &p;
                #
                #     {  // Captured variable
                #         name: "pp",
                #         value: "0x00500500",
                #         type: "int**",
                #         members {
                #             value: "0x00400400",
                #             type: "int*"
                #             status {
                #                 is_error: true,
                #                 description: { format: "unavailable" } }
                #             }
                #         }
                #     }
                #
                # To optimize computation, memory and network traffic, variables that
                # repeat in the output multiple times can be stored once in a shared
                # variable table and be referenced using the `var_table_index` field.  The
                # variables stored in the shared table are nameless and are essentially
                # a partition of the complete variable. To reconstruct the complete
                # variable, merge the referencing variable with the referenced variable.
                #
                # When using the shared variable table, the following variables:
                #
                #     T x = { 3, 7 };
                #     T* p = &x;
                #     T& r = x;
                #
                #     { name: "x", var_table_index: 3, type: "T" }  // Captured variables
                #     { name: "p", value "0x00500500", type="T*", var_table_index: 3 }
                #     { name: "r", type="T&", var_table_index: 3 }
                #
                #     {  // Shared variable table entry #3:
                #         members { name: "m1", value: "3", type: "int" },
                #         members { name: "m2", value: "7", type: "int" }
                #     }
                #
                # Note that the pointer address is stored with the referencing variable
                # and not with the referenced variable. This allows the referenced variable
                # to be shared between pointers and references.
                #
                # The type field is optional. The debugger agent may or may not support it.
              "status": { # Represents a contextual status message. # Status associated with the variable. This field will usually stay
                  # unset. A status of a single variable only applies to that variable or
                  # expression. The rest of breakpoint data still remains valid. Variables
                  # might be reported in error state even when breakpoint is not in final
                  # state.
                  #
                  # The message may refer to variable name with `refers_to` set to
                  # `VARIABLE_NAME`. Alternatively `refers_to` will be set to `VARIABLE_VALUE`.
                  # In either case variable value and members will be unset.
                  #
                  # Example of error message applied to name: `Invalid expression syntax`.
                  #
                  # Example of information message applied to value: `Not captured`.
                  #
                  # Examples of error message applied to value:
                  #
                  # *   `Malformed string`,
                  # *   `Field f not found in class C`
                  # *   `Null pointer dereference`
                  # The message can indicate an error or informational status, and refer to
                  # specific parts of the containing object.
                  # For example, the `Breakpoint.status` field can indicate an error referring
                  # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
                "isError": True or False, # Distinguishes errors from informational messages.
                "refersTo": "A String", # Reference to which the message applies.
                "description": { # Represents a message with parameters. # Status message text.
                  "parameters": [ # Optional parameters to be embedded into the message.
                    "A String",
                  ],
                  "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
                      # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
                      # character.
                      #
                      # Examples:
                      #
                      # *   `Failed to load '$0' which helps debug $1 the first time it
                      #     is loaded.  Again, $0 is very important.`
                      # *   `Please pay $$10 to use $0 instead of $1.`
                },
              },
              "name": "A String", # Name of the variable, if any.
              "varTableIndex": 42, # Reference to a variable in the shared variable table. More than
                  # one variable can reference the same variable in the table. The
                  # `var_table_index` field is an index into `variable_table` in Breakpoint.
              "value": "A String", # Simple value of the variable.
              "members": [ # Members contained or pointed to by the variable.
                # Object with schema name: Variable
              ],
              "type": "A String", # Variable type (e.g. `MyClass`). If the variable is split with
                  # `var_table_index`, `type` goes next to `value`. The interpretation of
                  # a type is agent specific. It is recommended to include the dynamic type
                  # rather than a static type of an object.
            },
          ],
          "location": { # Represents a location in the source code. # Source location of the call site.
            "path": "A String", # Path to the source file within the source context of the target binary.
            "line": 42, # Line inside the file. The first line in the file has the value `1`.
          },
        },
      ],
      "createTime": "A String", # Time this breakpoint was created by the server in seconds resolution.
      "expressions": [ # List of read-only expressions to evaluate at the breakpoint location.
          # The expressions are composed using expressions in the programming language
          # at the source location. If the breakpoint action is `LOG`, the evaluated
          # expressions are included in log statements.
        "A String",
      ],
      "location": { # Represents a location in the source code. # Breakpoint source location.
        "path": "A String", # Path to the source file within the source context of the target binary.
        "line": 42, # Line inside the file. The first line in the file has the value `1`.
      },
      "finalTime": "A String", # Time this breakpoint was finalized as seen by the server in seconds
          # resolution.
      "action": "A String", # Action that the agent should perform when the code at the
          # breakpoint location is hit.
      "logMessageFormat": "A String", # Only relevant when action is `LOG`. Defines the message to log when
          # the breakpoint hits. The message may include parameter placeholders `$0`,
          # `$1`, etc. These placeholders are replaced with the evaluated value
          # of the appropriate expression. Expressions not referenced in
          # `log_message_format` are not logged.
          #
          # Example: `Message received, id = $0, count = $1` with
          # `expressions` = `[ message.id, message.count ]`.
      "isFinalState": True or False, # When true, indicates that this is a final result and the
          # breakpoint state will not change from here on.
      "evaluatedExpressions": [ # Values of evaluated expressions at breakpoint time.
          # The evaluated expressions appear in exactly the same order they
          # are listed in the `expressions` field.
          # The `name` field holds the original expression text, the `value` or
          # `members` field holds the result of the evaluated expression.
          # If the expression cannot be evaluated, the `status` inside the `Variable`
          # will indicate an error and contain the error text.
        { # Represents a variable or an argument possibly of a compound object type.
            # Note how the following variables are represented:
            #
            # 1) A simple variable:
            #
            #     int x = 5
            #
            #     { name: "x", value: "5", type: "int" }  // Captured variable
            #
            # 2) A compound object:
            #
            #     struct T {
            #         int m1;
            #         int m2;
            #     };
            #     T x = { 3, 7 };
            #
            #     {  // Captured variable
            #         name: "x",
            #         type: "T",
            #         members { name: "m1", value: "3", type: "int" },
            #         members { name: "m2", value: "7", type: "int" }
            #     }
            #
            # 3) A pointer where the pointee was captured:
            #
            #     T x = { 3, 7 };
            #     T* p = &x;
            #
            #     {   // Captured variable
            #         name: "p",
            #         type: "T*",
            #         value: "0x00500500",
            #         members { name: "m1", value: "3", type: "int" },
            #         members { name: "m2", value: "7", type: "int" }
            #     }
            #
            # 4) A pointer where the pointee was not captured:
            #
            #     T* p = new T;
            #
            #     {   // Captured variable
            #         name: "p",
            #         type: "T*",
            #         value: "0x00400400"
            #         status { is_error: true, description { format: "unavailable" } }
            #     }
            #
            # The status should describe the reason for the missing value,
            # such as `<optimized out>`, `<inaccessible>`, `<pointers limit reached>`.
            #
            # Note that a null pointer should not have members.
            #
            # 5) An unnamed value:
            #
            #     int* p = new int(7);
            #
            #     {   // Captured variable
            #         name: "p",
            #         value: "0x00500500",
            #         type: "int*",
            #         members { value: "7", type: "int" } }
            #
            # 6) An unnamed pointer where the pointee was not captured:
            #
            #     int* p = new int(7);
            #     int** pp = &p;
            #
            #     {  // Captured variable
            #         name: "pp",
            #         value: "0x00500500",
            #         type: "int**",
            #         members {
            #             value: "0x00400400",
            #             type: "int*"
            #             status {
            #                 is_error: true,
            #                 description: { format: "unavailable" } }
            #             }
            #         }
            #     }
            #
            # To optimize computation, memory and network traffic, variables that
            # repeat in the output multiple times can be stored once in a shared
            # variable table and be referenced using the `var_table_index` field.  The
            # variables stored in the shared table are nameless and are essentially
            # a partition of the complete variable. To reconstruct the complete
            # variable, merge the referencing variable with the referenced variable.
            #
            # When using the shared variable table, the following variables:
            #
            #     T x = { 3, 7 };
            #     T* p = &x;
            #     T& r = x;
            #
            #     { name: "x", var_table_index: 3, type: "T" }  // Captured variables
            #     { name: "p", value "0x00500500", type="T*", var_table_index: 3 }
            #     { name: "r", type="T&", var_table_index: 3 }
            #
            #     {  // Shared variable table entry #3:
            #         members { name: "m1", value: "3", type: "int" },
            #         members { name: "m2", value: "7", type: "int" }
            #     }
            #
            # Note that the pointer address is stored with the referencing variable
            # and not with the referenced variable. This allows the referenced variable
            # to be shared between pointers and references.
            #
            # The type field is optional. The debugger agent may or may not support it.
          "status": { # Represents a contextual status message. # Status associated with the variable. This field will usually stay
              # unset. A status of a single variable only applies to that variable or
              # expression. The rest of breakpoint data still remains valid. Variables
              # might be reported in error state even when breakpoint is not in final
              # state.
              #
              # The message may refer to variable name with `refers_to` set to
              # `VARIABLE_NAME`. Alternatively `refers_to` will be set to `VARIABLE_VALUE`.
              # In either case variable value and members will be unset.
              #
              # Example of error message applied to name: `Invalid expression syntax`.
              #
              # Example of information message applied to value: `Not captured`.
              #
              # Examples of error message applied to value:
              #
              # *   `Malformed string`,
              # *   `Field f not found in class C`
              # *   `Null pointer dereference`
              # The message can indicate an error or informational status, and refer to
              # specific parts of the containing object.
              # For example, the `Breakpoint.status` field can indicate an error referring
              # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
            "isError": True or False, # Distinguishes errors from informational messages.
            "refersTo": "A String", # Reference to which the message applies.
            "description": { # Represents a message with parameters. # Status message text.
              "parameters": [ # Optional parameters to be embedded into the message.
                "A String",
              ],
              "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
                  # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
                  # character.
                  #
                  # Examples:
                  #
                  # *   `Failed to load '$0' which helps debug $1 the first time it
                  #     is loaded.  Again, $0 is very important.`
                  # *   `Please pay $$10 to use $0 instead of $1.`
            },
          },
          "name": "A String", # Name of the variable, if any.
          "varTableIndex": 42, # Reference to a variable in the shared variable table. More than
              # one variable can reference the same variable in the table. The
              # `var_table_index` field is an index into `variable_table` in Breakpoint.
          "value": "A String", # Simple value of the variable.
          "members": [ # Members contained or pointed to by the variable.
            # Object with schema name: Variable
          ],
          "type": "A String", # Variable type (e.g. `MyClass`). If the variable is split with
              # `var_table_index`, `type` goes next to `value`. The interpretation of
              # a type is agent specific. It is recommended to include the dynamic type
              # rather than a static type of an object.
        },
      ],
      "id": "A String", # Breakpoint identifier, unique in the scope of the debuggee.
      "condition": "A String", # Condition that triggers the breakpoint.
          # The condition is a compound boolean expression composed using expressions
          # in a programming language at the source location.
    },
  }</pre>
</div>

<div class="method">
    <code class="details" id="list">list(debuggeeId, includeAllUsers=None, includeInactive=None, x__xgafv=None, clientVersion=None, stripResults=None, action_value=None, waitToken=None)</code>
  <pre>Lists all breakpoints for the debuggee.

Args:
  debuggeeId: string, ID of the debuggee whose breakpoints to list. (required)
  includeAllUsers: boolean, When set to `true`, the response includes the list of breakpoints set by
any user. Otherwise, it includes only breakpoints set by the caller.
  includeInactive: boolean, When set to `true`, the response includes active and inactive
breakpoints. Otherwise, it includes only active breakpoints.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format
  clientVersion: string, The client version making the call.
Following: `domain/type/version` (e.g., `google.com/intellij/v1`).
  stripResults: boolean, This field is deprecated. The following fields are always stripped out of
the result: `stack_frames`, `evaluated_expressions` and `variable_table`.
  action_value: string, Only breakpoints with the specified action will pass the filter.
  waitToken: string, A wait token that, if specified, blocks the call until the breakpoints
list has changed, or a server selected timeout has expired.  The value
should be set from the last response. The error code
`google.rpc.Code.ABORTED` (RPC) is returned on wait timeout, which
should be called again with the same `wait_token`.

Returns:
  An object of the form:

    { # Response for listing breakpoints.
    "nextWaitToken": "A String", # A wait token that can be used in the next call to `list` (REST) or
        # `ListBreakpoints` (RPC) to block until the list of breakpoints has changes.
    "breakpoints": [ # List of breakpoints matching the request.
        # The fields `id` and `location` are guaranteed to be set on each breakpoint.
        # The fields: `stack_frames`, `evaluated_expressions` and `variable_table`
        # are cleared on each breakpoint regardless of it's status.
      { # Represents the breakpoint specification, status and results.
        "status": { # Represents a contextual status message. # Breakpoint status.
            #
            # The status includes an error flag and a human readable message.
            # This field is usually unset. The message can be either
            # informational or an error message. Regardless, clients should always
            # display the text message back to the user.
            #
            # Error status indicates complete failure of the breakpoint.
            #
            # Example (non-final state): `Still loading symbols...`
            #
            # Examples (final state):
            #
            # *   `Invalid line number` referring to location
            # *   `Field f not found in class C` referring to condition
            # The message can indicate an error or informational status, and refer to
            # specific parts of the containing object.
            # For example, the `Breakpoint.status` field can indicate an error referring
            # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
          "isError": True or False, # Distinguishes errors from informational messages.
          "refersTo": "A String", # Reference to which the message applies.
          "description": { # Represents a message with parameters. # Status message text.
            "parameters": [ # Optional parameters to be embedded into the message.
              "A String",
            ],
            "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
                # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
                # character.
                #
                # Examples:
                #
                # *   `Failed to load '$0' which helps debug $1 the first time it
                #     is loaded.  Again, $0 is very important.`
                # *   `Please pay $$10 to use $0 instead of $1.`
          },
        },
        "variableTable": [ # The `variable_table` exists to aid with computation, memory and network
            # traffic optimization.  It enables storing a variable once and reference
            # it from multiple variables, including variables stored in the
            # `variable_table` itself.
            # For example, the same `this` object, which may appear at many levels of
            # the stack, can have all of its data stored once in this table.  The
            # stack frame variables then would hold only a reference to it.
            #
            # The variable `var_table_index` field is an index into this repeated field.
            # The stored objects are nameless and get their name from the referencing
            # variable. The effective variable is a merge of the referencing variable
            # and the referenced variable.
          { # Represents a variable or an argument possibly of a compound object type.
              # Note how the following variables are represented:
              #
              # 1) A simple variable:
              #
              #     int x = 5
              #
              #     { name: "x", value: "5", type: "int" }  // Captured variable
              #
              # 2) A compound object:
              #
              #     struct T {
              #         int m1;
              #         int m2;
              #     };
              #     T x = { 3, 7 };
              #
              #     {  // Captured variable
              #         name: "x",
              #         type: "T",
              #         members { name: "m1", value: "3", type: "int" },
              #         members { name: "m2", value: "7", type: "int" }
              #     }
              #
              # 3) A pointer where the pointee was captured:
              #
              #     T x = { 3, 7 };
              #     T* p = &x;
              #
              #     {   // Captured variable
              #         name: "p",
              #         type: "T*",
              #         value: "0x00500500",
              #         members { name: "m1", value: "3", type: "int" },
              #         members { name: "m2", value: "7", type: "int" }
              #     }
              #
              # 4) A pointer where the pointee was not captured:
              #
              #     T* p = new T;
              #
              #     {   // Captured variable
              #         name: "p",
              #         type: "T*",
              #         value: "0x00400400"
              #         status { is_error: true, description { format: "unavailable" } }
              #     }
              #
              # The status should describe the reason for the missing value,
              # such as `<optimized out>`, `<inaccessible>`, `<pointers limit reached>`.
              #
              # Note that a null pointer should not have members.
              #
              # 5) An unnamed value:
              #
              #     int* p = new int(7);
              #
              #     {   // Captured variable
              #         name: "p",
              #         value: "0x00500500",
              #         type: "int*",
              #         members { value: "7", type: "int" } }
              #
              # 6) An unnamed pointer where the pointee was not captured:
              #
              #     int* p = new int(7);
              #     int** pp = &p;
              #
              #     {  // Captured variable
              #         name: "pp",
              #         value: "0x00500500",
              #         type: "int**",
              #         members {
              #             value: "0x00400400",
              #             type: "int*"
              #             status {
              #                 is_error: true,
              #                 description: { format: "unavailable" } }
              #             }
              #         }
              #     }
              #
              # To optimize computation, memory and network traffic, variables that
              # repeat in the output multiple times can be stored once in a shared
              # variable table and be referenced using the `var_table_index` field.  The
              # variables stored in the shared table are nameless and are essentially
              # a partition of the complete variable. To reconstruct the complete
              # variable, merge the referencing variable with the referenced variable.
              #
              # When using the shared variable table, the following variables:
              #
              #     T x = { 3, 7 };
              #     T* p = &x;
              #     T& r = x;
              #
              #     { name: "x", var_table_index: 3, type: "T" }  // Captured variables
              #     { name: "p", value "0x00500500", type="T*", var_table_index: 3 }
              #     { name: "r", type="T&", var_table_index: 3 }
              #
              #     {  // Shared variable table entry #3:
              #         members { name: "m1", value: "3", type: "int" },
              #         members { name: "m2", value: "7", type: "int" }
              #     }
              #
              # Note that the pointer address is stored with the referencing variable
              # and not with the referenced variable. This allows the referenced variable
              # to be shared between pointers and references.
              #
              # The type field is optional. The debugger agent may or may not support it.
            "status": { # Represents a contextual status message. # Status associated with the variable. This field will usually stay
                # unset. A status of a single variable only applies to that variable or
                # expression. The rest of breakpoint data still remains valid. Variables
                # might be reported in error state even when breakpoint is not in final
                # state.
                #
                # The message may refer to variable name with `refers_to` set to
                # `VARIABLE_NAME`. Alternatively `refers_to` will be set to `VARIABLE_VALUE`.
                # In either case variable value and members will be unset.
                #
                # Example of error message applied to name: `Invalid expression syntax`.
                #
                # Example of information message applied to value: `Not captured`.
                #
                # Examples of error message applied to value:
                #
                # *   `Malformed string`,
                # *   `Field f not found in class C`
                # *   `Null pointer dereference`
                # The message can indicate an error or informational status, and refer to
                # specific parts of the containing object.
                # For example, the `Breakpoint.status` field can indicate an error referring
                # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
              "isError": True or False, # Distinguishes errors from informational messages.
              "refersTo": "A String", # Reference to which the message applies.
              "description": { # Represents a message with parameters. # Status message text.
                "parameters": [ # Optional parameters to be embedded into the message.
                  "A String",
                ],
                "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
                    # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
                    # character.
                    #
                    # Examples:
                    #
                    # *   `Failed to load '$0' which helps debug $1 the first time it
                    #     is loaded.  Again, $0 is very important.`
                    # *   `Please pay $$10 to use $0 instead of $1.`
              },
            },
            "name": "A String", # Name of the variable, if any.
            "varTableIndex": 42, # Reference to a variable in the shared variable table. More than
                # one variable can reference the same variable in the table. The
                # `var_table_index` field is an index into `variable_table` in Breakpoint.
            "value": "A String", # Simple value of the variable.
            "members": [ # Members contained or pointed to by the variable.
              # Object with schema name: Variable
            ],
            "type": "A String", # Variable type (e.g. `MyClass`). If the variable is split with
                # `var_table_index`, `type` goes next to `value`. The interpretation of
                # a type is agent specific. It is recommended to include the dynamic type
                # rather than a static type of an object.
          },
        ],
        "userEmail": "A String", # E-mail address of the user that created this breakpoint
        "logLevel": "A String", # Indicates the severity of the log. Only relevant when action is `LOG`.
        "labels": { # A set of custom breakpoint properties, populated by the agent, to be
            # displayed to the user.
          "a_key": "A String",
        },
        "stackFrames": [ # The stack at breakpoint time.
          { # Represents a stack frame context.
            "function": "A String", # Demangled function name at the call site.
            "arguments": [ # Set of arguments passed to this function.
                # Note that this might not be populated for all stack frames.
              { # Represents a variable or an argument possibly of a compound object type.
                  # Note how the following variables are represented:
                  #
                  # 1) A simple variable:
                  #
                  #     int x = 5
                  #
                  #     { name: "x", value: "5", type: "int" }  // Captured variable
                  #
                  # 2) A compound object:
                  #
                  #     struct T {
                  #         int m1;
                  #         int m2;
                  #     };
                  #     T x = { 3, 7 };
                  #
                  #     {  // Captured variable
                  #         name: "x",
                  #         type: "T",
                  #         members { name: "m1", value: "3", type: "int" },
                  #         members { name: "m2", value: "7", type: "int" }
                  #     }
                  #
                  # 3) A pointer where the pointee was captured:
                  #
                  #     T x = { 3, 7 };
                  #     T* p = &x;
                  #
                  #     {   // Captured variable
                  #         name: "p",
                  #         type: "T*",
                  #         value: "0x00500500",
                  #         members { name: "m1", value: "3", type: "int" },
                  #         members { name: "m2", value: "7", type: "int" }
                  #     }
                  #
                  # 4) A pointer where the pointee was not captured:
                  #
                  #     T* p = new T;
                  #
                  #     {   // Captured variable
                  #         name: "p",
                  #         type: "T*",
                  #         value: "0x00400400"
                  #         status { is_error: true, description { format: "unavailable" } }
                  #     }
                  #
                  # The status should describe the reason for the missing value,
                  # such as `<optimized out>`, `<inaccessible>`, `<pointers limit reached>`.
                  #
                  # Note that a null pointer should not have members.
                  #
                  # 5) An unnamed value:
                  #
                  #     int* p = new int(7);
                  #
                  #     {   // Captured variable
                  #         name: "p",
                  #         value: "0x00500500",
                  #         type: "int*",
                  #         members { value: "7", type: "int" } }
                  #
                  # 6) An unnamed pointer where the pointee was not captured:
                  #
                  #     int* p = new int(7);
                  #     int** pp = &p;
                  #
                  #     {  // Captured variable
                  #         name: "pp",
                  #         value: "0x00500500",
                  #         type: "int**",
                  #         members {
                  #             value: "0x00400400",
                  #             type: "int*"
                  #             status {
                  #                 is_error: true,
                  #                 description: { format: "unavailable" } }
                  #             }
                  #         }
                  #     }
                  #
                  # To optimize computation, memory and network traffic, variables that
                  # repeat in the output multiple times can be stored once in a shared
                  # variable table and be referenced using the `var_table_index` field.  The
                  # variables stored in the shared table are nameless and are essentially
                  # a partition of the complete variable. To reconstruct the complete
                  # variable, merge the referencing variable with the referenced variable.
                  #
                  # When using the shared variable table, the following variables:
                  #
                  #     T x = { 3, 7 };
                  #     T* p = &x;
                  #     T& r = x;
                  #
                  #     { name: "x", var_table_index: 3, type: "T" }  // Captured variables
                  #     { name: "p", value "0x00500500", type="T*", var_table_index: 3 }
                  #     { name: "r", type="T&", var_table_index: 3 }
                  #
                  #     {  // Shared variable table entry #3:
                  #         members { name: "m1", value: "3", type: "int" },
                  #         members { name: "m2", value: "7", type: "int" }
                  #     }
                  #
                  # Note that the pointer address is stored with the referencing variable
                  # and not with the referenced variable. This allows the referenced variable
                  # to be shared between pointers and references.
                  #
                  # The type field is optional. The debugger agent may or may not support it.
                "status": { # Represents a contextual status message. # Status associated with the variable. This field will usually stay
                    # unset. A status of a single variable only applies to that variable or
                    # expression. The rest of breakpoint data still remains valid. Variables
                    # might be reported in error state even when breakpoint is not in final
                    # state.
                    #
                    # The message may refer to variable name with `refers_to` set to
                    # `VARIABLE_NAME`. Alternatively `refers_to` will be set to `VARIABLE_VALUE`.
                    # In either case variable value and members will be unset.
                    #
                    # Example of error message applied to name: `Invalid expression syntax`.
                    #
                    # Example of information message applied to value: `Not captured`.
                    #
                    # Examples of error message applied to value:
                    #
                    # *   `Malformed string`,
                    # *   `Field f not found in class C`
                    # *   `Null pointer dereference`
                    # The message can indicate an error or informational status, and refer to
                    # specific parts of the containing object.
                    # For example, the `Breakpoint.status` field can indicate an error referring
                    # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
                  "isError": True or False, # Distinguishes errors from informational messages.
                  "refersTo": "A String", # Reference to which the message applies.
                  "description": { # Represents a message with parameters. # Status message text.
                    "parameters": [ # Optional parameters to be embedded into the message.
                      "A String",
                    ],
                    "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
                        # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
                        # character.
                        #
                        # Examples:
                        #
                        # *   `Failed to load '$0' which helps debug $1 the first time it
                        #     is loaded.  Again, $0 is very important.`
                        # *   `Please pay $$10 to use $0 instead of $1.`
                  },
                },
                "name": "A String", # Name of the variable, if any.
                "varTableIndex": 42, # Reference to a variable in the shared variable table. More than
                    # one variable can reference the same variable in the table. The
                    # `var_table_index` field is an index into `variable_table` in Breakpoint.
                "value": "A String", # Simple value of the variable.
                "members": [ # Members contained or pointed to by the variable.
                  # Object with schema name: Variable
                ],
                "type": "A String", # Variable type (e.g. `MyClass`). If the variable is split with
                    # `var_table_index`, `type` goes next to `value`. The interpretation of
                    # a type is agent specific. It is recommended to include the dynamic type
                    # rather than a static type of an object.
              },
            ],
            "locals": [ # Set of local variables at the stack frame location.
                # Note that this might not be populated for all stack frames.
              { # Represents a variable or an argument possibly of a compound object type.
                  # Note how the following variables are represented:
                  #
                  # 1) A simple variable:
                  #
                  #     int x = 5
                  #
                  #     { name: "x", value: "5", type: "int" }  // Captured variable
                  #
                  # 2) A compound object:
                  #
                  #     struct T {
                  #         int m1;
                  #         int m2;
                  #     };
                  #     T x = { 3, 7 };
                  #
                  #     {  // Captured variable
                  #         name: "x",
                  #         type: "T",
                  #         members { name: "m1", value: "3", type: "int" },
                  #         members { name: "m2", value: "7", type: "int" }
                  #     }
                  #
                  # 3) A pointer where the pointee was captured:
                  #
                  #     T x = { 3, 7 };
                  #     T* p = &x;
                  #
                  #     {   // Captured variable
                  #         name: "p",
                  #         type: "T*",
                  #         value: "0x00500500",
                  #         members { name: "m1", value: "3", type: "int" },
                  #         members { name: "m2", value: "7", type: "int" }
                  #     }
                  #
                  # 4) A pointer where the pointee was not captured:
                  #
                  #     T* p = new T;
                  #
                  #     {   // Captured variable
                  #         name: "p",
                  #         type: "T*",
                  #         value: "0x00400400"
                  #         status { is_error: true, description { format: "unavailable" } }
                  #     }
                  #
                  # The status should describe the reason for the missing value,
                  # such as `<optimized out>`, `<inaccessible>`, `<pointers limit reached>`.
                  #
                  # Note that a null pointer should not have members.
                  #
                  # 5) An unnamed value:
                  #
                  #     int* p = new int(7);
                  #
                  #     {   // Captured variable
                  #         name: "p",
                  #         value: "0x00500500",
                  #         type: "int*",
                  #         members { value: "7", type: "int" } }
                  #
                  # 6) An unnamed pointer where the pointee was not captured:
                  #
                  #     int* p = new int(7);
                  #     int** pp = &p;
                  #
                  #     {  // Captured variable
                  #         name: "pp",
                  #         value: "0x00500500",
                  #         type: "int**",
                  #         members {
                  #             value: "0x00400400",
                  #             type: "int*"
                  #             status {
                  #                 is_error: true,
                  #                 description: { format: "unavailable" } }
                  #             }
                  #         }
                  #     }
                  #
                  # To optimize computation, memory and network traffic, variables that
                  # repeat in the output multiple times can be stored once in a shared
                  # variable table and be referenced using the `var_table_index` field.  The
                  # variables stored in the shared table are nameless and are essentially
                  # a partition of the complete variable. To reconstruct the complete
                  # variable, merge the referencing variable with the referenced variable.
                  #
                  # When using the shared variable table, the following variables:
                  #
                  #     T x = { 3, 7 };
                  #     T* p = &x;
                  #     T& r = x;
                  #
                  #     { name: "x", var_table_index: 3, type: "T" }  // Captured variables
                  #     { name: "p", value "0x00500500", type="T*", var_table_index: 3 }
                  #     { name: "r", type="T&", var_table_index: 3 }
                  #
                  #     {  // Shared variable table entry #3:
                  #         members { name: "m1", value: "3", type: "int" },
                  #         members { name: "m2", value: "7", type: "int" }
                  #     }
                  #
                  # Note that the pointer address is stored with the referencing variable
                  # and not with the referenced variable. This allows the referenced variable
                  # to be shared between pointers and references.
                  #
                  # The type field is optional. The debugger agent may or may not support it.
                "status": { # Represents a contextual status message. # Status associated with the variable. This field will usually stay
                    # unset. A status of a single variable only applies to that variable or
                    # expression. The rest of breakpoint data still remains valid. Variables
                    # might be reported in error state even when breakpoint is not in final
                    # state.
                    #
                    # The message may refer to variable name with `refers_to` set to
                    # `VARIABLE_NAME`. Alternatively `refers_to` will be set to `VARIABLE_VALUE`.
                    # In either case variable value and members will be unset.
                    #
                    # Example of error message applied to name: `Invalid expression syntax`.
                    #
                    # Example of information message applied to value: `Not captured`.
                    #
                    # Examples of error message applied to value:
                    #
                    # *   `Malformed string`,
                    # *   `Field f not found in class C`
                    # *   `Null pointer dereference`
                    # The message can indicate an error or informational status, and refer to
                    # specific parts of the containing object.
                    # For example, the `Breakpoint.status` field can indicate an error referring
                    # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
                  "isError": True or False, # Distinguishes errors from informational messages.
                  "refersTo": "A String", # Reference to which the message applies.
                  "description": { # Represents a message with parameters. # Status message text.
                    "parameters": [ # Optional parameters to be embedded into the message.
                      "A String",
                    ],
                    "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
                        # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
                        # character.
                        #
                        # Examples:
                        #
                        # *   `Failed to load '$0' which helps debug $1 the first time it
                        #     is loaded.  Again, $0 is very important.`
                        # *   `Please pay $$10 to use $0 instead of $1.`
                  },
                },
                "name": "A String", # Name of the variable, if any.
                "varTableIndex": 42, # Reference to a variable in the shared variable table. More than
                    # one variable can reference the same variable in the table. The
                    # `var_table_index` field is an index into `variable_table` in Breakpoint.
                "value": "A String", # Simple value of the variable.
                "members": [ # Members contained or pointed to by the variable.
                  # Object with schema name: Variable
                ],
                "type": "A String", # Variable type (e.g. `MyClass`). If the variable is split with
                    # `var_table_index`, `type` goes next to `value`. The interpretation of
                    # a type is agent specific. It is recommended to include the dynamic type
                    # rather than a static type of an object.
              },
            ],
            "location": { # Represents a location in the source code. # Source location of the call site.
              "path": "A String", # Path to the source file within the source context of the target binary.
              "line": 42, # Line inside the file. The first line in the file has the value `1`.
            },
          },
        ],
        "createTime": "A String", # Time this breakpoint was created by the server in seconds resolution.
        "expressions": [ # List of read-only expressions to evaluate at the breakpoint location.
            # The expressions are composed using expressions in the programming language
            # at the source location. If the breakpoint action is `LOG`, the evaluated
            # expressions are included in log statements.
          "A String",
        ],
        "location": { # Represents a location in the source code. # Breakpoint source location.
          "path": "A String", # Path to the source file within the source context of the target binary.
          "line": 42, # Line inside the file. The first line in the file has the value `1`.
        },
        "finalTime": "A String", # Time this breakpoint was finalized as seen by the server in seconds
            # resolution.
        "action": "A String", # Action that the agent should perform when the code at the
            # breakpoint location is hit.
        "logMessageFormat": "A String", # Only relevant when action is `LOG`. Defines the message to log when
            # the breakpoint hits. The message may include parameter placeholders `$0`,
            # `$1`, etc. These placeholders are replaced with the evaluated value
            # of the appropriate expression. Expressions not referenced in
            # `log_message_format` are not logged.
            #
            # Example: `Message received, id = $0, count = $1` with
            # `expressions` = `[ message.id, message.count ]`.
        "isFinalState": True or False, # When true, indicates that this is a final result and the
            # breakpoint state will not change from here on.
        "evaluatedExpressions": [ # Values of evaluated expressions at breakpoint time.
            # The evaluated expressions appear in exactly the same order they
            # are listed in the `expressions` field.
            # The `name` field holds the original expression text, the `value` or
            # `members` field holds the result of the evaluated expression.
            # If the expression cannot be evaluated, the `status` inside the `Variable`
            # will indicate an error and contain the error text.
          { # Represents a variable or an argument possibly of a compound object type.
              # Note how the following variables are represented:
              #
              # 1) A simple variable:
              #
              #     int x = 5
              #
              #     { name: "x", value: "5", type: "int" }  // Captured variable
              #
              # 2) A compound object:
              #
              #     struct T {
              #         int m1;
              #         int m2;
              #     };
              #     T x = { 3, 7 };
              #
              #     {  // Captured variable
              #         name: "x",
              #         type: "T",
              #         members { name: "m1", value: "3", type: "int" },
              #         members { name: "m2", value: "7", type: "int" }
              #     }
              #
              # 3) A pointer where the pointee was captured:
              #
              #     T x = { 3, 7 };
              #     T* p = &x;
              #
              #     {   // Captured variable
              #         name: "p",
              #         type: "T*",
              #         value: "0x00500500",
              #         members { name: "m1", value: "3", type: "int" },
              #         members { name: "m2", value: "7", type: "int" }
              #     }
              #
              # 4) A pointer where the pointee was not captured:
              #
              #     T* p = new T;
              #
              #     {   // Captured variable
              #         name: "p",
              #         type: "T*",
              #         value: "0x00400400"
              #         status { is_error: true, description { format: "unavailable" } }
              #     }
              #
              # The status should describe the reason for the missing value,
              # such as `<optimized out>`, `<inaccessible>`, `<pointers limit reached>`.
              #
              # Note that a null pointer should not have members.
              #
              # 5) An unnamed value:
              #
              #     int* p = new int(7);
              #
              #     {   // Captured variable
              #         name: "p",
              #         value: "0x00500500",
              #         type: "int*",
              #         members { value: "7", type: "int" } }
              #
              # 6) An unnamed pointer where the pointee was not captured:
              #
              #     int* p = new int(7);
              #     int** pp = &p;
              #
              #     {  // Captured variable
              #         name: "pp",
              #         value: "0x00500500",
              #         type: "int**",
              #         members {
              #             value: "0x00400400",
              #             type: "int*"
              #             status {
              #                 is_error: true,
              #                 description: { format: "unavailable" } }
              #             }
              #         }
              #     }
              #
              # To optimize computation, memory and network traffic, variables that
              # repeat in the output multiple times can be stored once in a shared
              # variable table and be referenced using the `var_table_index` field.  The
              # variables stored in the shared table are nameless and are essentially
              # a partition of the complete variable. To reconstruct the complete
              # variable, merge the referencing variable with the referenced variable.
              #
              # When using the shared variable table, the following variables:
              #
              #     T x = { 3, 7 };
              #     T* p = &x;
              #     T& r = x;
              #
              #     { name: "x", var_table_index: 3, type: "T" }  // Captured variables
              #     { name: "p", value "0x00500500", type="T*", var_table_index: 3 }
              #     { name: "r", type="T&", var_table_index: 3 }
              #
              #     {  // Shared variable table entry #3:
              #         members { name: "m1", value: "3", type: "int" },
              #         members { name: "m2", value: "7", type: "int" }
              #     }
              #
              # Note that the pointer address is stored with the referencing variable
              # and not with the referenced variable. This allows the referenced variable
              # to be shared between pointers and references.
              #
              # The type field is optional. The debugger agent may or may not support it.
            "status": { # Represents a contextual status message. # Status associated with the variable. This field will usually stay
                # unset. A status of a single variable only applies to that variable or
                # expression. The rest of breakpoint data still remains valid. Variables
                # might be reported in error state even when breakpoint is not in final
                # state.
                #
                # The message may refer to variable name with `refers_to` set to
                # `VARIABLE_NAME`. Alternatively `refers_to` will be set to `VARIABLE_VALUE`.
                # In either case variable value and members will be unset.
                #
                # Example of error message applied to name: `Invalid expression syntax`.
                #
                # Example of information message applied to value: `Not captured`.
                #
                # Examples of error message applied to value:
                #
                # *   `Malformed string`,
                # *   `Field f not found in class C`
                # *   `Null pointer dereference`
                # The message can indicate an error or informational status, and refer to
                # specific parts of the containing object.
                # For example, the `Breakpoint.status` field can indicate an error referring
                # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
              "isError": True or False, # Distinguishes errors from informational messages.
              "refersTo": "A String", # Reference to which the message applies.
              "description": { # Represents a message with parameters. # Status message text.
                "parameters": [ # Optional parameters to be embedded into the message.
                  "A String",
                ],
                "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
                    # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
                    # character.
                    #
                    # Examples:
                    #
                    # *   `Failed to load '$0' which helps debug $1 the first time it
                    #     is loaded.  Again, $0 is very important.`
                    # *   `Please pay $$10 to use $0 instead of $1.`
              },
            },
            "name": "A String", # Name of the variable, if any.
            "varTableIndex": 42, # Reference to a variable in the shared variable table. More than
                # one variable can reference the same variable in the table. The
                # `var_table_index` field is an index into `variable_table` in Breakpoint.
            "value": "A String", # Simple value of the variable.
            "members": [ # Members contained or pointed to by the variable.
              # Object with schema name: Variable
            ],
            "type": "A String", # Variable type (e.g. `MyClass`). If the variable is split with
                # `var_table_index`, `type` goes next to `value`. The interpretation of
                # a type is agent specific. It is recommended to include the dynamic type
                # rather than a static type of an object.
          },
        ],
        "id": "A String", # Breakpoint identifier, unique in the scope of the debuggee.
        "condition": "A String", # Condition that triggers the breakpoint.
            # The condition is a compound boolean expression composed using expressions
            # in a programming language at the source location.
      },
    ],
  }</pre>
</div>

<div class="method">
    <code class="details" id="set">set(debuggeeId, body, clientVersion=None, x__xgafv=None)</code>
  <pre>Sets the breakpoint to the debuggee.

Args:
  debuggeeId: string, ID of the debuggee where the breakpoint is to be set. (required)
  body: object, The request body. (required)
    The object takes the form of:

{ # Represents the breakpoint specification, status and results.
  "status": { # Represents a contextual status message. # Breakpoint status.
      # 
      # The status includes an error flag and a human readable message.
      # This field is usually unset. The message can be either
      # informational or an error message. Regardless, clients should always
      # display the text message back to the user.
      # 
      # Error status indicates complete failure of the breakpoint.
      # 
      # Example (non-final state): `Still loading symbols...`
      # 
      # Examples (final state):
      # 
      # *   `Invalid line number` referring to location
      # *   `Field f not found in class C` referring to condition
      # The message can indicate an error or informational status, and refer to
      # specific parts of the containing object.
      # For example, the `Breakpoint.status` field can indicate an error referring
      # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
    "isError": True or False, # Distinguishes errors from informational messages.
    "refersTo": "A String", # Reference to which the message applies.
    "description": { # Represents a message with parameters. # Status message text.
      "parameters": [ # Optional parameters to be embedded into the message.
        "A String",
      ],
      "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
          # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
          # character.
          #
          # Examples:
          #
          # *   `Failed to load '$0' which helps debug $1 the first time it
          #     is loaded.  Again, $0 is very important.`
          # *   `Please pay $$10 to use $0 instead of $1.`
    },
  },
  "variableTable": [ # The `variable_table` exists to aid with computation, memory and network
      # traffic optimization.  It enables storing a variable once and reference
      # it from multiple variables, including variables stored in the
      # `variable_table` itself.
      # For example, the same `this` object, which may appear at many levels of
      # the stack, can have all of its data stored once in this table.  The
      # stack frame variables then would hold only a reference to it.
      # 
      # The variable `var_table_index` field is an index into this repeated field.
      # The stored objects are nameless and get their name from the referencing
      # variable. The effective variable is a merge of the referencing variable
      # and the referenced variable.
    { # Represents a variable or an argument possibly of a compound object type.
        # Note how the following variables are represented:
        #
        # 1) A simple variable:
        #
        #     int x = 5
        #
        #     { name: "x", value: "5", type: "int" }  // Captured variable
        #
        # 2) A compound object:
        #
        #     struct T {
        #         int m1;
        #         int m2;
        #     };
        #     T x = { 3, 7 };
        #
        #     {  // Captured variable
        #         name: "x",
        #         type: "T",
        #         members { name: "m1", value: "3", type: "int" },
        #         members { name: "m2", value: "7", type: "int" }
        #     }
        #
        # 3) A pointer where the pointee was captured:
        #
        #     T x = { 3, 7 };
        #     T* p = &x;
        #
        #     {   // Captured variable
        #         name: "p",
        #         type: "T*",
        #         value: "0x00500500",
        #         members { name: "m1", value: "3", type: "int" },
        #         members { name: "m2", value: "7", type: "int" }
        #     }
        #
        # 4) A pointer where the pointee was not captured:
        #
        #     T* p = new T;
        #
        #     {   // Captured variable
        #         name: "p",
        #         type: "T*",
        #         value: "0x00400400"
        #         status { is_error: true, description { format: "unavailable" } }
        #     }
        #
        # The status should describe the reason for the missing value,
        # such as `<optimized out>`, `<inaccessible>`, `<pointers limit reached>`.
        #
        # Note that a null pointer should not have members.
        #
        # 5) An unnamed value:
        #
        #     int* p = new int(7);
        #
        #     {   // Captured variable
        #         name: "p",
        #         value: "0x00500500",
        #         type: "int*",
        #         members { value: "7", type: "int" } }
        #
        # 6) An unnamed pointer where the pointee was not captured:
        #
        #     int* p = new int(7);
        #     int** pp = &p;
        #
        #     {  // Captured variable
        #         name: "pp",
        #         value: "0x00500500",
        #         type: "int**",
        #         members {
        #             value: "0x00400400",
        #             type: "int*"
        #             status {
        #                 is_error: true,
        #                 description: { format: "unavailable" } }
        #             }
        #         }
        #     }
        #
        # To optimize computation, memory and network traffic, variables that
        # repeat in the output multiple times can be stored once in a shared
        # variable table and be referenced using the `var_table_index` field.  The
        # variables stored in the shared table are nameless and are essentially
        # a partition of the complete variable. To reconstruct the complete
        # variable, merge the referencing variable with the referenced variable.
        #
        # When using the shared variable table, the following variables:
        #
        #     T x = { 3, 7 };
        #     T* p = &x;
        #     T& r = x;
        #
        #     { name: "x", var_table_index: 3, type: "T" }  // Captured variables
        #     { name: "p", value "0x00500500", type="T*", var_table_index: 3 }
        #     { name: "r", type="T&", var_table_index: 3 }
        #
        #     {  // Shared variable table entry #3:
        #         members { name: "m1", value: "3", type: "int" },
        #         members { name: "m2", value: "7", type: "int" }
        #     }
        #
        # Note that the pointer address is stored with the referencing variable
        # and not with the referenced variable. This allows the referenced variable
        # to be shared between pointers and references.
        #
        # The type field is optional. The debugger agent may or may not support it.
      "status": { # Represents a contextual status message. # Status associated with the variable. This field will usually stay
          # unset. A status of a single variable only applies to that variable or
          # expression. The rest of breakpoint data still remains valid. Variables
          # might be reported in error state even when breakpoint is not in final
          # state.
          #
          # The message may refer to variable name with `refers_to` set to
          # `VARIABLE_NAME`. Alternatively `refers_to` will be set to `VARIABLE_VALUE`.
          # In either case variable value and members will be unset.
          #
          # Example of error message applied to name: `Invalid expression syntax`.
          #
          # Example of information message applied to value: `Not captured`.
          #
          # Examples of error message applied to value:
          #
          # *   `Malformed string`,
          # *   `Field f not found in class C`
          # *   `Null pointer dereference`
          # The message can indicate an error or informational status, and refer to
          # specific parts of the containing object.
          # For example, the `Breakpoint.status` field can indicate an error referring
          # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
        "isError": True or False, # Distinguishes errors from informational messages.
        "refersTo": "A String", # Reference to which the message applies.
        "description": { # Represents a message with parameters. # Status message text.
          "parameters": [ # Optional parameters to be embedded into the message.
            "A String",
          ],
          "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
              # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
              # character.
              #
              # Examples:
              #
              # *   `Failed to load '$0' which helps debug $1 the first time it
              #     is loaded.  Again, $0 is very important.`
              # *   `Please pay $$10 to use $0 instead of $1.`
        },
      },
      "name": "A String", # Name of the variable, if any.
      "varTableIndex": 42, # Reference to a variable in the shared variable table. More than
          # one variable can reference the same variable in the table. The
          # `var_table_index` field is an index into `variable_table` in Breakpoint.
      "value": "A String", # Simple value of the variable.
      "members": [ # Members contained or pointed to by the variable.
        # Object with schema name: Variable
      ],
      "type": "A String", # Variable type (e.g. `MyClass`). If the variable is split with
          # `var_table_index`, `type` goes next to `value`. The interpretation of
          # a type is agent specific. It is recommended to include the dynamic type
          # rather than a static type of an object.
    },
  ],
  "userEmail": "A String", # E-mail address of the user that created this breakpoint
  "logLevel": "A String", # Indicates the severity of the log. Only relevant when action is `LOG`.
  "labels": { # A set of custom breakpoint properties, populated by the agent, to be
      # displayed to the user.
    "a_key": "A String",
  },
  "stackFrames": [ # The stack at breakpoint time.
    { # Represents a stack frame context.
      "function": "A String", # Demangled function name at the call site.
      "arguments": [ # Set of arguments passed to this function.
          # Note that this might not be populated for all stack frames.
        { # Represents a variable or an argument possibly of a compound object type.
            # Note how the following variables are represented:
            #
            # 1) A simple variable:
            #
            #     int x = 5
            #
            #     { name: "x", value: "5", type: "int" }  // Captured variable
            #
            # 2) A compound object:
            #
            #     struct T {
            #         int m1;
            #         int m2;
            #     };
            #     T x = { 3, 7 };
            #
            #     {  // Captured variable
            #         name: "x",
            #         type: "T",
            #         members { name: "m1", value: "3", type: "int" },
            #         members { name: "m2", value: "7", type: "int" }
            #     }
            #
            # 3) A pointer where the pointee was captured:
            #
            #     T x = { 3, 7 };
            #     T* p = &x;
            #
            #     {   // Captured variable
            #         name: "p",
            #         type: "T*",
            #         value: "0x00500500",
            #         members { name: "m1", value: "3", type: "int" },
            #         members { name: "m2", value: "7", type: "int" }
            #     }
            #
            # 4) A pointer where the pointee was not captured:
            #
            #     T* p = new T;
            #
            #     {   // Captured variable
            #         name: "p",
            #         type: "T*",
            #         value: "0x00400400"
            #         status { is_error: true, description { format: "unavailable" } }
            #     }
            #
            # The status should describe the reason for the missing value,
            # such as `<optimized out>`, `<inaccessible>`, `<pointers limit reached>`.
            #
            # Note that a null pointer should not have members.
            #
            # 5) An unnamed value:
            #
            #     int* p = new int(7);
            #
            #     {   // Captured variable
            #         name: "p",
            #         value: "0x00500500",
            #         type: "int*",
            #         members { value: "7", type: "int" } }
            #
            # 6) An unnamed pointer where the pointee was not captured:
            #
            #     int* p = new int(7);
            #     int** pp = &p;
            #
            #     {  // Captured variable
            #         name: "pp",
            #         value: "0x00500500",
            #         type: "int**",
            #         members {
            #             value: "0x00400400",
            #             type: "int*"
            #             status {
            #                 is_error: true,
            #                 description: { format: "unavailable" } }
            #             }
            #         }
            #     }
            #
            # To optimize computation, memory and network traffic, variables that
            # repeat in the output multiple times can be stored once in a shared
            # variable table and be referenced using the `var_table_index` field.  The
            # variables stored in the shared table are nameless and are essentially
            # a partition of the complete variable. To reconstruct the complete
            # variable, merge the referencing variable with the referenced variable.
            #
            # When using the shared variable table, the following variables:
            #
            #     T x = { 3, 7 };
            #     T* p = &x;
            #     T& r = x;
            #
            #     { name: "x", var_table_index: 3, type: "T" }  // Captured variables
            #     { name: "p", value "0x00500500", type="T*", var_table_index: 3 }
            #     { name: "r", type="T&", var_table_index: 3 }
            #
            #     {  // Shared variable table entry #3:
            #         members { name: "m1", value: "3", type: "int" },
            #         members { name: "m2", value: "7", type: "int" }
            #     }
            #
            # Note that the pointer address is stored with the referencing variable
            # and not with the referenced variable. This allows the referenced variable
            # to be shared between pointers and references.
            #
            # The type field is optional. The debugger agent may or may not support it.
          "status": { # Represents a contextual status message. # Status associated with the variable. This field will usually stay
              # unset. A status of a single variable only applies to that variable or
              # expression. The rest of breakpoint data still remains valid. Variables
              # might be reported in error state even when breakpoint is not in final
              # state.
              #
              # The message may refer to variable name with `refers_to` set to
              # `VARIABLE_NAME`. Alternatively `refers_to` will be set to `VARIABLE_VALUE`.
              # In either case variable value and members will be unset.
              #
              # Example of error message applied to name: `Invalid expression syntax`.
              #
              # Example of information message applied to value: `Not captured`.
              #
              # Examples of error message applied to value:
              #
              # *   `Malformed string`,
              # *   `Field f not found in class C`
              # *   `Null pointer dereference`
              # The message can indicate an error or informational status, and refer to
              # specific parts of the containing object.
              # For example, the `Breakpoint.status` field can indicate an error referring
              # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
            "isError": True or False, # Distinguishes errors from informational messages.
            "refersTo": "A String", # Reference to which the message applies.
            "description": { # Represents a message with parameters. # Status message text.
              "parameters": [ # Optional parameters to be embedded into the message.
                "A String",
              ],
              "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
                  # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
                  # character.
                  #
                  # Examples:
                  #
                  # *   `Failed to load '$0' which helps debug $1 the first time it
                  #     is loaded.  Again, $0 is very important.`
                  # *   `Please pay $$10 to use $0 instead of $1.`
            },
          },
          "name": "A String", # Name of the variable, if any.
          "varTableIndex": 42, # Reference to a variable in the shared variable table. More than
              # one variable can reference the same variable in the table. The
              # `var_table_index` field is an index into `variable_table` in Breakpoint.
          "value": "A String", # Simple value of the variable.
          "members": [ # Members contained or pointed to by the variable.
            # Object with schema name: Variable
          ],
          "type": "A String", # Variable type (e.g. `MyClass`). If the variable is split with
              # `var_table_index`, `type` goes next to `value`. The interpretation of
              # a type is agent specific. It is recommended to include the dynamic type
              # rather than a static type of an object.
        },
      ],
      "locals": [ # Set of local variables at the stack frame location.
          # Note that this might not be populated for all stack frames.
        { # Represents a variable or an argument possibly of a compound object type.
            # Note how the following variables are represented:
            #
            # 1) A simple variable:
            #
            #     int x = 5
            #
            #     { name: "x", value: "5", type: "int" }  // Captured variable
            #
            # 2) A compound object:
            #
            #     struct T {
            #         int m1;
            #         int m2;
            #     };
            #     T x = { 3, 7 };
            #
            #     {  // Captured variable
            #         name: "x",
            #         type: "T",
            #         members { name: "m1", value: "3", type: "int" },
            #         members { name: "m2", value: "7", type: "int" }
            #     }
            #
            # 3) A pointer where the pointee was captured:
            #
            #     T x = { 3, 7 };
            #     T* p = &x;
            #
            #     {   // Captured variable
            #         name: "p",
            #         type: "T*",
            #         value: "0x00500500",
            #         members { name: "m1", value: "3", type: "int" },
            #         members { name: "m2", value: "7", type: "int" }
            #     }
            #
            # 4) A pointer where the pointee was not captured:
            #
            #     T* p = new T;
            #
            #     {   // Captured variable
            #         name: "p",
            #         type: "T*",
            #         value: "0x00400400"
            #         status { is_error: true, description { format: "unavailable" } }
            #     }
            #
            # The status should describe the reason for the missing value,
            # such as `<optimized out>`, `<inaccessible>`, `<pointers limit reached>`.
            #
            # Note that a null pointer should not have members.
            #
            # 5) An unnamed value:
            #
            #     int* p = new int(7);
            #
            #     {   // Captured variable
            #         name: "p",
            #         value: "0x00500500",
            #         type: "int*",
            #         members { value: "7", type: "int" } }
            #
            # 6) An unnamed pointer where the pointee was not captured:
            #
            #     int* p = new int(7);
            #     int** pp = &p;
            #
            #     {  // Captured variable
            #         name: "pp",
            #         value: "0x00500500",
            #         type: "int**",
            #         members {
            #             value: "0x00400400",
            #             type: "int*"
            #             status {
            #                 is_error: true,
            #                 description: { format: "unavailable" } }
            #             }
            #         }
            #     }
            #
            # To optimize computation, memory and network traffic, variables that
            # repeat in the output multiple times can be stored once in a shared
            # variable table and be referenced using the `var_table_index` field.  The
            # variables stored in the shared table are nameless and are essentially
            # a partition of the complete variable. To reconstruct the complete
            # variable, merge the referencing variable with the referenced variable.
            #
            # When using the shared variable table, the following variables:
            #
            #     T x = { 3, 7 };
            #     T* p = &x;
            #     T& r = x;
            #
            #     { name: "x", var_table_index: 3, type: "T" }  // Captured variables
            #     { name: "p", value "0x00500500", type="T*", var_table_index: 3 }
            #     { name: "r", type="T&", var_table_index: 3 }
            #
            #     {  // Shared variable table entry #3:
            #         members { name: "m1", value: "3", type: "int" },
            #         members { name: "m2", value: "7", type: "int" }
            #     }
            #
            # Note that the pointer address is stored with the referencing variable
            # and not with the referenced variable. This allows the referenced variable
            # to be shared between pointers and references.
            #
            # The type field is optional. The debugger agent may or may not support it.
          "status": { # Represents a contextual status message. # Status associated with the variable. This field will usually stay
              # unset. A status of a single variable only applies to that variable or
              # expression. The rest of breakpoint data still remains valid. Variables
              # might be reported in error state even when breakpoint is not in final
              # state.
              #
              # The message may refer to variable name with `refers_to` set to
              # `VARIABLE_NAME`. Alternatively `refers_to` will be set to `VARIABLE_VALUE`.
              # In either case variable value and members will be unset.
              #
              # Example of error message applied to name: `Invalid expression syntax`.
              #
              # Example of information message applied to value: `Not captured`.
              #
              # Examples of error message applied to value:
              #
              # *   `Malformed string`,
              # *   `Field f not found in class C`
              # *   `Null pointer dereference`
              # The message can indicate an error or informational status, and refer to
              # specific parts of the containing object.
              # For example, the `Breakpoint.status` field can indicate an error referring
              # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
            "isError": True or False, # Distinguishes errors from informational messages.
            "refersTo": "A String", # Reference to which the message applies.
            "description": { # Represents a message with parameters. # Status message text.
              "parameters": [ # Optional parameters to be embedded into the message.
                "A String",
              ],
              "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
                  # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
                  # character.
                  #
                  # Examples:
                  #
                  # *   `Failed to load '$0' which helps debug $1 the first time it
                  #     is loaded.  Again, $0 is very important.`
                  # *   `Please pay $$10 to use $0 instead of $1.`
            },
          },
          "name": "A String", # Name of the variable, if any.
          "varTableIndex": 42, # Reference to a variable in the shared variable table. More than
              # one variable can reference the same variable in the table. The
              # `var_table_index` field is an index into `variable_table` in Breakpoint.
          "value": "A String", # Simple value of the variable.
          "members": [ # Members contained or pointed to by the variable.
            # Object with schema name: Variable
          ],
          "type": "A String", # Variable type (e.g. `MyClass`). If the variable is split with
              # `var_table_index`, `type` goes next to `value`. The interpretation of
              # a type is agent specific. It is recommended to include the dynamic type
              # rather than a static type of an object.
        },
      ],
      "location": { # Represents a location in the source code. # Source location of the call site.
        "path": "A String", # Path to the source file within the source context of the target binary.
        "line": 42, # Line inside the file. The first line in the file has the value `1`.
      },
    },
  ],
  "createTime": "A String", # Time this breakpoint was created by the server in seconds resolution.
  "expressions": [ # List of read-only expressions to evaluate at the breakpoint location.
      # The expressions are composed using expressions in the programming language
      # at the source location. If the breakpoint action is `LOG`, the evaluated
      # expressions are included in log statements.
    "A String",
  ],
  "location": { # Represents a location in the source code. # Breakpoint source location.
    "path": "A String", # Path to the source file within the source context of the target binary.
    "line": 42, # Line inside the file. The first line in the file has the value `1`.
  },
  "finalTime": "A String", # Time this breakpoint was finalized as seen by the server in seconds
      # resolution.
  "action": "A String", # Action that the agent should perform when the code at the
      # breakpoint location is hit.
  "logMessageFormat": "A String", # Only relevant when action is `LOG`. Defines the message to log when
      # the breakpoint hits. The message may include parameter placeholders `$0`,
      # `$1`, etc. These placeholders are replaced with the evaluated value
      # of the appropriate expression. Expressions not referenced in
      # `log_message_format` are not logged.
      # 
      # Example: `Message received, id = $0, count = $1` with
      # `expressions` = `[ message.id, message.count ]`.
  "isFinalState": True or False, # When true, indicates that this is a final result and the
      # breakpoint state will not change from here on.
  "evaluatedExpressions": [ # Values of evaluated expressions at breakpoint time.
      # The evaluated expressions appear in exactly the same order they
      # are listed in the `expressions` field.
      # The `name` field holds the original expression text, the `value` or
      # `members` field holds the result of the evaluated expression.
      # If the expression cannot be evaluated, the `status` inside the `Variable`
      # will indicate an error and contain the error text.
    { # Represents a variable or an argument possibly of a compound object type.
        # Note how the following variables are represented:
        #
        # 1) A simple variable:
        #
        #     int x = 5
        #
        #     { name: "x", value: "5", type: "int" }  // Captured variable
        #
        # 2) A compound object:
        #
        #     struct T {
        #         int m1;
        #         int m2;
        #     };
        #     T x = { 3, 7 };
        #
        #     {  // Captured variable
        #         name: "x",
        #         type: "T",
        #         members { name: "m1", value: "3", type: "int" },
        #         members { name: "m2", value: "7", type: "int" }
        #     }
        #
        # 3) A pointer where the pointee was captured:
        #
        #     T x = { 3, 7 };
        #     T* p = &x;
        #
        #     {   // Captured variable
        #         name: "p",
        #         type: "T*",
        #         value: "0x00500500",
        #         members { name: "m1", value: "3", type: "int" },
        #         members { name: "m2", value: "7", type: "int" }
        #     }
        #
        # 4) A pointer where the pointee was not captured:
        #
        #     T* p = new T;
        #
        #     {   // Captured variable
        #         name: "p",
        #         type: "T*",
        #         value: "0x00400400"
        #         status { is_error: true, description { format: "unavailable" } }
        #     }
        #
        # The status should describe the reason for the missing value,
        # such as `<optimized out>`, `<inaccessible>`, `<pointers limit reached>`.
        #
        # Note that a null pointer should not have members.
        #
        # 5) An unnamed value:
        #
        #     int* p = new int(7);
        #
        #     {   // Captured variable
        #         name: "p",
        #         value: "0x00500500",
        #         type: "int*",
        #         members { value: "7", type: "int" } }
        #
        # 6) An unnamed pointer where the pointee was not captured:
        #
        #     int* p = new int(7);
        #     int** pp = &p;
        #
        #     {  // Captured variable
        #         name: "pp",
        #         value: "0x00500500",
        #         type: "int**",
        #         members {
        #             value: "0x00400400",
        #             type: "int*"
        #             status {
        #                 is_error: true,
        #                 description: { format: "unavailable" } }
        #             }
        #         }
        #     }
        #
        # To optimize computation, memory and network traffic, variables that
        # repeat in the output multiple times can be stored once in a shared
        # variable table and be referenced using the `var_table_index` field.  The
        # variables stored in the shared table are nameless and are essentially
        # a partition of the complete variable. To reconstruct the complete
        # variable, merge the referencing variable with the referenced variable.
        #
        # When using the shared variable table, the following variables:
        #
        #     T x = { 3, 7 };
        #     T* p = &x;
        #     T& r = x;
        #
        #     { name: "x", var_table_index: 3, type: "T" }  // Captured variables
        #     { name: "p", value "0x00500500", type="T*", var_table_index: 3 }
        #     { name: "r", type="T&", var_table_index: 3 }
        #
        #     {  // Shared variable table entry #3:
        #         members { name: "m1", value: "3", type: "int" },
        #         members { name: "m2", value: "7", type: "int" }
        #     }
        #
        # Note that the pointer address is stored with the referencing variable
        # and not with the referenced variable. This allows the referenced variable
        # to be shared between pointers and references.
        #
        # The type field is optional. The debugger agent may or may not support it.
      "status": { # Represents a contextual status message. # Status associated with the variable. This field will usually stay
          # unset. A status of a single variable only applies to that variable or
          # expression. The rest of breakpoint data still remains valid. Variables
          # might be reported in error state even when breakpoint is not in final
          # state.
          #
          # The message may refer to variable name with `refers_to` set to
          # `VARIABLE_NAME`. Alternatively `refers_to` will be set to `VARIABLE_VALUE`.
          # In either case variable value and members will be unset.
          #
          # Example of error message applied to name: `Invalid expression syntax`.
          #
          # Example of information message applied to value: `Not captured`.
          #
          # Examples of error message applied to value:
          #
          # *   `Malformed string`,
          # *   `Field f not found in class C`
          # *   `Null pointer dereference`
          # The message can indicate an error or informational status, and refer to
          # specific parts of the containing object.
          # For example, the `Breakpoint.status` field can indicate an error referring
          # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
        "isError": True or False, # Distinguishes errors from informational messages.
        "refersTo": "A String", # Reference to which the message applies.
        "description": { # Represents a message with parameters. # Status message text.
          "parameters": [ # Optional parameters to be embedded into the message.
            "A String",
          ],
          "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
              # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
              # character.
              #
              # Examples:
              #
              # *   `Failed to load '$0' which helps debug $1 the first time it
              #     is loaded.  Again, $0 is very important.`
              # *   `Please pay $$10 to use $0 instead of $1.`
        },
      },
      "name": "A String", # Name of the variable, if any.
      "varTableIndex": 42, # Reference to a variable in the shared variable table. More than
          # one variable can reference the same variable in the table. The
          # `var_table_index` field is an index into `variable_table` in Breakpoint.
      "value": "A String", # Simple value of the variable.
      "members": [ # Members contained or pointed to by the variable.
        # Object with schema name: Variable
      ],
      "type": "A String", # Variable type (e.g. `MyClass`). If the variable is split with
          # `var_table_index`, `type` goes next to `value`. The interpretation of
          # a type is agent specific. It is recommended to include the dynamic type
          # rather than a static type of an object.
    },
  ],
  "id": "A String", # Breakpoint identifier, unique in the scope of the debuggee.
  "condition": "A String", # Condition that triggers the breakpoint.
      # The condition is a compound boolean expression composed using expressions
      # in a programming language at the source location.
}

  clientVersion: string, The client version making the call.
Following: `domain/type/version` (e.g., `google.com/intellij/v1`).
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Response for setting a breakpoint.
    "breakpoint": { # Represents the breakpoint specification, status and results. # Breakpoint resource.
        # The field `id` is guaranteed to be set (in addition to the echoed fileds).
      "status": { # Represents a contextual status message. # Breakpoint status.
          #
          # The status includes an error flag and a human readable message.
          # This field is usually unset. The message can be either
          # informational or an error message. Regardless, clients should always
          # display the text message back to the user.
          #
          # Error status indicates complete failure of the breakpoint.
          #
          # Example (non-final state): `Still loading symbols...`
          #
          # Examples (final state):
          #
          # *   `Invalid line number` referring to location
          # *   `Field f not found in class C` referring to condition
          # The message can indicate an error or informational status, and refer to
          # specific parts of the containing object.
          # For example, the `Breakpoint.status` field can indicate an error referring
          # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
        "isError": True or False, # Distinguishes errors from informational messages.
        "refersTo": "A String", # Reference to which the message applies.
        "description": { # Represents a message with parameters. # Status message text.
          "parameters": [ # Optional parameters to be embedded into the message.
            "A String",
          ],
          "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
              # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
              # character.
              #
              # Examples:
              #
              # *   `Failed to load '$0' which helps debug $1 the first time it
              #     is loaded.  Again, $0 is very important.`
              # *   `Please pay $$10 to use $0 instead of $1.`
        },
      },
      "variableTable": [ # The `variable_table` exists to aid with computation, memory and network
          # traffic optimization.  It enables storing a variable once and reference
          # it from multiple variables, including variables stored in the
          # `variable_table` itself.
          # For example, the same `this` object, which may appear at many levels of
          # the stack, can have all of its data stored once in this table.  The
          # stack frame variables then would hold only a reference to it.
          #
          # The variable `var_table_index` field is an index into this repeated field.
          # The stored objects are nameless and get their name from the referencing
          # variable. The effective variable is a merge of the referencing variable
          # and the referenced variable.
        { # Represents a variable or an argument possibly of a compound object type.
            # Note how the following variables are represented:
            #
            # 1) A simple variable:
            #
            #     int x = 5
            #
            #     { name: "x", value: "5", type: "int" }  // Captured variable
            #
            # 2) A compound object:
            #
            #     struct T {
            #         int m1;
            #         int m2;
            #     };
            #     T x = { 3, 7 };
            #
            #     {  // Captured variable
            #         name: "x",
            #         type: "T",
            #         members { name: "m1", value: "3", type: "int" },
            #         members { name: "m2", value: "7", type: "int" }
            #     }
            #
            # 3) A pointer where the pointee was captured:
            #
            #     T x = { 3, 7 };
            #     T* p = &x;
            #
            #     {   // Captured variable
            #         name: "p",
            #         type: "T*",
            #         value: "0x00500500",
            #         members { name: "m1", value: "3", type: "int" },
            #         members { name: "m2", value: "7", type: "int" }
            #     }
            #
            # 4) A pointer where the pointee was not captured:
            #
            #     T* p = new T;
            #
            #     {   // Captured variable
            #         name: "p",
            #         type: "T*",
            #         value: "0x00400400"
            #         status { is_error: true, description { format: "unavailable" } }
            #     }
            #
            # The status should describe the reason for the missing value,
            # such as `<optimized out>`, `<inaccessible>`, `<pointers limit reached>`.
            #
            # Note that a null pointer should not have members.
            #
            # 5) An unnamed value:
            #
            #     int* p = new int(7);
            #
            #     {   // Captured variable
            #         name: "p",
            #         value: "0x00500500",
            #         type: "int*",
            #         members { value: "7", type: "int" } }
            #
            # 6) An unnamed pointer where the pointee was not captured:
            #
            #     int* p = new int(7);
            #     int** pp = &p;
            #
            #     {  // Captured variable
            #         name: "pp",
            #         value: "0x00500500",
            #         type: "int**",
            #         members {
            #             value: "0x00400400",
            #             type: "int*"
            #             status {
            #                 is_error: true,
            #                 description: { format: "unavailable" } }
            #             }
            #         }
            #     }
            #
            # To optimize computation, memory and network traffic, variables that
            # repeat in the output multiple times can be stored once in a shared
            # variable table and be referenced using the `var_table_index` field.  The
            # variables stored in the shared table are nameless and are essentially
            # a partition of the complete variable. To reconstruct the complete
            # variable, merge the referencing variable with the referenced variable.
            #
            # When using the shared variable table, the following variables:
            #
            #     T x = { 3, 7 };
            #     T* p = &x;
            #     T& r = x;
            #
            #     { name: "x", var_table_index: 3, type: "T" }  // Captured variables
            #     { name: "p", value "0x00500500", type="T*", var_table_index: 3 }
            #     { name: "r", type="T&", var_table_index: 3 }
            #
            #     {  // Shared variable table entry #3:
            #         members { name: "m1", value: "3", type: "int" },
            #         members { name: "m2", value: "7", type: "int" }
            #     }
            #
            # Note that the pointer address is stored with the referencing variable
            # and not with the referenced variable. This allows the referenced variable
            # to be shared between pointers and references.
            #
            # The type field is optional. The debugger agent may or may not support it.
          "status": { # Represents a contextual status message. # Status associated with the variable. This field will usually stay
              # unset. A status of a single variable only applies to that variable or
              # expression. The rest of breakpoint data still remains valid. Variables
              # might be reported in error state even when breakpoint is not in final
              # state.
              #
              # The message may refer to variable name with `refers_to` set to
              # `VARIABLE_NAME`. Alternatively `refers_to` will be set to `VARIABLE_VALUE`.
              # In either case variable value and members will be unset.
              #
              # Example of error message applied to name: `Invalid expression syntax`.
              #
              # Example of information message applied to value: `Not captured`.
              #
              # Examples of error message applied to value:
              #
              # *   `Malformed string`,
              # *   `Field f not found in class C`
              # *   `Null pointer dereference`
              # The message can indicate an error or informational status, and refer to
              # specific parts of the containing object.
              # For example, the `Breakpoint.status` field can indicate an error referring
              # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
            "isError": True or False, # Distinguishes errors from informational messages.
            "refersTo": "A String", # Reference to which the message applies.
            "description": { # Represents a message with parameters. # Status message text.
              "parameters": [ # Optional parameters to be embedded into the message.
                "A String",
              ],
              "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
                  # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
                  # character.
                  #
                  # Examples:
                  #
                  # *   `Failed to load '$0' which helps debug $1 the first time it
                  #     is loaded.  Again, $0 is very important.`
                  # *   `Please pay $$10 to use $0 instead of $1.`
            },
          },
          "name": "A String", # Name of the variable, if any.
          "varTableIndex": 42, # Reference to a variable in the shared variable table. More than
              # one variable can reference the same variable in the table. The
              # `var_table_index` field is an index into `variable_table` in Breakpoint.
          "value": "A String", # Simple value of the variable.
          "members": [ # Members contained or pointed to by the variable.
            # Object with schema name: Variable
          ],
          "type": "A String", # Variable type (e.g. `MyClass`). If the variable is split with
              # `var_table_index`, `type` goes next to `value`. The interpretation of
              # a type is agent specific. It is recommended to include the dynamic type
              # rather than a static type of an object.
        },
      ],
      "userEmail": "A String", # E-mail address of the user that created this breakpoint
      "logLevel": "A String", # Indicates the severity of the log. Only relevant when action is `LOG`.
      "labels": { # A set of custom breakpoint properties, populated by the agent, to be
          # displayed to the user.
        "a_key": "A String",
      },
      "stackFrames": [ # The stack at breakpoint time.
        { # Represents a stack frame context.
          "function": "A String", # Demangled function name at the call site.
          "arguments": [ # Set of arguments passed to this function.
              # Note that this might not be populated for all stack frames.
            { # Represents a variable or an argument possibly of a compound object type.
                # Note how the following variables are represented:
                #
                # 1) A simple variable:
                #
                #     int x = 5
                #
                #     { name: "x", value: "5", type: "int" }  // Captured variable
                #
                # 2) A compound object:
                #
                #     struct T {
                #         int m1;
                #         int m2;
                #     };
                #     T x = { 3, 7 };
                #
                #     {  // Captured variable
                #         name: "x",
                #         type: "T",
                #         members { name: "m1", value: "3", type: "int" },
                #         members { name: "m2", value: "7", type: "int" }
                #     }
                #
                # 3) A pointer where the pointee was captured:
                #
                #     T x = { 3, 7 };
                #     T* p = &x;
                #
                #     {   // Captured variable
                #         name: "p",
                #         type: "T*",
                #         value: "0x00500500",
                #         members { name: "m1", value: "3", type: "int" },
                #         members { name: "m2", value: "7", type: "int" }
                #     }
                #
                # 4) A pointer where the pointee was not captured:
                #
                #     T* p = new T;
                #
                #     {   // Captured variable
                #         name: "p",
                #         type: "T*",
                #         value: "0x00400400"
                #         status { is_error: true, description { format: "unavailable" } }
                #     }
                #
                # The status should describe the reason for the missing value,
                # such as `<optimized out>`, `<inaccessible>`, `<pointers limit reached>`.
                #
                # Note that a null pointer should not have members.
                #
                # 5) An unnamed value:
                #
                #     int* p = new int(7);
                #
                #     {   // Captured variable
                #         name: "p",
                #         value: "0x00500500",
                #         type: "int*",
                #         members { value: "7", type: "int" } }
                #
                # 6) An unnamed pointer where the pointee was not captured:
                #
                #     int* p = new int(7);
                #     int** pp = &p;
                #
                #     {  // Captured variable
                #         name: "pp",
                #         value: "0x00500500",
                #         type: "int**",
                #         members {
                #             value: "0x00400400",
                #             type: "int*"
                #             status {
                #                 is_error: true,
                #                 description: { format: "unavailable" } }
                #             }
                #         }
                #     }
                #
                # To optimize computation, memory and network traffic, variables that
                # repeat in the output multiple times can be stored once in a shared
                # variable table and be referenced using the `var_table_index` field.  The
                # variables stored in the shared table are nameless and are essentially
                # a partition of the complete variable. To reconstruct the complete
                # variable, merge the referencing variable with the referenced variable.
                #
                # When using the shared variable table, the following variables:
                #
                #     T x = { 3, 7 };
                #     T* p = &x;
                #     T& r = x;
                #
                #     { name: "x", var_table_index: 3, type: "T" }  // Captured variables
                #     { name: "p", value "0x00500500", type="T*", var_table_index: 3 }
                #     { name: "r", type="T&", var_table_index: 3 }
                #
                #     {  // Shared variable table entry #3:
                #         members { name: "m1", value: "3", type: "int" },
                #         members { name: "m2", value: "7", type: "int" }
                #     }
                #
                # Note that the pointer address is stored with the referencing variable
                # and not with the referenced variable. This allows the referenced variable
                # to be shared between pointers and references.
                #
                # The type field is optional. The debugger agent may or may not support it.
              "status": { # Represents a contextual status message. # Status associated with the variable. This field will usually stay
                  # unset. A status of a single variable only applies to that variable or
                  # expression. The rest of breakpoint data still remains valid. Variables
                  # might be reported in error state even when breakpoint is not in final
                  # state.
                  #
                  # The message may refer to variable name with `refers_to` set to
                  # `VARIABLE_NAME`. Alternatively `refers_to` will be set to `VARIABLE_VALUE`.
                  # In either case variable value and members will be unset.
                  #
                  # Example of error message applied to name: `Invalid expression syntax`.
                  #
                  # Example of information message applied to value: `Not captured`.
                  #
                  # Examples of error message applied to value:
                  #
                  # *   `Malformed string`,
                  # *   `Field f not found in class C`
                  # *   `Null pointer dereference`
                  # The message can indicate an error or informational status, and refer to
                  # specific parts of the containing object.
                  # For example, the `Breakpoint.status` field can indicate an error referring
                  # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
                "isError": True or False, # Distinguishes errors from informational messages.
                "refersTo": "A String", # Reference to which the message applies.
                "description": { # Represents a message with parameters. # Status message text.
                  "parameters": [ # Optional parameters to be embedded into the message.
                    "A String",
                  ],
                  "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
                      # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
                      # character.
                      #
                      # Examples:
                      #
                      # *   `Failed to load '$0' which helps debug $1 the first time it
                      #     is loaded.  Again, $0 is very important.`
                      # *   `Please pay $$10 to use $0 instead of $1.`
                },
              },
              "name": "A String", # Name of the variable, if any.
              "varTableIndex": 42, # Reference to a variable in the shared variable table. More than
                  # one variable can reference the same variable in the table. The
                  # `var_table_index` field is an index into `variable_table` in Breakpoint.
              "value": "A String", # Simple value of the variable.
              "members": [ # Members contained or pointed to by the variable.
                # Object with schema name: Variable
              ],
              "type": "A String", # Variable type (e.g. `MyClass`). If the variable is split with
                  # `var_table_index`, `type` goes next to `value`. The interpretation of
                  # a type is agent specific. It is recommended to include the dynamic type
                  # rather than a static type of an object.
            },
          ],
          "locals": [ # Set of local variables at the stack frame location.
              # Note that this might not be populated for all stack frames.
            { # Represents a variable or an argument possibly of a compound object type.
                # Note how the following variables are represented:
                #
                # 1) A simple variable:
                #
                #     int x = 5
                #
                #     { name: "x", value: "5", type: "int" }  // Captured variable
                #
                # 2) A compound object:
                #
                #     struct T {
                #         int m1;
                #         int m2;
                #     };
                #     T x = { 3, 7 };
                #
                #     {  // Captured variable
                #         name: "x",
                #         type: "T",
                #         members { name: "m1", value: "3", type: "int" },
                #         members { name: "m2", value: "7", type: "int" }
                #     }
                #
                # 3) A pointer where the pointee was captured:
                #
                #     T x = { 3, 7 };
                #     T* p = &x;
                #
                #     {   // Captured variable
                #         name: "p",
                #         type: "T*",
                #         value: "0x00500500",
                #         members { name: "m1", value: "3", type: "int" },
                #         members { name: "m2", value: "7", type: "int" }
                #     }
                #
                # 4) A pointer where the pointee was not captured:
                #
                #     T* p = new T;
                #
                #     {   // Captured variable
                #         name: "p",
                #         type: "T*",
                #         value: "0x00400400"
                #         status { is_error: true, description { format: "unavailable" } }
                #     }
                #
                # The status should describe the reason for the missing value,
                # such as `<optimized out>`, `<inaccessible>`, `<pointers limit reached>`.
                #
                # Note that a null pointer should not have members.
                #
                # 5) An unnamed value:
                #
                #     int* p = new int(7);
                #
                #     {   // Captured variable
                #         name: "p",
                #         value: "0x00500500",
                #         type: "int*",
                #         members { value: "7", type: "int" } }
                #
                # 6) An unnamed pointer where the pointee was not captured:
                #
                #     int* p = new int(7);
                #     int** pp = &p;
                #
                #     {  // Captured variable
                #         name: "pp",
                #         value: "0x00500500",
                #         type: "int**",
                #         members {
                #             value: "0x00400400",
                #             type: "int*"
                #             status {
                #                 is_error: true,
                #                 description: { format: "unavailable" } }
                #             }
                #         }
                #     }
                #
                # To optimize computation, memory and network traffic, variables that
                # repeat in the output multiple times can be stored once in a shared
                # variable table and be referenced using the `var_table_index` field.  The
                # variables stored in the shared table are nameless and are essentially
                # a partition of the complete variable. To reconstruct the complete
                # variable, merge the referencing variable with the referenced variable.
                #
                # When using the shared variable table, the following variables:
                #
                #     T x = { 3, 7 };
                #     T* p = &x;
                #     T& r = x;
                #
                #     { name: "x", var_table_index: 3, type: "T" }  // Captured variables
                #     { name: "p", value "0x00500500", type="T*", var_table_index: 3 }
                #     { name: "r", type="T&", var_table_index: 3 }
                #
                #     {  // Shared variable table entry #3:
                #         members { name: "m1", value: "3", type: "int" },
                #         members { name: "m2", value: "7", type: "int" }
                #     }
                #
                # Note that the pointer address is stored with the referencing variable
                # and not with the referenced variable. This allows the referenced variable
                # to be shared between pointers and references.
                #
                # The type field is optional. The debugger agent may or may not support it.
              "status": { # Represents a contextual status message. # Status associated with the variable. This field will usually stay
                  # unset. A status of a single variable only applies to that variable or
                  # expression. The rest of breakpoint data still remains valid. Variables
                  # might be reported in error state even when breakpoint is not in final
                  # state.
                  #
                  # The message may refer to variable name with `refers_to` set to
                  # `VARIABLE_NAME`. Alternatively `refers_to` will be set to `VARIABLE_VALUE`.
                  # In either case variable value and members will be unset.
                  #
                  # Example of error message applied to name: `Invalid expression syntax`.
                  #
                  # Example of information message applied to value: `Not captured`.
                  #
                  # Examples of error message applied to value:
                  #
                  # *   `Malformed string`,
                  # *   `Field f not found in class C`
                  # *   `Null pointer dereference`
                  # The message can indicate an error or informational status, and refer to
                  # specific parts of the containing object.
                  # For example, the `Breakpoint.status` field can indicate an error referring
                  # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
                "isError": True or False, # Distinguishes errors from informational messages.
                "refersTo": "A String", # Reference to which the message applies.
                "description": { # Represents a message with parameters. # Status message text.
                  "parameters": [ # Optional parameters to be embedded into the message.
                    "A String",
                  ],
                  "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
                      # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
                      # character.
                      #
                      # Examples:
                      #
                      # *   `Failed to load '$0' which helps debug $1 the first time it
                      #     is loaded.  Again, $0 is very important.`
                      # *   `Please pay $$10 to use $0 instead of $1.`
                },
              },
              "name": "A String", # Name of the variable, if any.
              "varTableIndex": 42, # Reference to a variable in the shared variable table. More than
                  # one variable can reference the same variable in the table. The
                  # `var_table_index` field is an index into `variable_table` in Breakpoint.
              "value": "A String", # Simple value of the variable.
              "members": [ # Members contained or pointed to by the variable.
                # Object with schema name: Variable
              ],
              "type": "A String", # Variable type (e.g. `MyClass`). If the variable is split with
                  # `var_table_index`, `type` goes next to `value`. The interpretation of
                  # a type is agent specific. It is recommended to include the dynamic type
                  # rather than a static type of an object.
            },
          ],
          "location": { # Represents a location in the source code. # Source location of the call site.
            "path": "A String", # Path to the source file within the source context of the target binary.
            "line": 42, # Line inside the file. The first line in the file has the value `1`.
          },
        },
      ],
      "createTime": "A String", # Time this breakpoint was created by the server in seconds resolution.
      "expressions": [ # List of read-only expressions to evaluate at the breakpoint location.
          # The expressions are composed using expressions in the programming language
          # at the source location. If the breakpoint action is `LOG`, the evaluated
          # expressions are included in log statements.
        "A String",
      ],
      "location": { # Represents a location in the source code. # Breakpoint source location.
        "path": "A String", # Path to the source file within the source context of the target binary.
        "line": 42, # Line inside the file. The first line in the file has the value `1`.
      },
      "finalTime": "A String", # Time this breakpoint was finalized as seen by the server in seconds
          # resolution.
      "action": "A String", # Action that the agent should perform when the code at the
          # breakpoint location is hit.
      "logMessageFormat": "A String", # Only relevant when action is `LOG`. Defines the message to log when
          # the breakpoint hits. The message may include parameter placeholders `$0`,
          # `$1`, etc. These placeholders are replaced with the evaluated value
          # of the appropriate expression. Expressions not referenced in
          # `log_message_format` are not logged.
          #
          # Example: `Message received, id = $0, count = $1` with
          # `expressions` = `[ message.id, message.count ]`.
      "isFinalState": True or False, # When true, indicates that this is a final result and the
          # breakpoint state will not change from here on.
      "evaluatedExpressions": [ # Values of evaluated expressions at breakpoint time.
          # The evaluated expressions appear in exactly the same order they
          # are listed in the `expressions` field.
          # The `name` field holds the original expression text, the `value` or
          # `members` field holds the result of the evaluated expression.
          # If the expression cannot be evaluated, the `status` inside the `Variable`
          # will indicate an error and contain the error text.
        { # Represents a variable or an argument possibly of a compound object type.
            # Note how the following variables are represented:
            #
            # 1) A simple variable:
            #
            #     int x = 5
            #
            #     { name: "x", value: "5", type: "int" }  // Captured variable
            #
            # 2) A compound object:
            #
            #     struct T {
            #         int m1;
            #         int m2;
            #     };
            #     T x = { 3, 7 };
            #
            #     {  // Captured variable
            #         name: "x",
            #         type: "T",
            #         members { name: "m1", value: "3", type: "int" },
            #         members { name: "m2", value: "7", type: "int" }
            #     }
            #
            # 3) A pointer where the pointee was captured:
            #
            #     T x = { 3, 7 };
            #     T* p = &x;
            #
            #     {   // Captured variable
            #         name: "p",
            #         type: "T*",
            #         value: "0x00500500",
            #         members { name: "m1", value: "3", type: "int" },
            #         members { name: "m2", value: "7", type: "int" }
            #     }
            #
            # 4) A pointer where the pointee was not captured:
            #
            #     T* p = new T;
            #
            #     {   // Captured variable
            #         name: "p",
            #         type: "T*",
            #         value: "0x00400400"
            #         status { is_error: true, description { format: "unavailable" } }
            #     }
            #
            # The status should describe the reason for the missing value,
            # such as `<optimized out>`, `<inaccessible>`, `<pointers limit reached>`.
            #
            # Note that a null pointer should not have members.
            #
            # 5) An unnamed value:
            #
            #     int* p = new int(7);
            #
            #     {   // Captured variable
            #         name: "p",
            #         value: "0x00500500",
            #         type: "int*",
            #         members { value: "7", type: "int" } }
            #
            # 6) An unnamed pointer where the pointee was not captured:
            #
            #     int* p = new int(7);
            #     int** pp = &p;
            #
            #     {  // Captured variable
            #         name: "pp",
            #         value: "0x00500500",
            #         type: "int**",
            #         members {
            #             value: "0x00400400",
            #             type: "int*"
            #             status {
            #                 is_error: true,
            #                 description: { format: "unavailable" } }
            #             }
            #         }
            #     }
            #
            # To optimize computation, memory and network traffic, variables that
            # repeat in the output multiple times can be stored once in a shared
            # variable table and be referenced using the `var_table_index` field.  The
            # variables stored in the shared table are nameless and are essentially
            # a partition of the complete variable. To reconstruct the complete
            # variable, merge the referencing variable with the referenced variable.
            #
            # When using the shared variable table, the following variables:
            #
            #     T x = { 3, 7 };
            #     T* p = &x;
            #     T& r = x;
            #
            #     { name: "x", var_table_index: 3, type: "T" }  // Captured variables
            #     { name: "p", value "0x00500500", type="T*", var_table_index: 3 }
            #     { name: "r", type="T&", var_table_index: 3 }
            #
            #     {  // Shared variable table entry #3:
            #         members { name: "m1", value: "3", type: "int" },
            #         members { name: "m2", value: "7", type: "int" }
            #     }
            #
            # Note that the pointer address is stored with the referencing variable
            # and not with the referenced variable. This allows the referenced variable
            # to be shared between pointers and references.
            #
            # The type field is optional. The debugger agent may or may not support it.
          "status": { # Represents a contextual status message. # Status associated with the variable. This field will usually stay
              # unset. A status of a single variable only applies to that variable or
              # expression. The rest of breakpoint data still remains valid. Variables
              # might be reported in error state even when breakpoint is not in final
              # state.
              #
              # The message may refer to variable name with `refers_to` set to
              # `VARIABLE_NAME`. Alternatively `refers_to` will be set to `VARIABLE_VALUE`.
              # In either case variable value and members will be unset.
              #
              # Example of error message applied to name: `Invalid expression syntax`.
              #
              # Example of information message applied to value: `Not captured`.
              #
              # Examples of error message applied to value:
              #
              # *   `Malformed string`,
              # *   `Field f not found in class C`
              # *   `Null pointer dereference`
              # The message can indicate an error or informational status, and refer to
              # specific parts of the containing object.
              # For example, the `Breakpoint.status` field can indicate an error referring
              # to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
            "isError": True or False, # Distinguishes errors from informational messages.
            "refersTo": "A String", # Reference to which the message applies.
            "description": { # Represents a message with parameters. # Status message text.
              "parameters": [ # Optional parameters to be embedded into the message.
                "A String",
              ],
              "format": "A String", # Format template for the message. The `format` uses placeholders `$0`,
                  # `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
                  # character.
                  #
                  # Examples:
                  #
                  # *   `Failed to load '$0' which helps debug $1 the first time it
                  #     is loaded.  Again, $0 is very important.`
                  # *   `Please pay $$10 to use $0 instead of $1.`
            },
          },
          "name": "A String", # Name of the variable, if any.
          "varTableIndex": 42, # Reference to a variable in the shared variable table. More than
              # one variable can reference the same variable in the table. The
              # `var_table_index` field is an index into `variable_table` in Breakpoint.
          "value": "A String", # Simple value of the variable.
          "members": [ # Members contained or pointed to by the variable.
            # Object with schema name: Variable
          ],
          "type": "A String", # Variable type (e.g. `MyClass`). If the variable is split with
              # `var_table_index`, `type` goes next to `value`. The interpretation of
              # a type is agent specific. It is recommended to include the dynamic type
              # rather than a static type of an object.
        },
      ],
      "id": "A String", # Breakpoint identifier, unique in the scope of the debuggee.
      "condition": "A String", # Condition that triggers the breakpoint.
          # The condition is a compound boolean expression composed using expressions
          # in a programming language at the source location.
    },
  }</pre>
</div>

</body></html>