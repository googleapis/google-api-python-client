<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="compute_alpha.html">Compute Engine API</a> . <a href="compute_alpha.regionMultiMigs.html">regionMultiMigs</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#delete">delete(project, region, multiMig, requestId=None, x__xgafv=None)</a></code></p>
<p class="firstline">Deletes a regional multiMIG in the specified project.</p>
<p class="toc_element">
  <code><a href="#get">get(project, region, multiMig, x__xgafv=None)</a></code></p>
<p class="firstline">Returns the specified MultiMIG resource.</p>
<p class="toc_element">
  <code><a href="#insert">insert(project, region, body=None, requestId=None, x__xgafv=None)</a></code></p>
<p class="firstline">Creates a regional multiMIG in the specified project.</p>
<p class="toc_element">
  <code><a href="#list">list(project, region, filter=None, maxResults=None, orderBy=None, pageToken=None, returnPartialSuccess=None, x__xgafv=None)</a></code></p>
<p class="firstline">Retrieves a list of MultiMIGs in a project and region.</p>
<p class="toc_element">
  <code><a href="#list_next">list_next()</a></code></p>
<p class="firstline">Retrieves the next page of results.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="delete">delete(project, region, multiMig, requestId=None, x__xgafv=None)</code>
  <pre>Deletes a regional multiMIG in the specified project.

Args:
  project: string, Project ID for this request. (required)
  region: string, Name of the region for this request. (required)
  multiMig: string, Name of the multiMIG to delete. (required)
  requestId: string, An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Represents an Operation resource. Google Compute Engine has three Operation resources: * [Global](/compute/docs/reference/rest/alpha/globalOperations) * [Regional](/compute/docs/reference/rest/alpha/regionOperations) * [Zonal](/compute/docs/reference/rest/alpha/zoneOperations) You can use an operation resource to manage asynchronous API requests. For more information, read Handling API responses. Operations can be global, regional or zonal. - For global operations, use the `globalOperations` resource. - For regional operations, use the `regionOperations` resource. - For zonal operations, use the `zoneOperations` resource. For more information, read Global, Regional, and Zonal Resources. Note that completed Operation resources have a limited retention period.
  &quot;clientOperationId&quot;: &quot;A String&quot;, # [Output Only] The value of `requestId` if you provided it in the request. Not present otherwise.
  &quot;creationTimestamp&quot;: &quot;A String&quot;, # [Deprecated] This field is deprecated.
  &quot;description&quot;: &quot;A String&quot;, # [Output Only] A textual description of the operation, which is set when the operation is created.
  &quot;endTime&quot;: &quot;A String&quot;, # [Output Only] The time that this operation was completed. This value is in RFC3339 text format.
  &quot;error&quot;: { # [Output Only] If errors are generated during processing of the operation, this field will be populated.
    &quot;errors&quot;: [ # [Output Only] The array of errors encountered while processing this operation.
      {
        &quot;code&quot;: &quot;A String&quot;, # [Output Only] The error type identifier for this error.
        &quot;errorDetails&quot;: [ # [Output Only] An optional list of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.
          {
            &quot;errorInfo&quot;: { # Describes the cause of the error with structured details. Example of an error when contacting the &quot;pubsub.googleapis.com&quot; API when it is not enabled: { &quot;reason&quot;: &quot;API_DISABLED&quot; &quot;domain&quot;: &quot;googleapis.com&quot; &quot;metadata&quot;: { &quot;resource&quot;: &quot;projects/123&quot;, &quot;service&quot;: &quot;pubsub.googleapis.com&quot; } } This response indicates that the pubsub.googleapis.com API is not enabled. Example of an error that is returned when attempting to create a Spanner instance in a region that is out of stock: { &quot;reason&quot;: &quot;STOCKOUT&quot; &quot;domain&quot;: &quot;spanner.googleapis.com&quot;, &quot;metadata&quot;: { &quot;availableRegions&quot;: &quot;us-central1,us-east2&quot; } }
              &quot;domain&quot;: &quot;A String&quot;, # The logical grouping to which the &quot;reason&quot; belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: &quot;pubsub.googleapis.com&quot;. If the error is generated by some common infrastructure, the error domain must be a globally unique value that identifies the infrastructure. For Google API infrastructure, the error domain is &quot;googleapis.com&quot;.
              &quot;metadatas&quot;: { # Additional structured details about this error. Keys must match /a-z+/ but should ideally be lowerCamelCase. Also they must be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {&quot;instanceLimit&quot;: &quot;100/request&quot;}, should be returned as, {&quot;instanceLimitPerRequest&quot;: &quot;100&quot;}, if the client exceeds the number of instances that can be created in a single (batch) request.
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;reason&quot;: &quot;A String&quot;, # The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors. This should be at most 63 characters and match a regular expression of `A-Z+[A-Z0-9]`, which represents UPPER_SNAKE_CASE.
            },
            &quot;help&quot;: { # Provides links to documentation or for performing an out of band action. For example, if a quota check failed with an error indicating the calling project hasn&#x27;t enabled the accessed service, this can contain a URL pointing directly to the right place in the developer console to flip the bit.
              &quot;links&quot;: [ # URL(s) pointing to additional information on handling the current error.
                { # Describes a URL link.
                  &quot;description&quot;: &quot;A String&quot;, # Describes what the link offers.
                  &quot;url&quot;: &quot;A String&quot;, # The URL of the link.
                },
              ],
            },
            &quot;localizedMessage&quot;: { # Provides a localized error message that is safe to return to the user which can be attached to an RPC error.
              &quot;locale&quot;: &quot;A String&quot;, # The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: &quot;en-US&quot;, &quot;fr-CH&quot;, &quot;es-MX&quot;
              &quot;message&quot;: &quot;A String&quot;, # The localized error message in the above locale.
            },
            &quot;quotaInfo&quot;: { # Additional details for quota exceeded error for resource quota.
              &quot;dimensions&quot;: { # The map holding related quota dimensions.
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;futureLimit&quot;: 3.14, # Future quota limit being rolled out. The limit&#x27;s unit depends on the quota type or metric.
              &quot;limit&quot;: 3.14, # Current effective quota limit. The limit&#x27;s unit depends on the quota type or metric.
              &quot;limitName&quot;: &quot;A String&quot;, # The name of the quota limit.
              &quot;metricName&quot;: &quot;A String&quot;, # The Compute Engine quota metric name.
              &quot;rolloutStatus&quot;: &quot;A String&quot;, # Rollout status of the future quota limit.
            },
          },
        ],
        &quot;location&quot;: &quot;A String&quot;, # [Output Only] Indicates the field in the request that caused the error. This property is optional.
        &quot;message&quot;: &quot;A String&quot;, # [Output Only] An optional, human-readable error message.
      },
    ],
  },
  &quot;httpErrorMessage&quot;: &quot;A String&quot;, # [Output Only] If the operation fails, this field contains the HTTP error message that was returned, such as `NOT FOUND`.
  &quot;httpErrorStatusCode&quot;: 42, # [Output Only] If the operation fails, this field contains the HTTP error status code that was returned. For example, a `404` means the resource was not found.
  &quot;id&quot;: &quot;A String&quot;, # [Output Only] The unique identifier for the operation. This identifier is defined by the server.
  &quot;insertTime&quot;: &quot;A String&quot;, # [Output Only] The time that this operation was requested. This value is in RFC3339 text format.
  &quot;instancesBulkInsertOperationMetadata&quot;: {
    &quot;perLocationStatus&quot;: { # Status information per location (location name is key). Example key: zones/us-central1-a
      &quot;a_key&quot;: {
        &quot;createdVmCount&quot;: 42, # [Output Only] Count of VMs successfully created so far.
        &quot;deletedVmCount&quot;: 42, # [Output Only] Count of VMs that got deleted during rollback.
        &quot;failedToCreateVmCount&quot;: 42, # [Output Only] Count of VMs that started creating but encountered an error.
        &quot;status&quot;: &quot;A String&quot;, # [Output Only] Creation status of BulkInsert operation - information if the flow is rolling forward or rolling back.
        &quot;targetVmCount&quot;: 42, # [Output Only] Count of VMs originally planned to be created.
      },
    },
  },
  &quot;kind&quot;: &quot;compute#operation&quot;, # [Output Only] Type of the resource. Always `compute#operation` for Operation resources.
  &quot;name&quot;: &quot;A String&quot;, # [Output Only] Name of the operation.
  &quot;operationGroupId&quot;: &quot;A String&quot;, # [Output Only] An ID that represents a group of operations, such as when a group of operations results from a `bulkInsert` API request.
  &quot;operationType&quot;: &quot;A String&quot;, # [Output Only] The type of operation, such as `insert`, `update`, or `delete`, and so on.
  &quot;progress&quot;: 42, # [Output Only] An optional progress indicator that ranges from 0 to 100. There is no requirement that this be linear or support any granularity of operations. This should not be used to guess when the operation will be complete. This number should monotonically increase as the operation progresses.
  &quot;region&quot;: &quot;A String&quot;, # [Output Only] The URL of the region where the operation resides. Only applicable when performing regional operations.
  &quot;selfLink&quot;: &quot;A String&quot;, # [Output Only] Server-defined URL for the resource.
  &quot;selfLinkWithId&quot;: &quot;A String&quot;, # [Output Only] Server-defined URL for this resource with the resource id.
  &quot;setCommonInstanceMetadataOperationMetadata&quot;: { # [Output Only] If the operation is for projects.setCommonInstanceMetadata, this field will contain information on all underlying zonal actions and their state.
    &quot;clientOperationId&quot;: &quot;A String&quot;, # [Output Only] The client operation id.
    &quot;perLocationOperations&quot;: { # [Output Only] Status information per location (location name is key). Example key: zones/us-central1-a
      &quot;a_key&quot;: {
        &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # [Output Only] If state is `ABANDONED` or `FAILED`, this field is populated.
          &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
          &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
            {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
            },
          ],
          &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        },
        &quot;state&quot;: &quot;A String&quot;, # [Output Only] Status of the action, which can be one of the following: `PROPAGATING`, `PROPAGATED`, `ABANDONED`, `FAILED`, or `DONE`.
      },
    },
  },
  &quot;startTime&quot;: &quot;A String&quot;, # [Output Only] The time that this operation was started by the server. This value is in RFC3339 text format.
  &quot;status&quot;: &quot;A String&quot;, # [Output Only] The status of the operation, which can be one of the following: `PENDING`, `RUNNING`, or `DONE`.
  &quot;statusMessage&quot;: &quot;A String&quot;, # [Output Only] An optional textual description of the current status of the operation.
  &quot;targetId&quot;: &quot;A String&quot;, # [Output Only] The unique target ID, which identifies a specific incarnation of the target resource.
  &quot;targetLink&quot;: &quot;A String&quot;, # [Output Only] The URL of the resource that the operation modifies. For operations related to creating a snapshot, this points to the persistent disk that the snapshot was created from.
  &quot;user&quot;: &quot;A String&quot;, # [Output Only] User who requested the operation, for example: `user@example.com` or `alice_smith_identifier (global/workforcePools/example-com-us-employees)`.
  &quot;warnings&quot;: [ # [Output Only] If warning messages are generated during processing of the operation, this field will be populated.
    {
      &quot;code&quot;: &quot;A String&quot;, # [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
      &quot;data&quot;: [ # [Output Only] Metadata about this warning in key: value format. For example: &quot;data&quot;: [ { &quot;key&quot;: &quot;scope&quot;, &quot;value&quot;: &quot;zones/us-east1-d&quot; }
        {
          &quot;key&quot;: &quot;A String&quot;, # [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
          &quot;value&quot;: &quot;A String&quot;, # [Output Only] A warning data value corresponding to the key.
        },
      ],
      &quot;message&quot;: &quot;A String&quot;, # [Output Only] A human-readable description of the warning code.
    },
  ],
  &quot;zone&quot;: &quot;A String&quot;, # [Output Only] The URL of the zone where the operation resides. Only applicable when performing per-zone operations.
}</pre>
</div>

<div class="method">
    <code class="details" id="get">get(project, region, multiMig, x__xgafv=None)</code>
  <pre>Returns the specified MultiMIG resource.

Args:
  project: string, Project ID for this request. (required)
  region: string, Name of the region for this request. (required)
  multiMig: string, Name of the MultiMig resource to return. (required)
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # MultiMIG represents a group of Managed Instance Groups.
  &quot;creationTimestamp&quot;: &quot;A String&quot;, # [Output Only] Creation timestamp in RFC3339 text format.
  &quot;description&quot;: &quot;A String&quot;, # An optional description of this resource. Provide this property when you create the resource.
  &quot;id&quot;: &quot;A String&quot;, # [Output Only] The unique identifier for the resource. This identifier is defined by the server.
  &quot;kind&quot;: &quot;compute#multiMig&quot;, # [Output Only] Type of the resource. Always compute#multiMig for MultiMIGs.
  &quot;locationPolicy&quot;: { # Policy regarding where to create MIGs Initially only zonal MIGs in the same zone are supported.
    &quot;provisioningZones&quot;: [ # List of zones where MIGs will be provisioned. Should be valid RFC1035 name
      &quot;A String&quot;,
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
  &quot;parts&quot;: { # User-provided names for Parts of MultiMIG and the Parts themselves.
    &quot;a_key&quot;: { # Config for an MMIG part.
      &quot;instanceGroupManager&quot;: &quot;A String&quot;, # Link to an existing InstanceGroupManager that will be adopted by a MultiMIG.
      &quot;instanceGroupManagerProperties&quot;: { # Represents a Managed Instance Group resource. An instance group is a collection of VM instances that you can manage as a single entity. For more information, read Instance groups. For zonal Managed Instance Group, use the instanceGroupManagers resource. For regional Managed Instance Group, use the regionInstanceGroupManagers resource. # InstanceGroupManager to be created by the multiMig
        &quot;allInstancesConfig&quot;: { # Specifies configuration that overrides the instance template configuration for the group.
          &quot;properties&quot;: { # Represents the change that you want to make to the instance properties. # Properties to set on all instances in the group. You can add or modify properties using the instanceGroupManagers.patch or regionInstanceGroupManagers.patch. After setting allInstancesConfig on the group, you must update the group&#x27;s instances to apply the configuration. To apply the configuration, set the group&#x27;s updatePolicy.type field to use proactive updates or use the applyUpdatesToInstances method.
            &quot;labels&quot;: { # The label key-value pairs that you want to patch onto the instance.
              &quot;a_key&quot;: &quot;A String&quot;,
            },
            &quot;metadata&quot;: { # The metadata key-value pairs that you want to patch onto the instance. For more information, see Project and instance metadata.
              &quot;a_key&quot;: &quot;A String&quot;,
            },
          },
        },
        &quot;autoHealingPolicies&quot;: [ # The autohealing policy for this managed instance group. You can specify only one value.
          {
            &quot;autoHealingTriggers&quot;: { # Restricts what triggers autohealing.
              &quot;onHealthCheck&quot;: &quot;A String&quot;, # If you have configured an application-based health check for the group, this field controls whether to trigger VM autohealing based on a failed health check. Valid values are: - ON (default): The group recreates running VMs that fail the application-based health check. - OFF: When set to OFF, you can still observe instance health state, but the group does not recreate VMs that fail the application-based health check. This is useful for troubleshooting and setting up your health check configuration.
            },
            &quot;healthCheck&quot;: &quot;A String&quot;, # The URL for the health check that signals autohealing.
            &quot;initialDelaySec&quot;: 42, # The initial delay is the number of seconds that a new VM takes to initialize and run its startup script. During a VM&#x27;s initial delay period, the MIG ignores unsuccessful health checks because the VM might be in the startup process. This prevents the MIG from prematurely recreating a VM. If the health check receives a healthy response during the initial delay, it indicates that the startup process is complete and the VM is ready. The value of initial delay must be between 0 and 3600 seconds. The default value is 0.
            &quot;maxUnavailable&quot;: { # Encapsulates numeric value that can be either absolute or relative. # Maximum number of instances that can be unavailable when autohealing. When &#x27;percent&#x27; is used, the value is rounded if necessary. The instance is considered available if all of the following conditions are satisfied: 1. Instance&#x27;s status is RUNNING. 2. Instance&#x27;s currentAction is NONE (in particular its liveness health check result was observed to be HEALTHY at least once as it passed VERIFYING). 3. There is no outgoing action on an instance triggered by IGM. By default, number of concurrently autohealed instances is smaller than the managed instance group target size. However, if a zonal managed instance group has only one instance, or a regional managed instance group has only one instance per zone, autohealing will recreate these instances when they become unhealthy.
              &quot;calculated&quot;: 42, # [Output Only] Absolute value of VM instances calculated based on the specific mode. - If the value is fixed, then the calculated value is equal to the fixed value. - If the value is a percent, then the calculated value is percent/100 * targetSize. For example, the calculated value of a 80% of a managed instance group with 150 instances would be (80/100 * 150) = 120 VM instances. If there is a remainder, the number is rounded.
              &quot;fixed&quot;: 42, # Specifies a fixed number of VM instances. This must be a positive integer.
              &quot;percent&quot;: 42, # Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%.
            },
          },
        ],
        &quot;baseInstanceName&quot;: &quot;A String&quot;, # The base instance name to use for instances in this group. The value must be 1-58 characters long. Instances are named by appending a hyphen and a random four-character string to the base instance name. The base instance name must comply with RFC1035.
        &quot;creationTimestamp&quot;: &quot;A String&quot;, # [Output Only] The creation timestamp for this managed instance group in RFC3339 text format.
        &quot;currentActions&quot;: { # [Output Only] The list of instance actions and the number of instances in this managed instance group that are scheduled for each of those actions.
          &quot;abandoning&quot;: 42, # [Output Only] The total number of instances in the managed instance group that are scheduled to be abandoned. Abandoning an instance removes it from the managed instance group without deleting it.
          &quot;creating&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be created or are currently being created. If the group fails to create any of these instances, it tries again until it creates the instance successfully. If you have disabled creation retries, this field will not be populated; instead, the creatingWithoutRetries field will be populated.
          &quot;creatingAtomically&quot;: 42, # [Output Only] The number of instances that the managed instance group will attempt to create atomically, in a batch mode. If the desired count of instances can not be created, entire batch will be deleted and the group will decrease its targetSize value accordingly.
          &quot;creatingWithoutRetries&quot;: 42, # [Output Only] The number of instances that the managed instance group will attempt to create. The group attempts to create each instance only once. If the group fails to create any of these instances, it decreases the group&#x27;s targetSize value accordingly.
          &quot;deleting&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be deleted or are currently being deleted.
          &quot;none&quot;: 42, # [Output Only] The number of instances in the managed instance group that are running and have no scheduled actions.
          &quot;queuing&quot;: 42, # [Output Only] The number of instances that the managed instance group is currently queuing.
          &quot;recreating&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be recreated or are currently being being recreated. Recreating an instance deletes the existing root persistent disk and creates a new disk from the image that is defined in the instance template.
          &quot;refreshing&quot;: 42, # [Output Only] The number of instances in the managed instance group that are being reconfigured with properties that do not require a restart or a recreate action. For example, setting or removing target pools for the instance.
          &quot;restarting&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be restarted or are currently being restarted.
          &quot;resuming&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be resumed or are currently being resumed.
          &quot;starting&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be started or are currently being started.
          &quot;stopping&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be stopped or are currently being stopped.
          &quot;suspending&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be suspended or are currently being suspended.
          &quot;verifying&quot;: 42, # [Output Only] The number of instances in the managed instance group that are being verified. See the managedInstances[].currentAction property in the listManagedInstances method documentation.
        },
        &quot;description&quot;: &quot;A String&quot;, # An optional description of this resource.
        &quot;distributionPolicy&quot;: { # Policy specifying the intended distribution of managed instances across zones in a regional managed instance group.
          &quot;targetShape&quot;: &quot;A String&quot;, # The distribution shape to which the group converges either proactively or on resize events (depending on the value set in updatePolicy.instanceRedistributionType).
          &quot;zones&quot;: [ # Zones where the regional managed instance group will create and manage its instances.
            {
              &quot;zone&quot;: &quot;A String&quot;, # The URL of the zone. The zone must exist in the region where the managed instance group is located.
            },
          ],
        },
        &quot;failoverAction&quot;: &quot;A String&quot;, # The action to perform in case of zone failure. Only one value is supported, NO_FAILOVER. The default is NO_FAILOVER.
        &quot;fingerprint&quot;: &quot;A String&quot;, # Fingerprint of this resource. This field may be used in optimistic locking. It will be ignored when inserting an InstanceGroupManager. An up-to-date fingerprint must be provided in order to update the InstanceGroupManager, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve an InstanceGroupManager.
        &quot;id&quot;: &quot;A String&quot;, # [Output Only] A unique identifier for this resource type. The server generates this identifier.
        &quot;instanceFlexibilityPolicy&quot;: { # Instance flexibility allowing MIG to create VMs from multiple types of machines. Instance flexibility configuration on MIG overrides instance template configuration.
          &quot;instanceSelectionLists&quot;: { # Named instance selections configuring properties that the group will use when creating new VMs.
            &quot;a_key&quot;: {
              &quot;machineTypes&quot;: [ # Full machine-type names, e.g. &quot;n1-standard-16&quot;.
                &quot;A String&quot;,
              ],
              &quot;rank&quot;: 42, # Preference of this instance selection. Lower number means higher preference. MIG will first try to create a VM based on the machine-type with lowest rank and fallback to next rank based on availability. Machine types and instance selections with the same rank have the same preference.
            },
          },
          &quot;instanceSelections&quot;: { # Named instance selections configuring properties that the group will use when creating new VMs.
            &quot;a_key&quot;: {
              &quot;machineTypes&quot;: [ # Full machine-type names, e.g. &quot;n1-standard-16&quot;.
                &quot;A String&quot;,
              ],
              &quot;rank&quot;: 42, # Preference of this instance selection. Lower number means higher preference. MIG will first try to create a VM based on the machine-type with lowest rank and fallback to next rank based on availability. Machine types and instance selections with the same rank have the same preference.
            },
          },
          &quot;provisioningModelMix&quot;: { # Provisioning model configuration used by this managed instance group to create instances.
            &quot;standardCapacityBase&quot;: 42, # The base capacity that will always use Standard VMs to avoid risk of more preemption than the minimum capacity user needs. MIG will create only Standard VMs until it reaches standard_capacity_base and only then will start using standard_capacity_percent_above_base to mix Spot with Standard VMs.
            &quot;standardCapacityPercentAboveBase&quot;: 42, # The percentage of target capacity that should use Standard VM. The remaining percentage will use Spot VMs. The percentage applies only to the capacity above standard_capacity_base.
          },
        },
        &quot;instanceGroup&quot;: &quot;A String&quot;, # [Output Only] The URL of the Instance Group resource.
        &quot;instanceLifecyclePolicy&quot;: { # The repair policy for this managed instance group.
          &quot;defaultActionOnFailure&quot;: &quot;A String&quot;, # The action that a MIG performs on a failed or an unhealthy VM. A VM is marked as unhealthy when the application running on that VM fails a health check. Valid values are - REPAIR (default): MIG automatically repairs a failed or an unhealthy VM by recreating it. For more information, see About repairing VMs in a MIG. - DO_NOTHING: MIG does not repair a failed or an unhealthy VM.
          &quot;forceUpdateOnRepair&quot;: &quot;A String&quot;, # A bit indicating whether to forcefully apply the group&#x27;s latest configuration when repairing a VM. Valid options are: - NO (default): If configuration updates are available, they are not forcefully applied during repair. Instead, configuration updates are applied according to the group&#x27;s update policy. - YES: If configuration updates are available, they are applied during repair.
          &quot;metadataBasedReadinessSignal&quot;: { # The configuration for metadata based readiness signal sent by the instance during initialization when stopping / suspending an instance. The Instance Group Manager will wait for a signal that indicates successful initialization before stopping / suspending an instance. If a successful readiness signal is not sent before timeout, the corresponding instance will not be stopped / suspended. Instead, an error will be visible in the lastAttempt.errors field of the managed instance in the listmanagedinstances method. If metadataBasedReadinessSignal.timeoutSec is unset, the Instance Group Manager will directly proceed to suspend / stop instances, skipping initialization on them.
            &quot;timeoutSec&quot;: 42, # The number of seconds to wait for a readiness signal during initialization before timing out.
          },
          &quot;onFailedHealthCheck&quot;: &quot;A String&quot;, # The action that a MIG performs on an unhealthy VM. A VM is marked as unhealthy when the application running on that VM fails a health check. Valid values are: - DEFAULT_ACTION (default): The MIG performs the same action as specified in the instanceLifecyclePolicy.defaultActionOnFailure field. If the defaultActionOnFailure field is set to REPAIR, then the MIG repairs unhealthy VMs. If the defaultActionOnFailure field is set to DO_NOTHING, then the MIG doesn&#x27;t repair unhealthy VMs. - REPAIR: The MIG repairs unhealthy VMs by recreating it. - DO_NOTHING: The MIG doesn&#x27;t repair unhealthy VMs. For more information, see About repairing VMs in a MIG.
        },
        &quot;instanceTemplate&quot;: &quot;A String&quot;, # The URL of the instance template that is specified for this managed instance group. The group uses this template to create all new instances in the managed instance group. The templates for existing instances in the group do not change unless you run recreateInstances, run applyUpdatesToInstances, or set the group&#x27;s updatePolicy.type to PROACTIVE.
        &quot;kind&quot;: &quot;compute#instanceGroupManager&quot;, # [Output Only] The resource type, which is always compute#instanceGroupManager for managed instance groups.
        &quot;listManagedInstancesResults&quot;: &quot;A String&quot;, # Pagination behavior of the listManagedInstances API method for this managed instance group.
        &quot;name&quot;: &quot;A String&quot;, # The name of the managed instance group. The name must be 1-63 characters long, and comply with RFC1035.
        &quot;namedPorts&quot;: [ # Named ports configured for the Instance Groups complementary to this Instance Group Manager.
          { # The named port. For example: &lt;&quot;http&quot;, 80&gt;.
            &quot;name&quot;: &quot;A String&quot;, # The name for this named port. The name must be 1-63 characters long, and comply with RFC1035.
            &quot;port&quot;: 42, # The port number, which can be a value between 1 and 65535.
          },
        ],
        &quot;params&quot;: { # Input only additional params for instance group manager creation. # Input only. Additional params passed with the request, but not persisted as part of resource payload.
          &quot;resourceManagerTags&quot;: { # Resource manager tags to bind to the managed instance group. The tags are key-value pairs. Keys must be in the format tagKeys/123 and values in the format tagValues/456. For more information, see Manage tags for resources.
            &quot;a_key&quot;: &quot;A String&quot;,
          },
        },
        &quot;region&quot;: &quot;A String&quot;, # [Output Only] The URL of the region where the managed instance group resides (for regional resources).
        &quot;satisfiesPzi&quot;: True or False, # [Output Only] Reserved for future use.
        &quot;satisfiesPzs&quot;: True or False, # [Output Only] Reserved for future use.
        &quot;selfLink&quot;: &quot;A String&quot;, # [Output Only] The URL for this managed instance group. The server defines this URL.
        &quot;selfLinkWithId&quot;: &quot;A String&quot;, # [Output Only] Server-defined URL for this resource with the resource id.
        &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account to be used as credentials for all operations performed by the managed instance group on instances. The service accounts needs all permissions required to create and delete instances. By default, the service account {projectNumber}@cloudservices.gserviceaccount.com is used.
        &quot;standbyPolicy&quot;: { # Standby policy for stopped and suspended instances.
          &quot;initialDelaySec&quot;: 42, # Specifies the number of seconds that the MIG should wait to suspend or stop a VM after that VM was created. The initial delay gives the initialization script the time to prepare your VM for a quick scale out. The value of initial delay must be between 0 and 3600 seconds. The default value is 0.
          &quot;mode&quot;: &quot;A String&quot;, # Defines how a MIG resumes or starts VMs from a standby pool when the group scales out. The default mode is `MANUAL`.
        },
        &quot;statefulPolicy&quot;: { # Stateful configuration for this Instanced Group Manager
          &quot;preservedState&quot;: { # Configuration of preserved resources.
            &quot;disks&quot;: { # Disks created on the instances that will be preserved on instance delete, update, etc. This map is keyed with the device names of the disks.
              &quot;a_key&quot;: {
                &quot;autoDelete&quot;: &quot;A String&quot;, # These stateful disks will never be deleted during autohealing, update or VM instance recreate operations. This flag is used to configure if the disk should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted. Note: disks attached in READ_ONLY mode cannot be auto-deleted.
              },
            },
            &quot;externalIPs&quot;: { # External network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name.
              &quot;a_key&quot;: {
                &quot;autoDelete&quot;: &quot;A String&quot;, # These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
              },
            },
            &quot;internalIPs&quot;: { # Internal network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name.
              &quot;a_key&quot;: {
                &quot;autoDelete&quot;: &quot;A String&quot;, # These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
              },
            },
          },
        },
        &quot;status&quot;: { # [Output Only] The status of this managed instance group.
          &quot;allInstancesConfig&quot;: { # [Output only] Status of all-instances configuration on the group.
            &quot;currentRevision&quot;: &quot;A String&quot;, # [Output Only] Current all-instances configuration revision. This value is in RFC3339 text format.
            &quot;effective&quot;: True or False, # [Output Only] A bit indicating whether this configuration has been applied to all managed instances in the group.
          },
          &quot;autoscaler&quot;: &quot;A String&quot;, # [Output Only] The URL of the Autoscaler that targets this instance group manager.
          &quot;isStable&quot;: True or False, # [Output Only] A bit indicating whether the managed instance group is in a stable state. A stable state means that: none of the instances in the managed instance group is currently undergoing any type of change (for example, creation, restart, or deletion); no future changes are scheduled for instances in the managed instance group; and the managed instance group itself is not being modified.
          &quot;stateful&quot;: { # [Output Only] Stateful status of the given Instance Group Manager.
            &quot;hasStatefulConfig&quot;: True or False, # [Output Only] A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful configuration even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions.
            &quot;isStateful&quot;: True or False, # [Output Only] A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful configuration even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions. This field is deprecated in favor of has_stateful_config.
            &quot;perInstanceConfigs&quot;: { # [Output Only] Status of per-instance configurations on the instances.
              &quot;allEffective&quot;: True or False, # A bit indicating if all of the group&#x27;s per-instance configurations (listed in the output of a listPerInstanceConfigs API call) have status EFFECTIVE or there are no per-instance-configs.
            },
          },
          &quot;versionTarget&quot;: { # [Output Only] A status of consistency of Instances&#x27; versions with their target version specified by version field on Instance Group Manager.
            &quot;isReached&quot;: True or False, # [Output Only] A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances&#x27; target version are specified by version field on Instance Group Manager.
          },
        },
        &quot;targetPools&quot;: [ # The URLs for all TargetPool resources to which instances in the instanceGroup field are added. The target pools automatically apply to all of the instances in the managed instance group.
          &quot;A String&quot;,
        ],
        &quot;targetSize&quot;: 42, # The target number of running instances for this managed instance group. You can reduce this number by using the instanceGroupManager deleteInstances or abandonInstances methods. Resizing the group also changes this number.
        &quot;targetSizeUnit&quot;: &quot;A String&quot;, # The unit of measure for the target size.
        &quot;targetStoppedSize&quot;: 42, # The target number of stopped instances for this managed instance group. This number changes when you: - Stop instance using the stopInstances method or start instances using the startInstances method. - Manually change the targetStoppedSize using the update method.
        &quot;targetSuspendedSize&quot;: 42, # The target number of suspended instances for this managed instance group. This number changes when you: - Suspend instance using the suspendInstances method or resume instances using the resumeInstances method. - Manually change the targetSuspendedSize using the update method.
        &quot;updatePolicy&quot;: { # The update policy for this managed instance group.
          &quot;instanceRedistributionType&quot;: &quot;A String&quot;, # The instance redistribution policy for regional managed instance groups. Valid values are: - PROACTIVE (default): The group attempts to maintain an even distribution of VM instances across zones in the region. - NONE: For non-autoscaled groups, proactive redistribution is disabled.
          &quot;maxSurge&quot;: { # Encapsulates numeric value that can be either absolute or relative. # The maximum number of instances that can be created above the specified targetSize during the update process. This value can be either a fixed number or, if the group has 10 or more instances, a percentage. If you set a percentage, the number of instances is rounded if necessary. The default value for maxSurge is a fixed value equal to the number of zones in which the managed instance group operates. At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxSurge.
            &quot;calculated&quot;: 42, # [Output Only] Absolute value of VM instances calculated based on the specific mode. - If the value is fixed, then the calculated value is equal to the fixed value. - If the value is a percent, then the calculated value is percent/100 * targetSize. For example, the calculated value of a 80% of a managed instance group with 150 instances would be (80/100 * 150) = 120 VM instances. If there is a remainder, the number is rounded.
            &quot;fixed&quot;: 42, # Specifies a fixed number of VM instances. This must be a positive integer.
            &quot;percent&quot;: 42, # Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%.
          },
          &quot;maxUnavailable&quot;: { # Encapsulates numeric value that can be either absolute or relative. # The maximum number of instances that can be unavailable during the update process. An instance is considered available if all of the following conditions are satisfied: - The instance&#x27;s status is RUNNING. - If there is a health check on the instance group, the instance&#x27;s health check status must be HEALTHY at least once. If there is no health check on the group, then the instance only needs to have a status of RUNNING to be considered available. This value can be either a fixed number or, if the group has 10 or more instances, a percentage. If you set a percentage, the number of instances is rounded if necessary. The default value for maxUnavailable is a fixed value equal to the number of zones in which the managed instance group operates. At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxUnavailable.
            &quot;calculated&quot;: 42, # [Output Only] Absolute value of VM instances calculated based on the specific mode. - If the value is fixed, then the calculated value is equal to the fixed value. - If the value is a percent, then the calculated value is percent/100 * targetSize. For example, the calculated value of a 80% of a managed instance group with 150 instances would be (80/100 * 150) = 120 VM instances. If there is a remainder, the number is rounded.
            &quot;fixed&quot;: 42, # Specifies a fixed number of VM instances. This must be a positive integer.
            &quot;percent&quot;: 42, # Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%.
          },
          &quot;minReadySec&quot;: 42, # Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600].
          &quot;minimalAction&quot;: &quot;A String&quot;, # Minimal action to be taken on an instance. Use this option to minimize disruption as much as possible or to apply a more disruptive action than is necessary. - To limit disruption as much as possible, set the minimal action to REFRESH. If your update requires a more disruptive action, Compute Engine performs the necessary action to execute the update. - To apply a more disruptive action than is strictly necessary, set the minimal action to RESTART or REPLACE. For example, Compute Engine does not need to restart a VM to change its metadata. But if your application reads instance metadata only when a VM is restarted, you can set the minimal action to RESTART in order to pick up metadata changes.
          &quot;mostDisruptiveAllowedAction&quot;: &quot;A String&quot;, # Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to avoid restarting the VM and to limit disruption as much as possible. RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
          &quot;replacementMethod&quot;: &quot;A String&quot;, # What action should be used to replace instances. See minimal_action.REPLACE
          &quot;type&quot;: &quot;A String&quot;, # The type of update process. You can specify either PROACTIVE so that the MIG automatically updates VMs to the latest configurations or OPPORTUNISTIC so that you can select the VMs that you want to update.
        },
        &quot;versions&quot;: [ # Specifies the instance templates used by this managed instance group to create instances. Each version is defined by an instanceTemplate and a name. Every version can appear at most once per instance group. This field overrides the top-level instanceTemplate field. Read more about the relationships between these fields. Exactly one version must leave the targetSize field unset. That version will be applied to all remaining instances. For more information, read about canary updates.
          {
            &quot;instanceTemplate&quot;: &quot;A String&quot;, # The URL of the instance template that is specified for this managed instance group. The group uses this template to create new instances in the managed instance group until the `targetSize` for this version is reached. The templates for existing instances in the group do not change unless you run recreateInstances, run applyUpdatesToInstances, or set the group&#x27;s updatePolicy.type to PROACTIVE; in those cases, existing instances are updated until the `targetSize` for this version is reached.
            &quot;name&quot;: &quot;A String&quot;, # Name of the version. Unique among all versions in the scope of this managed instance group.
            &quot;tag&quot;: &quot;A String&quot;, # Tag describing the version. Used to trigger rollout of a target version even if instance_template remains unchanged. Deprecated in favor of &#x27;name&#x27;.
            &quot;targetSize&quot;: { # Encapsulates numeric value that can be either absolute or relative. # Specifies the intended number of instances to be created from the instanceTemplate. The final number of instances created from the template will be equal to: - If expressed as a fixed number, the minimum of either targetSize.fixed or instanceGroupManager.targetSize is used. - if expressed as a percent, the targetSize would be (targetSize.percent/100 * InstanceGroupManager.targetSize) If there is a remainder, the number is rounded. If unset, this version will update any remaining instances not updated by another version. Read Starting a canary update for more information.
              &quot;calculated&quot;: 42, # [Output Only] Absolute value of VM instances calculated based on the specific mode. - If the value is fixed, then the calculated value is equal to the fixed value. - If the value is a percent, then the calculated value is percent/100 * targetSize. For example, the calculated value of a 80% of a managed instance group with 150 instances would be (80/100 * 150) = 120 VM instances. If there is a remainder, the number is rounded.
              &quot;fixed&quot;: 42, # Specifies a fixed number of VM instances. This must be a positive integer.
              &quot;percent&quot;: 42, # Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%.
            },
          },
        ],
        &quot;zone&quot;: &quot;A String&quot;, # [Output Only] The URL of a zone where the managed instance group is located (for zonal resources).
      },
    },
  },
  &quot;region&quot;: &quot;A String&quot;, # [Output Only] URL of the region where the resource resides. Only applicable for regional resources. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
  &quot;schedulingPolicy&quot;: { # Policy for handling provisioning and other scheduling-related events. # Policy for handling provisioning and other scheduling-related events.
    &quot;provisioning&quot;: &quot;A String&quot;, # How provisioning of MIGs should be scheduled (coordinated or not)
  },
  &quot;selfLink&quot;: &quot;A String&quot;, # [Output only] Server-defined URL for the resource.
  &quot;selfLinkWithId&quot;: &quot;A String&quot;, # [Output Only] Server-defined URL for this resource with the resource id.
}</pre>
</div>

<div class="method">
    <code class="details" id="insert">insert(project, region, body=None, requestId=None, x__xgafv=None)</code>
  <pre>Creates a regional multiMIG in the specified project.

Args:
  project: string, Project ID for this request. (required)
  region: string, Name of the region for this request. (required)
  body: object, The request body.
    The object takes the form of:

{ # MultiMIG represents a group of Managed Instance Groups.
  &quot;creationTimestamp&quot;: &quot;A String&quot;, # [Output Only] Creation timestamp in RFC3339 text format.
  &quot;description&quot;: &quot;A String&quot;, # An optional description of this resource. Provide this property when you create the resource.
  &quot;id&quot;: &quot;A String&quot;, # [Output Only] The unique identifier for the resource. This identifier is defined by the server.
  &quot;kind&quot;: &quot;compute#multiMig&quot;, # [Output Only] Type of the resource. Always compute#multiMig for MultiMIGs.
  &quot;locationPolicy&quot;: { # Policy regarding where to create MIGs Initially only zonal MIGs in the same zone are supported.
    &quot;provisioningZones&quot;: [ # List of zones where MIGs will be provisioned. Should be valid RFC1035 name
      &quot;A String&quot;,
    ],
  },
  &quot;name&quot;: &quot;A String&quot;, # Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
  &quot;parts&quot;: { # User-provided names for Parts of MultiMIG and the Parts themselves.
    &quot;a_key&quot;: { # Config for an MMIG part.
      &quot;instanceGroupManager&quot;: &quot;A String&quot;, # Link to an existing InstanceGroupManager that will be adopted by a MultiMIG.
      &quot;instanceGroupManagerProperties&quot;: { # Represents a Managed Instance Group resource. An instance group is a collection of VM instances that you can manage as a single entity. For more information, read Instance groups. For zonal Managed Instance Group, use the instanceGroupManagers resource. For regional Managed Instance Group, use the regionInstanceGroupManagers resource. # InstanceGroupManager to be created by the multiMig
        &quot;allInstancesConfig&quot;: { # Specifies configuration that overrides the instance template configuration for the group.
          &quot;properties&quot;: { # Represents the change that you want to make to the instance properties. # Properties to set on all instances in the group. You can add or modify properties using the instanceGroupManagers.patch or regionInstanceGroupManagers.patch. After setting allInstancesConfig on the group, you must update the group&#x27;s instances to apply the configuration. To apply the configuration, set the group&#x27;s updatePolicy.type field to use proactive updates or use the applyUpdatesToInstances method.
            &quot;labels&quot;: { # The label key-value pairs that you want to patch onto the instance.
              &quot;a_key&quot;: &quot;A String&quot;,
            },
            &quot;metadata&quot;: { # The metadata key-value pairs that you want to patch onto the instance. For more information, see Project and instance metadata.
              &quot;a_key&quot;: &quot;A String&quot;,
            },
          },
        },
        &quot;autoHealingPolicies&quot;: [ # The autohealing policy for this managed instance group. You can specify only one value.
          {
            &quot;autoHealingTriggers&quot;: { # Restricts what triggers autohealing.
              &quot;onHealthCheck&quot;: &quot;A String&quot;, # If you have configured an application-based health check for the group, this field controls whether to trigger VM autohealing based on a failed health check. Valid values are: - ON (default): The group recreates running VMs that fail the application-based health check. - OFF: When set to OFF, you can still observe instance health state, but the group does not recreate VMs that fail the application-based health check. This is useful for troubleshooting and setting up your health check configuration.
            },
            &quot;healthCheck&quot;: &quot;A String&quot;, # The URL for the health check that signals autohealing.
            &quot;initialDelaySec&quot;: 42, # The initial delay is the number of seconds that a new VM takes to initialize and run its startup script. During a VM&#x27;s initial delay period, the MIG ignores unsuccessful health checks because the VM might be in the startup process. This prevents the MIG from prematurely recreating a VM. If the health check receives a healthy response during the initial delay, it indicates that the startup process is complete and the VM is ready. The value of initial delay must be between 0 and 3600 seconds. The default value is 0.
            &quot;maxUnavailable&quot;: { # Encapsulates numeric value that can be either absolute or relative. # Maximum number of instances that can be unavailable when autohealing. When &#x27;percent&#x27; is used, the value is rounded if necessary. The instance is considered available if all of the following conditions are satisfied: 1. Instance&#x27;s status is RUNNING. 2. Instance&#x27;s currentAction is NONE (in particular its liveness health check result was observed to be HEALTHY at least once as it passed VERIFYING). 3. There is no outgoing action on an instance triggered by IGM. By default, number of concurrently autohealed instances is smaller than the managed instance group target size. However, if a zonal managed instance group has only one instance, or a regional managed instance group has only one instance per zone, autohealing will recreate these instances when they become unhealthy.
              &quot;calculated&quot;: 42, # [Output Only] Absolute value of VM instances calculated based on the specific mode. - If the value is fixed, then the calculated value is equal to the fixed value. - If the value is a percent, then the calculated value is percent/100 * targetSize. For example, the calculated value of a 80% of a managed instance group with 150 instances would be (80/100 * 150) = 120 VM instances. If there is a remainder, the number is rounded.
              &quot;fixed&quot;: 42, # Specifies a fixed number of VM instances. This must be a positive integer.
              &quot;percent&quot;: 42, # Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%.
            },
          },
        ],
        &quot;baseInstanceName&quot;: &quot;A String&quot;, # The base instance name to use for instances in this group. The value must be 1-58 characters long. Instances are named by appending a hyphen and a random four-character string to the base instance name. The base instance name must comply with RFC1035.
        &quot;creationTimestamp&quot;: &quot;A String&quot;, # [Output Only] The creation timestamp for this managed instance group in RFC3339 text format.
        &quot;currentActions&quot;: { # [Output Only] The list of instance actions and the number of instances in this managed instance group that are scheduled for each of those actions.
          &quot;abandoning&quot;: 42, # [Output Only] The total number of instances in the managed instance group that are scheduled to be abandoned. Abandoning an instance removes it from the managed instance group without deleting it.
          &quot;creating&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be created or are currently being created. If the group fails to create any of these instances, it tries again until it creates the instance successfully. If you have disabled creation retries, this field will not be populated; instead, the creatingWithoutRetries field will be populated.
          &quot;creatingAtomically&quot;: 42, # [Output Only] The number of instances that the managed instance group will attempt to create atomically, in a batch mode. If the desired count of instances can not be created, entire batch will be deleted and the group will decrease its targetSize value accordingly.
          &quot;creatingWithoutRetries&quot;: 42, # [Output Only] The number of instances that the managed instance group will attempt to create. The group attempts to create each instance only once. If the group fails to create any of these instances, it decreases the group&#x27;s targetSize value accordingly.
          &quot;deleting&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be deleted or are currently being deleted.
          &quot;none&quot;: 42, # [Output Only] The number of instances in the managed instance group that are running and have no scheduled actions.
          &quot;queuing&quot;: 42, # [Output Only] The number of instances that the managed instance group is currently queuing.
          &quot;recreating&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be recreated or are currently being being recreated. Recreating an instance deletes the existing root persistent disk and creates a new disk from the image that is defined in the instance template.
          &quot;refreshing&quot;: 42, # [Output Only] The number of instances in the managed instance group that are being reconfigured with properties that do not require a restart or a recreate action. For example, setting or removing target pools for the instance.
          &quot;restarting&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be restarted or are currently being restarted.
          &quot;resuming&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be resumed or are currently being resumed.
          &quot;starting&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be started or are currently being started.
          &quot;stopping&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be stopped or are currently being stopped.
          &quot;suspending&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be suspended or are currently being suspended.
          &quot;verifying&quot;: 42, # [Output Only] The number of instances in the managed instance group that are being verified. See the managedInstances[].currentAction property in the listManagedInstances method documentation.
        },
        &quot;description&quot;: &quot;A String&quot;, # An optional description of this resource.
        &quot;distributionPolicy&quot;: { # Policy specifying the intended distribution of managed instances across zones in a regional managed instance group.
          &quot;targetShape&quot;: &quot;A String&quot;, # The distribution shape to which the group converges either proactively or on resize events (depending on the value set in updatePolicy.instanceRedistributionType).
          &quot;zones&quot;: [ # Zones where the regional managed instance group will create and manage its instances.
            {
              &quot;zone&quot;: &quot;A String&quot;, # The URL of the zone. The zone must exist in the region where the managed instance group is located.
            },
          ],
        },
        &quot;failoverAction&quot;: &quot;A String&quot;, # The action to perform in case of zone failure. Only one value is supported, NO_FAILOVER. The default is NO_FAILOVER.
        &quot;fingerprint&quot;: &quot;A String&quot;, # Fingerprint of this resource. This field may be used in optimistic locking. It will be ignored when inserting an InstanceGroupManager. An up-to-date fingerprint must be provided in order to update the InstanceGroupManager, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve an InstanceGroupManager.
        &quot;id&quot;: &quot;A String&quot;, # [Output Only] A unique identifier for this resource type. The server generates this identifier.
        &quot;instanceFlexibilityPolicy&quot;: { # Instance flexibility allowing MIG to create VMs from multiple types of machines. Instance flexibility configuration on MIG overrides instance template configuration.
          &quot;instanceSelectionLists&quot;: { # Named instance selections configuring properties that the group will use when creating new VMs.
            &quot;a_key&quot;: {
              &quot;machineTypes&quot;: [ # Full machine-type names, e.g. &quot;n1-standard-16&quot;.
                &quot;A String&quot;,
              ],
              &quot;rank&quot;: 42, # Preference of this instance selection. Lower number means higher preference. MIG will first try to create a VM based on the machine-type with lowest rank and fallback to next rank based on availability. Machine types and instance selections with the same rank have the same preference.
            },
          },
          &quot;instanceSelections&quot;: { # Named instance selections configuring properties that the group will use when creating new VMs.
            &quot;a_key&quot;: {
              &quot;machineTypes&quot;: [ # Full machine-type names, e.g. &quot;n1-standard-16&quot;.
                &quot;A String&quot;,
              ],
              &quot;rank&quot;: 42, # Preference of this instance selection. Lower number means higher preference. MIG will first try to create a VM based on the machine-type with lowest rank and fallback to next rank based on availability. Machine types and instance selections with the same rank have the same preference.
            },
          },
          &quot;provisioningModelMix&quot;: { # Provisioning model configuration used by this managed instance group to create instances.
            &quot;standardCapacityBase&quot;: 42, # The base capacity that will always use Standard VMs to avoid risk of more preemption than the minimum capacity user needs. MIG will create only Standard VMs until it reaches standard_capacity_base and only then will start using standard_capacity_percent_above_base to mix Spot with Standard VMs.
            &quot;standardCapacityPercentAboveBase&quot;: 42, # The percentage of target capacity that should use Standard VM. The remaining percentage will use Spot VMs. The percentage applies only to the capacity above standard_capacity_base.
          },
        },
        &quot;instanceGroup&quot;: &quot;A String&quot;, # [Output Only] The URL of the Instance Group resource.
        &quot;instanceLifecyclePolicy&quot;: { # The repair policy for this managed instance group.
          &quot;defaultActionOnFailure&quot;: &quot;A String&quot;, # The action that a MIG performs on a failed or an unhealthy VM. A VM is marked as unhealthy when the application running on that VM fails a health check. Valid values are - REPAIR (default): MIG automatically repairs a failed or an unhealthy VM by recreating it. For more information, see About repairing VMs in a MIG. - DO_NOTHING: MIG does not repair a failed or an unhealthy VM.
          &quot;forceUpdateOnRepair&quot;: &quot;A String&quot;, # A bit indicating whether to forcefully apply the group&#x27;s latest configuration when repairing a VM. Valid options are: - NO (default): If configuration updates are available, they are not forcefully applied during repair. Instead, configuration updates are applied according to the group&#x27;s update policy. - YES: If configuration updates are available, they are applied during repair.
          &quot;metadataBasedReadinessSignal&quot;: { # The configuration for metadata based readiness signal sent by the instance during initialization when stopping / suspending an instance. The Instance Group Manager will wait for a signal that indicates successful initialization before stopping / suspending an instance. If a successful readiness signal is not sent before timeout, the corresponding instance will not be stopped / suspended. Instead, an error will be visible in the lastAttempt.errors field of the managed instance in the listmanagedinstances method. If metadataBasedReadinessSignal.timeoutSec is unset, the Instance Group Manager will directly proceed to suspend / stop instances, skipping initialization on them.
            &quot;timeoutSec&quot;: 42, # The number of seconds to wait for a readiness signal during initialization before timing out.
          },
          &quot;onFailedHealthCheck&quot;: &quot;A String&quot;, # The action that a MIG performs on an unhealthy VM. A VM is marked as unhealthy when the application running on that VM fails a health check. Valid values are: - DEFAULT_ACTION (default): The MIG performs the same action as specified in the instanceLifecyclePolicy.defaultActionOnFailure field. If the defaultActionOnFailure field is set to REPAIR, then the MIG repairs unhealthy VMs. If the defaultActionOnFailure field is set to DO_NOTHING, then the MIG doesn&#x27;t repair unhealthy VMs. - REPAIR: The MIG repairs unhealthy VMs by recreating it. - DO_NOTHING: The MIG doesn&#x27;t repair unhealthy VMs. For more information, see About repairing VMs in a MIG.
        },
        &quot;instanceTemplate&quot;: &quot;A String&quot;, # The URL of the instance template that is specified for this managed instance group. The group uses this template to create all new instances in the managed instance group. The templates for existing instances in the group do not change unless you run recreateInstances, run applyUpdatesToInstances, or set the group&#x27;s updatePolicy.type to PROACTIVE.
        &quot;kind&quot;: &quot;compute#instanceGroupManager&quot;, # [Output Only] The resource type, which is always compute#instanceGroupManager for managed instance groups.
        &quot;listManagedInstancesResults&quot;: &quot;A String&quot;, # Pagination behavior of the listManagedInstances API method for this managed instance group.
        &quot;name&quot;: &quot;A String&quot;, # The name of the managed instance group. The name must be 1-63 characters long, and comply with RFC1035.
        &quot;namedPorts&quot;: [ # Named ports configured for the Instance Groups complementary to this Instance Group Manager.
          { # The named port. For example: &lt;&quot;http&quot;, 80&gt;.
            &quot;name&quot;: &quot;A String&quot;, # The name for this named port. The name must be 1-63 characters long, and comply with RFC1035.
            &quot;port&quot;: 42, # The port number, which can be a value between 1 and 65535.
          },
        ],
        &quot;params&quot;: { # Input only additional params for instance group manager creation. # Input only. Additional params passed with the request, but not persisted as part of resource payload.
          &quot;resourceManagerTags&quot;: { # Resource manager tags to bind to the managed instance group. The tags are key-value pairs. Keys must be in the format tagKeys/123 and values in the format tagValues/456. For more information, see Manage tags for resources.
            &quot;a_key&quot;: &quot;A String&quot;,
          },
        },
        &quot;region&quot;: &quot;A String&quot;, # [Output Only] The URL of the region where the managed instance group resides (for regional resources).
        &quot;satisfiesPzi&quot;: True or False, # [Output Only] Reserved for future use.
        &quot;satisfiesPzs&quot;: True or False, # [Output Only] Reserved for future use.
        &quot;selfLink&quot;: &quot;A String&quot;, # [Output Only] The URL for this managed instance group. The server defines this URL.
        &quot;selfLinkWithId&quot;: &quot;A String&quot;, # [Output Only] Server-defined URL for this resource with the resource id.
        &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account to be used as credentials for all operations performed by the managed instance group on instances. The service accounts needs all permissions required to create and delete instances. By default, the service account {projectNumber}@cloudservices.gserviceaccount.com is used.
        &quot;standbyPolicy&quot;: { # Standby policy for stopped and suspended instances.
          &quot;initialDelaySec&quot;: 42, # Specifies the number of seconds that the MIG should wait to suspend or stop a VM after that VM was created. The initial delay gives the initialization script the time to prepare your VM for a quick scale out. The value of initial delay must be between 0 and 3600 seconds. The default value is 0.
          &quot;mode&quot;: &quot;A String&quot;, # Defines how a MIG resumes or starts VMs from a standby pool when the group scales out. The default mode is `MANUAL`.
        },
        &quot;statefulPolicy&quot;: { # Stateful configuration for this Instanced Group Manager
          &quot;preservedState&quot;: { # Configuration of preserved resources.
            &quot;disks&quot;: { # Disks created on the instances that will be preserved on instance delete, update, etc. This map is keyed with the device names of the disks.
              &quot;a_key&quot;: {
                &quot;autoDelete&quot;: &quot;A String&quot;, # These stateful disks will never be deleted during autohealing, update or VM instance recreate operations. This flag is used to configure if the disk should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted. Note: disks attached in READ_ONLY mode cannot be auto-deleted.
              },
            },
            &quot;externalIPs&quot;: { # External network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name.
              &quot;a_key&quot;: {
                &quot;autoDelete&quot;: &quot;A String&quot;, # These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
              },
            },
            &quot;internalIPs&quot;: { # Internal network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name.
              &quot;a_key&quot;: {
                &quot;autoDelete&quot;: &quot;A String&quot;, # These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
              },
            },
          },
        },
        &quot;status&quot;: { # [Output Only] The status of this managed instance group.
          &quot;allInstancesConfig&quot;: { # [Output only] Status of all-instances configuration on the group.
            &quot;currentRevision&quot;: &quot;A String&quot;, # [Output Only] Current all-instances configuration revision. This value is in RFC3339 text format.
            &quot;effective&quot;: True or False, # [Output Only] A bit indicating whether this configuration has been applied to all managed instances in the group.
          },
          &quot;autoscaler&quot;: &quot;A String&quot;, # [Output Only] The URL of the Autoscaler that targets this instance group manager.
          &quot;isStable&quot;: True or False, # [Output Only] A bit indicating whether the managed instance group is in a stable state. A stable state means that: none of the instances in the managed instance group is currently undergoing any type of change (for example, creation, restart, or deletion); no future changes are scheduled for instances in the managed instance group; and the managed instance group itself is not being modified.
          &quot;stateful&quot;: { # [Output Only] Stateful status of the given Instance Group Manager.
            &quot;hasStatefulConfig&quot;: True or False, # [Output Only] A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful configuration even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions.
            &quot;isStateful&quot;: True or False, # [Output Only] A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful configuration even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions. This field is deprecated in favor of has_stateful_config.
            &quot;perInstanceConfigs&quot;: { # [Output Only] Status of per-instance configurations on the instances.
              &quot;allEffective&quot;: True or False, # A bit indicating if all of the group&#x27;s per-instance configurations (listed in the output of a listPerInstanceConfigs API call) have status EFFECTIVE or there are no per-instance-configs.
            },
          },
          &quot;versionTarget&quot;: { # [Output Only] A status of consistency of Instances&#x27; versions with their target version specified by version field on Instance Group Manager.
            &quot;isReached&quot;: True or False, # [Output Only] A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances&#x27; target version are specified by version field on Instance Group Manager.
          },
        },
        &quot;targetPools&quot;: [ # The URLs for all TargetPool resources to which instances in the instanceGroup field are added. The target pools automatically apply to all of the instances in the managed instance group.
          &quot;A String&quot;,
        ],
        &quot;targetSize&quot;: 42, # The target number of running instances for this managed instance group. You can reduce this number by using the instanceGroupManager deleteInstances or abandonInstances methods. Resizing the group also changes this number.
        &quot;targetSizeUnit&quot;: &quot;A String&quot;, # The unit of measure for the target size.
        &quot;targetStoppedSize&quot;: 42, # The target number of stopped instances for this managed instance group. This number changes when you: - Stop instance using the stopInstances method or start instances using the startInstances method. - Manually change the targetStoppedSize using the update method.
        &quot;targetSuspendedSize&quot;: 42, # The target number of suspended instances for this managed instance group. This number changes when you: - Suspend instance using the suspendInstances method or resume instances using the resumeInstances method. - Manually change the targetSuspendedSize using the update method.
        &quot;updatePolicy&quot;: { # The update policy for this managed instance group.
          &quot;instanceRedistributionType&quot;: &quot;A String&quot;, # The instance redistribution policy for regional managed instance groups. Valid values are: - PROACTIVE (default): The group attempts to maintain an even distribution of VM instances across zones in the region. - NONE: For non-autoscaled groups, proactive redistribution is disabled.
          &quot;maxSurge&quot;: { # Encapsulates numeric value that can be either absolute or relative. # The maximum number of instances that can be created above the specified targetSize during the update process. This value can be either a fixed number or, if the group has 10 or more instances, a percentage. If you set a percentage, the number of instances is rounded if necessary. The default value for maxSurge is a fixed value equal to the number of zones in which the managed instance group operates. At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxSurge.
            &quot;calculated&quot;: 42, # [Output Only] Absolute value of VM instances calculated based on the specific mode. - If the value is fixed, then the calculated value is equal to the fixed value. - If the value is a percent, then the calculated value is percent/100 * targetSize. For example, the calculated value of a 80% of a managed instance group with 150 instances would be (80/100 * 150) = 120 VM instances. If there is a remainder, the number is rounded.
            &quot;fixed&quot;: 42, # Specifies a fixed number of VM instances. This must be a positive integer.
            &quot;percent&quot;: 42, # Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%.
          },
          &quot;maxUnavailable&quot;: { # Encapsulates numeric value that can be either absolute or relative. # The maximum number of instances that can be unavailable during the update process. An instance is considered available if all of the following conditions are satisfied: - The instance&#x27;s status is RUNNING. - If there is a health check on the instance group, the instance&#x27;s health check status must be HEALTHY at least once. If there is no health check on the group, then the instance only needs to have a status of RUNNING to be considered available. This value can be either a fixed number or, if the group has 10 or more instances, a percentage. If you set a percentage, the number of instances is rounded if necessary. The default value for maxUnavailable is a fixed value equal to the number of zones in which the managed instance group operates. At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxUnavailable.
            &quot;calculated&quot;: 42, # [Output Only] Absolute value of VM instances calculated based on the specific mode. - If the value is fixed, then the calculated value is equal to the fixed value. - If the value is a percent, then the calculated value is percent/100 * targetSize. For example, the calculated value of a 80% of a managed instance group with 150 instances would be (80/100 * 150) = 120 VM instances. If there is a remainder, the number is rounded.
            &quot;fixed&quot;: 42, # Specifies a fixed number of VM instances. This must be a positive integer.
            &quot;percent&quot;: 42, # Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%.
          },
          &quot;minReadySec&quot;: 42, # Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600].
          &quot;minimalAction&quot;: &quot;A String&quot;, # Minimal action to be taken on an instance. Use this option to minimize disruption as much as possible or to apply a more disruptive action than is necessary. - To limit disruption as much as possible, set the minimal action to REFRESH. If your update requires a more disruptive action, Compute Engine performs the necessary action to execute the update. - To apply a more disruptive action than is strictly necessary, set the minimal action to RESTART or REPLACE. For example, Compute Engine does not need to restart a VM to change its metadata. But if your application reads instance metadata only when a VM is restarted, you can set the minimal action to RESTART in order to pick up metadata changes.
          &quot;mostDisruptiveAllowedAction&quot;: &quot;A String&quot;, # Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to avoid restarting the VM and to limit disruption as much as possible. RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
          &quot;replacementMethod&quot;: &quot;A String&quot;, # What action should be used to replace instances. See minimal_action.REPLACE
          &quot;type&quot;: &quot;A String&quot;, # The type of update process. You can specify either PROACTIVE so that the MIG automatically updates VMs to the latest configurations or OPPORTUNISTIC so that you can select the VMs that you want to update.
        },
        &quot;versions&quot;: [ # Specifies the instance templates used by this managed instance group to create instances. Each version is defined by an instanceTemplate and a name. Every version can appear at most once per instance group. This field overrides the top-level instanceTemplate field. Read more about the relationships between these fields. Exactly one version must leave the targetSize field unset. That version will be applied to all remaining instances. For more information, read about canary updates.
          {
            &quot;instanceTemplate&quot;: &quot;A String&quot;, # The URL of the instance template that is specified for this managed instance group. The group uses this template to create new instances in the managed instance group until the `targetSize` for this version is reached. The templates for existing instances in the group do not change unless you run recreateInstances, run applyUpdatesToInstances, or set the group&#x27;s updatePolicy.type to PROACTIVE; in those cases, existing instances are updated until the `targetSize` for this version is reached.
            &quot;name&quot;: &quot;A String&quot;, # Name of the version. Unique among all versions in the scope of this managed instance group.
            &quot;tag&quot;: &quot;A String&quot;, # Tag describing the version. Used to trigger rollout of a target version even if instance_template remains unchanged. Deprecated in favor of &#x27;name&#x27;.
            &quot;targetSize&quot;: { # Encapsulates numeric value that can be either absolute or relative. # Specifies the intended number of instances to be created from the instanceTemplate. The final number of instances created from the template will be equal to: - If expressed as a fixed number, the minimum of either targetSize.fixed or instanceGroupManager.targetSize is used. - if expressed as a percent, the targetSize would be (targetSize.percent/100 * InstanceGroupManager.targetSize) If there is a remainder, the number is rounded. If unset, this version will update any remaining instances not updated by another version. Read Starting a canary update for more information.
              &quot;calculated&quot;: 42, # [Output Only] Absolute value of VM instances calculated based on the specific mode. - If the value is fixed, then the calculated value is equal to the fixed value. - If the value is a percent, then the calculated value is percent/100 * targetSize. For example, the calculated value of a 80% of a managed instance group with 150 instances would be (80/100 * 150) = 120 VM instances. If there is a remainder, the number is rounded.
              &quot;fixed&quot;: 42, # Specifies a fixed number of VM instances. This must be a positive integer.
              &quot;percent&quot;: 42, # Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%.
            },
          },
        ],
        &quot;zone&quot;: &quot;A String&quot;, # [Output Only] The URL of a zone where the managed instance group is located (for zonal resources).
      },
    },
  },
  &quot;region&quot;: &quot;A String&quot;, # [Output Only] URL of the region where the resource resides. Only applicable for regional resources. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
  &quot;schedulingPolicy&quot;: { # Policy for handling provisioning and other scheduling-related events. # Policy for handling provisioning and other scheduling-related events.
    &quot;provisioning&quot;: &quot;A String&quot;, # How provisioning of MIGs should be scheduled (coordinated or not)
  },
  &quot;selfLink&quot;: &quot;A String&quot;, # [Output only] Server-defined URL for the resource.
  &quot;selfLinkWithId&quot;: &quot;A String&quot;, # [Output Only] Server-defined URL for this resource with the resource id.
}

  requestId: string, An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Represents an Operation resource. Google Compute Engine has three Operation resources: * [Global](/compute/docs/reference/rest/alpha/globalOperations) * [Regional](/compute/docs/reference/rest/alpha/regionOperations) * [Zonal](/compute/docs/reference/rest/alpha/zoneOperations) You can use an operation resource to manage asynchronous API requests. For more information, read Handling API responses. Operations can be global, regional or zonal. - For global operations, use the `globalOperations` resource. - For regional operations, use the `regionOperations` resource. - For zonal operations, use the `zoneOperations` resource. For more information, read Global, Regional, and Zonal Resources. Note that completed Operation resources have a limited retention period.
  &quot;clientOperationId&quot;: &quot;A String&quot;, # [Output Only] The value of `requestId` if you provided it in the request. Not present otherwise.
  &quot;creationTimestamp&quot;: &quot;A String&quot;, # [Deprecated] This field is deprecated.
  &quot;description&quot;: &quot;A String&quot;, # [Output Only] A textual description of the operation, which is set when the operation is created.
  &quot;endTime&quot;: &quot;A String&quot;, # [Output Only] The time that this operation was completed. This value is in RFC3339 text format.
  &quot;error&quot;: { # [Output Only] If errors are generated during processing of the operation, this field will be populated.
    &quot;errors&quot;: [ # [Output Only] The array of errors encountered while processing this operation.
      {
        &quot;code&quot;: &quot;A String&quot;, # [Output Only] The error type identifier for this error.
        &quot;errorDetails&quot;: [ # [Output Only] An optional list of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.
          {
            &quot;errorInfo&quot;: { # Describes the cause of the error with structured details. Example of an error when contacting the &quot;pubsub.googleapis.com&quot; API when it is not enabled: { &quot;reason&quot;: &quot;API_DISABLED&quot; &quot;domain&quot;: &quot;googleapis.com&quot; &quot;metadata&quot;: { &quot;resource&quot;: &quot;projects/123&quot;, &quot;service&quot;: &quot;pubsub.googleapis.com&quot; } } This response indicates that the pubsub.googleapis.com API is not enabled. Example of an error that is returned when attempting to create a Spanner instance in a region that is out of stock: { &quot;reason&quot;: &quot;STOCKOUT&quot; &quot;domain&quot;: &quot;spanner.googleapis.com&quot;, &quot;metadata&quot;: { &quot;availableRegions&quot;: &quot;us-central1,us-east2&quot; } }
              &quot;domain&quot;: &quot;A String&quot;, # The logical grouping to which the &quot;reason&quot; belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: &quot;pubsub.googleapis.com&quot;. If the error is generated by some common infrastructure, the error domain must be a globally unique value that identifies the infrastructure. For Google API infrastructure, the error domain is &quot;googleapis.com&quot;.
              &quot;metadatas&quot;: { # Additional structured details about this error. Keys must match /a-z+/ but should ideally be lowerCamelCase. Also they must be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {&quot;instanceLimit&quot;: &quot;100/request&quot;}, should be returned as, {&quot;instanceLimitPerRequest&quot;: &quot;100&quot;}, if the client exceeds the number of instances that can be created in a single (batch) request.
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;reason&quot;: &quot;A String&quot;, # The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors. This should be at most 63 characters and match a regular expression of `A-Z+[A-Z0-9]`, which represents UPPER_SNAKE_CASE.
            },
            &quot;help&quot;: { # Provides links to documentation or for performing an out of band action. For example, if a quota check failed with an error indicating the calling project hasn&#x27;t enabled the accessed service, this can contain a URL pointing directly to the right place in the developer console to flip the bit.
              &quot;links&quot;: [ # URL(s) pointing to additional information on handling the current error.
                { # Describes a URL link.
                  &quot;description&quot;: &quot;A String&quot;, # Describes what the link offers.
                  &quot;url&quot;: &quot;A String&quot;, # The URL of the link.
                },
              ],
            },
            &quot;localizedMessage&quot;: { # Provides a localized error message that is safe to return to the user which can be attached to an RPC error.
              &quot;locale&quot;: &quot;A String&quot;, # The locale used following the specification defined at https://www.rfc-editor.org/rfc/bcp/bcp47.txt. Examples are: &quot;en-US&quot;, &quot;fr-CH&quot;, &quot;es-MX&quot;
              &quot;message&quot;: &quot;A String&quot;, # The localized error message in the above locale.
            },
            &quot;quotaInfo&quot;: { # Additional details for quota exceeded error for resource quota.
              &quot;dimensions&quot;: { # The map holding related quota dimensions.
                &quot;a_key&quot;: &quot;A String&quot;,
              },
              &quot;futureLimit&quot;: 3.14, # Future quota limit being rolled out. The limit&#x27;s unit depends on the quota type or metric.
              &quot;limit&quot;: 3.14, # Current effective quota limit. The limit&#x27;s unit depends on the quota type or metric.
              &quot;limitName&quot;: &quot;A String&quot;, # The name of the quota limit.
              &quot;metricName&quot;: &quot;A String&quot;, # The Compute Engine quota metric name.
              &quot;rolloutStatus&quot;: &quot;A String&quot;, # Rollout status of the future quota limit.
            },
          },
        ],
        &quot;location&quot;: &quot;A String&quot;, # [Output Only] Indicates the field in the request that caused the error. This property is optional.
        &quot;message&quot;: &quot;A String&quot;, # [Output Only] An optional, human-readable error message.
      },
    ],
  },
  &quot;httpErrorMessage&quot;: &quot;A String&quot;, # [Output Only] If the operation fails, this field contains the HTTP error message that was returned, such as `NOT FOUND`.
  &quot;httpErrorStatusCode&quot;: 42, # [Output Only] If the operation fails, this field contains the HTTP error status code that was returned. For example, a `404` means the resource was not found.
  &quot;id&quot;: &quot;A String&quot;, # [Output Only] The unique identifier for the operation. This identifier is defined by the server.
  &quot;insertTime&quot;: &quot;A String&quot;, # [Output Only] The time that this operation was requested. This value is in RFC3339 text format.
  &quot;instancesBulkInsertOperationMetadata&quot;: {
    &quot;perLocationStatus&quot;: { # Status information per location (location name is key). Example key: zones/us-central1-a
      &quot;a_key&quot;: {
        &quot;createdVmCount&quot;: 42, # [Output Only] Count of VMs successfully created so far.
        &quot;deletedVmCount&quot;: 42, # [Output Only] Count of VMs that got deleted during rollback.
        &quot;failedToCreateVmCount&quot;: 42, # [Output Only] Count of VMs that started creating but encountered an error.
        &quot;status&quot;: &quot;A String&quot;, # [Output Only] Creation status of BulkInsert operation - information if the flow is rolling forward or rolling back.
        &quot;targetVmCount&quot;: 42, # [Output Only] Count of VMs originally planned to be created.
      },
    },
  },
  &quot;kind&quot;: &quot;compute#operation&quot;, # [Output Only] Type of the resource. Always `compute#operation` for Operation resources.
  &quot;name&quot;: &quot;A String&quot;, # [Output Only] Name of the operation.
  &quot;operationGroupId&quot;: &quot;A String&quot;, # [Output Only] An ID that represents a group of operations, such as when a group of operations results from a `bulkInsert` API request.
  &quot;operationType&quot;: &quot;A String&quot;, # [Output Only] The type of operation, such as `insert`, `update`, or `delete`, and so on.
  &quot;progress&quot;: 42, # [Output Only] An optional progress indicator that ranges from 0 to 100. There is no requirement that this be linear or support any granularity of operations. This should not be used to guess when the operation will be complete. This number should monotonically increase as the operation progresses.
  &quot;region&quot;: &quot;A String&quot;, # [Output Only] The URL of the region where the operation resides. Only applicable when performing regional operations.
  &quot;selfLink&quot;: &quot;A String&quot;, # [Output Only] Server-defined URL for the resource.
  &quot;selfLinkWithId&quot;: &quot;A String&quot;, # [Output Only] Server-defined URL for this resource with the resource id.
  &quot;setCommonInstanceMetadataOperationMetadata&quot;: { # [Output Only] If the operation is for projects.setCommonInstanceMetadata, this field will contain information on all underlying zonal actions and their state.
    &quot;clientOperationId&quot;: &quot;A String&quot;, # [Output Only] The client operation id.
    &quot;perLocationOperations&quot;: { # [Output Only] Status information per location (location name is key). Example key: zones/us-central1-a
      &quot;a_key&quot;: {
        &quot;error&quot;: { # The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors). # [Output Only] If state is `ABANDONED` or `FAILED`, this field is populated.
          &quot;code&quot;: 42, # The status code, which should be an enum value of google.rpc.Code.
          &quot;details&quot;: [ # A list of messages that carry the error details. There is a common set of message types for APIs to use.
            {
              &quot;a_key&quot;: &quot;&quot;, # Properties of the object. Contains field @type with type URL.
            },
          ],
          &quot;message&quot;: &quot;A String&quot;, # A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        },
        &quot;state&quot;: &quot;A String&quot;, # [Output Only] Status of the action, which can be one of the following: `PROPAGATING`, `PROPAGATED`, `ABANDONED`, `FAILED`, or `DONE`.
      },
    },
  },
  &quot;startTime&quot;: &quot;A String&quot;, # [Output Only] The time that this operation was started by the server. This value is in RFC3339 text format.
  &quot;status&quot;: &quot;A String&quot;, # [Output Only] The status of the operation, which can be one of the following: `PENDING`, `RUNNING`, or `DONE`.
  &quot;statusMessage&quot;: &quot;A String&quot;, # [Output Only] An optional textual description of the current status of the operation.
  &quot;targetId&quot;: &quot;A String&quot;, # [Output Only] The unique target ID, which identifies a specific incarnation of the target resource.
  &quot;targetLink&quot;: &quot;A String&quot;, # [Output Only] The URL of the resource that the operation modifies. For operations related to creating a snapshot, this points to the persistent disk that the snapshot was created from.
  &quot;user&quot;: &quot;A String&quot;, # [Output Only] User who requested the operation, for example: `user@example.com` or `alice_smith_identifier (global/workforcePools/example-com-us-employees)`.
  &quot;warnings&quot;: [ # [Output Only] If warning messages are generated during processing of the operation, this field will be populated.
    {
      &quot;code&quot;: &quot;A String&quot;, # [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
      &quot;data&quot;: [ # [Output Only] Metadata about this warning in key: value format. For example: &quot;data&quot;: [ { &quot;key&quot;: &quot;scope&quot;, &quot;value&quot;: &quot;zones/us-east1-d&quot; }
        {
          &quot;key&quot;: &quot;A String&quot;, # [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
          &quot;value&quot;: &quot;A String&quot;, # [Output Only] A warning data value corresponding to the key.
        },
      ],
      &quot;message&quot;: &quot;A String&quot;, # [Output Only] A human-readable description of the warning code.
    },
  ],
  &quot;zone&quot;: &quot;A String&quot;, # [Output Only] The URL of the zone where the operation resides. Only applicable when performing per-zone operations.
}</pre>
</div>

<div class="method">
    <code class="details" id="list">list(project, region, filter=None, maxResults=None, orderBy=None, pageToken=None, returnPartialSuccess=None, x__xgafv=None)</code>
  <pre>Retrieves a list of MultiMIGs in a project and region.

Args:
  project: string, Project ID for this request. (required)
  region: string, Name of the region for this request. (required)
  filter: string, A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `&gt;`, `&lt;`, `&lt;=`, `&gt;=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = &quot;Intel Skylake&quot;) ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = &quot;Intel Skylake&quot;) OR (cpuPlatform = &quot;Intel Broadwell&quot;) AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq &#x27;single quoted literal&#x27;` `fieldname eq &quot;double quoted literal&quot;` `(fieldname1 eq literal) (fieldname2 ne &quot;literal&quot;)` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name &quot;instance&quot;, you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.
  maxResults: integer, The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)
  orderBy: string, Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy=&quot;creationTimestamp desc&quot;`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.
  pageToken: string, Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.
  returnPartialSuccess: boolean, Opt-in for partial success behavior which provides partial results in case of failure. The default value is false. For example, when partial success behavior is enabled, aggregatedList for a single zone scope either returns all resources in the zone or no resources, with an error code.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    {
  &quot;etag&quot;: &quot;A String&quot;,
  &quot;id&quot;: &quot;A String&quot;, # Unique identifier for the resource; defined by the server.
  &quot;items&quot;: [ # A list of MultiMig resources.
    { # MultiMIG represents a group of Managed Instance Groups.
      &quot;creationTimestamp&quot;: &quot;A String&quot;, # [Output Only] Creation timestamp in RFC3339 text format.
      &quot;description&quot;: &quot;A String&quot;, # An optional description of this resource. Provide this property when you create the resource.
      &quot;id&quot;: &quot;A String&quot;, # [Output Only] The unique identifier for the resource. This identifier is defined by the server.
      &quot;kind&quot;: &quot;compute#multiMig&quot;, # [Output Only] Type of the resource. Always compute#multiMig for MultiMIGs.
      &quot;locationPolicy&quot;: { # Policy regarding where to create MIGs Initially only zonal MIGs in the same zone are supported.
        &quot;provisioningZones&quot;: [ # List of zones where MIGs will be provisioned. Should be valid RFC1035 name
          &quot;A String&quot;,
        ],
      },
      &quot;name&quot;: &quot;A String&quot;, # Name of the resource. Provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
      &quot;parts&quot;: { # User-provided names for Parts of MultiMIG and the Parts themselves.
        &quot;a_key&quot;: { # Config for an MMIG part.
          &quot;instanceGroupManager&quot;: &quot;A String&quot;, # Link to an existing InstanceGroupManager that will be adopted by a MultiMIG.
          &quot;instanceGroupManagerProperties&quot;: { # Represents a Managed Instance Group resource. An instance group is a collection of VM instances that you can manage as a single entity. For more information, read Instance groups. For zonal Managed Instance Group, use the instanceGroupManagers resource. For regional Managed Instance Group, use the regionInstanceGroupManagers resource. # InstanceGroupManager to be created by the multiMig
            &quot;allInstancesConfig&quot;: { # Specifies configuration that overrides the instance template configuration for the group.
              &quot;properties&quot;: { # Represents the change that you want to make to the instance properties. # Properties to set on all instances in the group. You can add or modify properties using the instanceGroupManagers.patch or regionInstanceGroupManagers.patch. After setting allInstancesConfig on the group, you must update the group&#x27;s instances to apply the configuration. To apply the configuration, set the group&#x27;s updatePolicy.type field to use proactive updates or use the applyUpdatesToInstances method.
                &quot;labels&quot;: { # The label key-value pairs that you want to patch onto the instance.
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
                &quot;metadata&quot;: { # The metadata key-value pairs that you want to patch onto the instance. For more information, see Project and instance metadata.
                  &quot;a_key&quot;: &quot;A String&quot;,
                },
              },
            },
            &quot;autoHealingPolicies&quot;: [ # The autohealing policy for this managed instance group. You can specify only one value.
              {
                &quot;autoHealingTriggers&quot;: { # Restricts what triggers autohealing.
                  &quot;onHealthCheck&quot;: &quot;A String&quot;, # If you have configured an application-based health check for the group, this field controls whether to trigger VM autohealing based on a failed health check. Valid values are: - ON (default): The group recreates running VMs that fail the application-based health check. - OFF: When set to OFF, you can still observe instance health state, but the group does not recreate VMs that fail the application-based health check. This is useful for troubleshooting and setting up your health check configuration.
                },
                &quot;healthCheck&quot;: &quot;A String&quot;, # The URL for the health check that signals autohealing.
                &quot;initialDelaySec&quot;: 42, # The initial delay is the number of seconds that a new VM takes to initialize and run its startup script. During a VM&#x27;s initial delay period, the MIG ignores unsuccessful health checks because the VM might be in the startup process. This prevents the MIG from prematurely recreating a VM. If the health check receives a healthy response during the initial delay, it indicates that the startup process is complete and the VM is ready. The value of initial delay must be between 0 and 3600 seconds. The default value is 0.
                &quot;maxUnavailable&quot;: { # Encapsulates numeric value that can be either absolute or relative. # Maximum number of instances that can be unavailable when autohealing. When &#x27;percent&#x27; is used, the value is rounded if necessary. The instance is considered available if all of the following conditions are satisfied: 1. Instance&#x27;s status is RUNNING. 2. Instance&#x27;s currentAction is NONE (in particular its liveness health check result was observed to be HEALTHY at least once as it passed VERIFYING). 3. There is no outgoing action on an instance triggered by IGM. By default, number of concurrently autohealed instances is smaller than the managed instance group target size. However, if a zonal managed instance group has only one instance, or a regional managed instance group has only one instance per zone, autohealing will recreate these instances when they become unhealthy.
                  &quot;calculated&quot;: 42, # [Output Only] Absolute value of VM instances calculated based on the specific mode. - If the value is fixed, then the calculated value is equal to the fixed value. - If the value is a percent, then the calculated value is percent/100 * targetSize. For example, the calculated value of a 80% of a managed instance group with 150 instances would be (80/100 * 150) = 120 VM instances. If there is a remainder, the number is rounded.
                  &quot;fixed&quot;: 42, # Specifies a fixed number of VM instances. This must be a positive integer.
                  &quot;percent&quot;: 42, # Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%.
                },
              },
            ],
            &quot;baseInstanceName&quot;: &quot;A String&quot;, # The base instance name to use for instances in this group. The value must be 1-58 characters long. Instances are named by appending a hyphen and a random four-character string to the base instance name. The base instance name must comply with RFC1035.
            &quot;creationTimestamp&quot;: &quot;A String&quot;, # [Output Only] The creation timestamp for this managed instance group in RFC3339 text format.
            &quot;currentActions&quot;: { # [Output Only] The list of instance actions and the number of instances in this managed instance group that are scheduled for each of those actions.
              &quot;abandoning&quot;: 42, # [Output Only] The total number of instances in the managed instance group that are scheduled to be abandoned. Abandoning an instance removes it from the managed instance group without deleting it.
              &quot;creating&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be created or are currently being created. If the group fails to create any of these instances, it tries again until it creates the instance successfully. If you have disabled creation retries, this field will not be populated; instead, the creatingWithoutRetries field will be populated.
              &quot;creatingAtomically&quot;: 42, # [Output Only] The number of instances that the managed instance group will attempt to create atomically, in a batch mode. If the desired count of instances can not be created, entire batch will be deleted and the group will decrease its targetSize value accordingly.
              &quot;creatingWithoutRetries&quot;: 42, # [Output Only] The number of instances that the managed instance group will attempt to create. The group attempts to create each instance only once. If the group fails to create any of these instances, it decreases the group&#x27;s targetSize value accordingly.
              &quot;deleting&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be deleted or are currently being deleted.
              &quot;none&quot;: 42, # [Output Only] The number of instances in the managed instance group that are running and have no scheduled actions.
              &quot;queuing&quot;: 42, # [Output Only] The number of instances that the managed instance group is currently queuing.
              &quot;recreating&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be recreated or are currently being being recreated. Recreating an instance deletes the existing root persistent disk and creates a new disk from the image that is defined in the instance template.
              &quot;refreshing&quot;: 42, # [Output Only] The number of instances in the managed instance group that are being reconfigured with properties that do not require a restart or a recreate action. For example, setting or removing target pools for the instance.
              &quot;restarting&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be restarted or are currently being restarted.
              &quot;resuming&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be resumed or are currently being resumed.
              &quot;starting&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be started or are currently being started.
              &quot;stopping&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be stopped or are currently being stopped.
              &quot;suspending&quot;: 42, # [Output Only] The number of instances in the managed instance group that are scheduled to be suspended or are currently being suspended.
              &quot;verifying&quot;: 42, # [Output Only] The number of instances in the managed instance group that are being verified. See the managedInstances[].currentAction property in the listManagedInstances method documentation.
            },
            &quot;description&quot;: &quot;A String&quot;, # An optional description of this resource.
            &quot;distributionPolicy&quot;: { # Policy specifying the intended distribution of managed instances across zones in a regional managed instance group.
              &quot;targetShape&quot;: &quot;A String&quot;, # The distribution shape to which the group converges either proactively or on resize events (depending on the value set in updatePolicy.instanceRedistributionType).
              &quot;zones&quot;: [ # Zones where the regional managed instance group will create and manage its instances.
                {
                  &quot;zone&quot;: &quot;A String&quot;, # The URL of the zone. The zone must exist in the region where the managed instance group is located.
                },
              ],
            },
            &quot;failoverAction&quot;: &quot;A String&quot;, # The action to perform in case of zone failure. Only one value is supported, NO_FAILOVER. The default is NO_FAILOVER.
            &quot;fingerprint&quot;: &quot;A String&quot;, # Fingerprint of this resource. This field may be used in optimistic locking. It will be ignored when inserting an InstanceGroupManager. An up-to-date fingerprint must be provided in order to update the InstanceGroupManager, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve an InstanceGroupManager.
            &quot;id&quot;: &quot;A String&quot;, # [Output Only] A unique identifier for this resource type. The server generates this identifier.
            &quot;instanceFlexibilityPolicy&quot;: { # Instance flexibility allowing MIG to create VMs from multiple types of machines. Instance flexibility configuration on MIG overrides instance template configuration.
              &quot;instanceSelectionLists&quot;: { # Named instance selections configuring properties that the group will use when creating new VMs.
                &quot;a_key&quot;: {
                  &quot;machineTypes&quot;: [ # Full machine-type names, e.g. &quot;n1-standard-16&quot;.
                    &quot;A String&quot;,
                  ],
                  &quot;rank&quot;: 42, # Preference of this instance selection. Lower number means higher preference. MIG will first try to create a VM based on the machine-type with lowest rank and fallback to next rank based on availability. Machine types and instance selections with the same rank have the same preference.
                },
              },
              &quot;instanceSelections&quot;: { # Named instance selections configuring properties that the group will use when creating new VMs.
                &quot;a_key&quot;: {
                  &quot;machineTypes&quot;: [ # Full machine-type names, e.g. &quot;n1-standard-16&quot;.
                    &quot;A String&quot;,
                  ],
                  &quot;rank&quot;: 42, # Preference of this instance selection. Lower number means higher preference. MIG will first try to create a VM based on the machine-type with lowest rank and fallback to next rank based on availability. Machine types and instance selections with the same rank have the same preference.
                },
              },
              &quot;provisioningModelMix&quot;: { # Provisioning model configuration used by this managed instance group to create instances.
                &quot;standardCapacityBase&quot;: 42, # The base capacity that will always use Standard VMs to avoid risk of more preemption than the minimum capacity user needs. MIG will create only Standard VMs until it reaches standard_capacity_base and only then will start using standard_capacity_percent_above_base to mix Spot with Standard VMs.
                &quot;standardCapacityPercentAboveBase&quot;: 42, # The percentage of target capacity that should use Standard VM. The remaining percentage will use Spot VMs. The percentage applies only to the capacity above standard_capacity_base.
              },
            },
            &quot;instanceGroup&quot;: &quot;A String&quot;, # [Output Only] The URL of the Instance Group resource.
            &quot;instanceLifecyclePolicy&quot;: { # The repair policy for this managed instance group.
              &quot;defaultActionOnFailure&quot;: &quot;A String&quot;, # The action that a MIG performs on a failed or an unhealthy VM. A VM is marked as unhealthy when the application running on that VM fails a health check. Valid values are - REPAIR (default): MIG automatically repairs a failed or an unhealthy VM by recreating it. For more information, see About repairing VMs in a MIG. - DO_NOTHING: MIG does not repair a failed or an unhealthy VM.
              &quot;forceUpdateOnRepair&quot;: &quot;A String&quot;, # A bit indicating whether to forcefully apply the group&#x27;s latest configuration when repairing a VM. Valid options are: - NO (default): If configuration updates are available, they are not forcefully applied during repair. Instead, configuration updates are applied according to the group&#x27;s update policy. - YES: If configuration updates are available, they are applied during repair.
              &quot;metadataBasedReadinessSignal&quot;: { # The configuration for metadata based readiness signal sent by the instance during initialization when stopping / suspending an instance. The Instance Group Manager will wait for a signal that indicates successful initialization before stopping / suspending an instance. If a successful readiness signal is not sent before timeout, the corresponding instance will not be stopped / suspended. Instead, an error will be visible in the lastAttempt.errors field of the managed instance in the listmanagedinstances method. If metadataBasedReadinessSignal.timeoutSec is unset, the Instance Group Manager will directly proceed to suspend / stop instances, skipping initialization on them.
                &quot;timeoutSec&quot;: 42, # The number of seconds to wait for a readiness signal during initialization before timing out.
              },
              &quot;onFailedHealthCheck&quot;: &quot;A String&quot;, # The action that a MIG performs on an unhealthy VM. A VM is marked as unhealthy when the application running on that VM fails a health check. Valid values are: - DEFAULT_ACTION (default): The MIG performs the same action as specified in the instanceLifecyclePolicy.defaultActionOnFailure field. If the defaultActionOnFailure field is set to REPAIR, then the MIG repairs unhealthy VMs. If the defaultActionOnFailure field is set to DO_NOTHING, then the MIG doesn&#x27;t repair unhealthy VMs. - REPAIR: The MIG repairs unhealthy VMs by recreating it. - DO_NOTHING: The MIG doesn&#x27;t repair unhealthy VMs. For more information, see About repairing VMs in a MIG.
            },
            &quot;instanceTemplate&quot;: &quot;A String&quot;, # The URL of the instance template that is specified for this managed instance group. The group uses this template to create all new instances in the managed instance group. The templates for existing instances in the group do not change unless you run recreateInstances, run applyUpdatesToInstances, or set the group&#x27;s updatePolicy.type to PROACTIVE.
            &quot;kind&quot;: &quot;compute#instanceGroupManager&quot;, # [Output Only] The resource type, which is always compute#instanceGroupManager for managed instance groups.
            &quot;listManagedInstancesResults&quot;: &quot;A String&quot;, # Pagination behavior of the listManagedInstances API method for this managed instance group.
            &quot;name&quot;: &quot;A String&quot;, # The name of the managed instance group. The name must be 1-63 characters long, and comply with RFC1035.
            &quot;namedPorts&quot;: [ # Named ports configured for the Instance Groups complementary to this Instance Group Manager.
              { # The named port. For example: &lt;&quot;http&quot;, 80&gt;.
                &quot;name&quot;: &quot;A String&quot;, # The name for this named port. The name must be 1-63 characters long, and comply with RFC1035.
                &quot;port&quot;: 42, # The port number, which can be a value between 1 and 65535.
              },
            ],
            &quot;params&quot;: { # Input only additional params for instance group manager creation. # Input only. Additional params passed with the request, but not persisted as part of resource payload.
              &quot;resourceManagerTags&quot;: { # Resource manager tags to bind to the managed instance group. The tags are key-value pairs. Keys must be in the format tagKeys/123 and values in the format tagValues/456. For more information, see Manage tags for resources.
                &quot;a_key&quot;: &quot;A String&quot;,
              },
            },
            &quot;region&quot;: &quot;A String&quot;, # [Output Only] The URL of the region where the managed instance group resides (for regional resources).
            &quot;satisfiesPzi&quot;: True or False, # [Output Only] Reserved for future use.
            &quot;satisfiesPzs&quot;: True or False, # [Output Only] Reserved for future use.
            &quot;selfLink&quot;: &quot;A String&quot;, # [Output Only] The URL for this managed instance group. The server defines this URL.
            &quot;selfLinkWithId&quot;: &quot;A String&quot;, # [Output Only] Server-defined URL for this resource with the resource id.
            &quot;serviceAccount&quot;: &quot;A String&quot;, # The service account to be used as credentials for all operations performed by the managed instance group on instances. The service accounts needs all permissions required to create and delete instances. By default, the service account {projectNumber}@cloudservices.gserviceaccount.com is used.
            &quot;standbyPolicy&quot;: { # Standby policy for stopped and suspended instances.
              &quot;initialDelaySec&quot;: 42, # Specifies the number of seconds that the MIG should wait to suspend or stop a VM after that VM was created. The initial delay gives the initialization script the time to prepare your VM for a quick scale out. The value of initial delay must be between 0 and 3600 seconds. The default value is 0.
              &quot;mode&quot;: &quot;A String&quot;, # Defines how a MIG resumes or starts VMs from a standby pool when the group scales out. The default mode is `MANUAL`.
            },
            &quot;statefulPolicy&quot;: { # Stateful configuration for this Instanced Group Manager
              &quot;preservedState&quot;: { # Configuration of preserved resources.
                &quot;disks&quot;: { # Disks created on the instances that will be preserved on instance delete, update, etc. This map is keyed with the device names of the disks.
                  &quot;a_key&quot;: {
                    &quot;autoDelete&quot;: &quot;A String&quot;, # These stateful disks will never be deleted during autohealing, update or VM instance recreate operations. This flag is used to configure if the disk should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted. Note: disks attached in READ_ONLY mode cannot be auto-deleted.
                  },
                },
                &quot;externalIPs&quot;: { # External network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name.
                  &quot;a_key&quot;: {
                    &quot;autoDelete&quot;: &quot;A String&quot;, # These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
                  },
                },
                &quot;internalIPs&quot;: { # Internal network IPs assigned to the instances that will be preserved on instance delete, update, etc. This map is keyed with the network interface name.
                  &quot;a_key&quot;: {
                    &quot;autoDelete&quot;: &quot;A String&quot;, # These stateful IPs will never be released during autohealing, update or VM instance recreate operations. This flag is used to configure if the IP reservation should be deleted after it is no longer used by the group, e.g. when the given instance or the whole group is deleted.
                  },
                },
              },
            },
            &quot;status&quot;: { # [Output Only] The status of this managed instance group.
              &quot;allInstancesConfig&quot;: { # [Output only] Status of all-instances configuration on the group.
                &quot;currentRevision&quot;: &quot;A String&quot;, # [Output Only] Current all-instances configuration revision. This value is in RFC3339 text format.
                &quot;effective&quot;: True or False, # [Output Only] A bit indicating whether this configuration has been applied to all managed instances in the group.
              },
              &quot;autoscaler&quot;: &quot;A String&quot;, # [Output Only] The URL of the Autoscaler that targets this instance group manager.
              &quot;isStable&quot;: True or False, # [Output Only] A bit indicating whether the managed instance group is in a stable state. A stable state means that: none of the instances in the managed instance group is currently undergoing any type of change (for example, creation, restart, or deletion); no future changes are scheduled for instances in the managed instance group; and the managed instance group itself is not being modified.
              &quot;stateful&quot;: { # [Output Only] Stateful status of the given Instance Group Manager.
                &quot;hasStatefulConfig&quot;: True or False, # [Output Only] A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful configuration even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions.
                &quot;isStateful&quot;: True or False, # [Output Only] A bit indicating whether the managed instance group has stateful configuration, that is, if you have configured any items in a stateful policy or in per-instance configs. The group might report that it has no stateful configuration even when there is still some preserved state on a managed instance, for example, if you have deleted all PICs but not yet applied those deletions. This field is deprecated in favor of has_stateful_config.
                &quot;perInstanceConfigs&quot;: { # [Output Only] Status of per-instance configurations on the instances.
                  &quot;allEffective&quot;: True or False, # A bit indicating if all of the group&#x27;s per-instance configurations (listed in the output of a listPerInstanceConfigs API call) have status EFFECTIVE or there are no per-instance-configs.
                },
              },
              &quot;versionTarget&quot;: { # [Output Only] A status of consistency of Instances&#x27; versions with their target version specified by version field on Instance Group Manager.
                &quot;isReached&quot;: True or False, # [Output Only] A bit indicating whether version target has been reached in this managed instance group, i.e. all instances are in their target version. Instances&#x27; target version are specified by version field on Instance Group Manager.
              },
            },
            &quot;targetPools&quot;: [ # The URLs for all TargetPool resources to which instances in the instanceGroup field are added. The target pools automatically apply to all of the instances in the managed instance group.
              &quot;A String&quot;,
            ],
            &quot;targetSize&quot;: 42, # The target number of running instances for this managed instance group. You can reduce this number by using the instanceGroupManager deleteInstances or abandonInstances methods. Resizing the group also changes this number.
            &quot;targetSizeUnit&quot;: &quot;A String&quot;, # The unit of measure for the target size.
            &quot;targetStoppedSize&quot;: 42, # The target number of stopped instances for this managed instance group. This number changes when you: - Stop instance using the stopInstances method or start instances using the startInstances method. - Manually change the targetStoppedSize using the update method.
            &quot;targetSuspendedSize&quot;: 42, # The target number of suspended instances for this managed instance group. This number changes when you: - Suspend instance using the suspendInstances method or resume instances using the resumeInstances method. - Manually change the targetSuspendedSize using the update method.
            &quot;updatePolicy&quot;: { # The update policy for this managed instance group.
              &quot;instanceRedistributionType&quot;: &quot;A String&quot;, # The instance redistribution policy for regional managed instance groups. Valid values are: - PROACTIVE (default): The group attempts to maintain an even distribution of VM instances across zones in the region. - NONE: For non-autoscaled groups, proactive redistribution is disabled.
              &quot;maxSurge&quot;: { # Encapsulates numeric value that can be either absolute or relative. # The maximum number of instances that can be created above the specified targetSize during the update process. This value can be either a fixed number or, if the group has 10 or more instances, a percentage. If you set a percentage, the number of instances is rounded if necessary. The default value for maxSurge is a fixed value equal to the number of zones in which the managed instance group operates. At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxSurge.
                &quot;calculated&quot;: 42, # [Output Only] Absolute value of VM instances calculated based on the specific mode. - If the value is fixed, then the calculated value is equal to the fixed value. - If the value is a percent, then the calculated value is percent/100 * targetSize. For example, the calculated value of a 80% of a managed instance group with 150 instances would be (80/100 * 150) = 120 VM instances. If there is a remainder, the number is rounded.
                &quot;fixed&quot;: 42, # Specifies a fixed number of VM instances. This must be a positive integer.
                &quot;percent&quot;: 42, # Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%.
              },
              &quot;maxUnavailable&quot;: { # Encapsulates numeric value that can be either absolute or relative. # The maximum number of instances that can be unavailable during the update process. An instance is considered available if all of the following conditions are satisfied: - The instance&#x27;s status is RUNNING. - If there is a health check on the instance group, the instance&#x27;s health check status must be HEALTHY at least once. If there is no health check on the group, then the instance only needs to have a status of RUNNING to be considered available. This value can be either a fixed number or, if the group has 10 or more instances, a percentage. If you set a percentage, the number of instances is rounded if necessary. The default value for maxUnavailable is a fixed value equal to the number of zones in which the managed instance group operates. At least one of either maxSurge or maxUnavailable must be greater than 0. Learn more about maxUnavailable.
                &quot;calculated&quot;: 42, # [Output Only] Absolute value of VM instances calculated based on the specific mode. - If the value is fixed, then the calculated value is equal to the fixed value. - If the value is a percent, then the calculated value is percent/100 * targetSize. For example, the calculated value of a 80% of a managed instance group with 150 instances would be (80/100 * 150) = 120 VM instances. If there is a remainder, the number is rounded.
                &quot;fixed&quot;: 42, # Specifies a fixed number of VM instances. This must be a positive integer.
                &quot;percent&quot;: 42, # Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%.
              },
              &quot;minReadySec&quot;: 42, # Minimum number of seconds to wait for after a newly created instance becomes available. This value must be from range [0, 3600].
              &quot;minimalAction&quot;: &quot;A String&quot;, # Minimal action to be taken on an instance. Use this option to minimize disruption as much as possible or to apply a more disruptive action than is necessary. - To limit disruption as much as possible, set the minimal action to REFRESH. If your update requires a more disruptive action, Compute Engine performs the necessary action to execute the update. - To apply a more disruptive action than is strictly necessary, set the minimal action to RESTART or REPLACE. For example, Compute Engine does not need to restart a VM to change its metadata. But if your application reads instance metadata only when a VM is restarted, you can set the minimal action to RESTART in order to pick up metadata changes.
              &quot;mostDisruptiveAllowedAction&quot;: &quot;A String&quot;, # Most disruptive action that is allowed to be taken on an instance. You can specify either NONE to forbid any actions, REFRESH to avoid restarting the VM and to limit disruption as much as possible. RESTART to allow actions that can be applied without instance replacing or REPLACE to allow all possible actions. If the Updater determines that the minimal update action needed is more disruptive than most disruptive allowed action you specify it will not perform the update at all.
              &quot;replacementMethod&quot;: &quot;A String&quot;, # What action should be used to replace instances. See minimal_action.REPLACE
              &quot;type&quot;: &quot;A String&quot;, # The type of update process. You can specify either PROACTIVE so that the MIG automatically updates VMs to the latest configurations or OPPORTUNISTIC so that you can select the VMs that you want to update.
            },
            &quot;versions&quot;: [ # Specifies the instance templates used by this managed instance group to create instances. Each version is defined by an instanceTemplate and a name. Every version can appear at most once per instance group. This field overrides the top-level instanceTemplate field. Read more about the relationships between these fields. Exactly one version must leave the targetSize field unset. That version will be applied to all remaining instances. For more information, read about canary updates.
              {
                &quot;instanceTemplate&quot;: &quot;A String&quot;, # The URL of the instance template that is specified for this managed instance group. The group uses this template to create new instances in the managed instance group until the `targetSize` for this version is reached. The templates for existing instances in the group do not change unless you run recreateInstances, run applyUpdatesToInstances, or set the group&#x27;s updatePolicy.type to PROACTIVE; in those cases, existing instances are updated until the `targetSize` for this version is reached.
                &quot;name&quot;: &quot;A String&quot;, # Name of the version. Unique among all versions in the scope of this managed instance group.
                &quot;tag&quot;: &quot;A String&quot;, # Tag describing the version. Used to trigger rollout of a target version even if instance_template remains unchanged. Deprecated in favor of &#x27;name&#x27;.
                &quot;targetSize&quot;: { # Encapsulates numeric value that can be either absolute or relative. # Specifies the intended number of instances to be created from the instanceTemplate. The final number of instances created from the template will be equal to: - If expressed as a fixed number, the minimum of either targetSize.fixed or instanceGroupManager.targetSize is used. - if expressed as a percent, the targetSize would be (targetSize.percent/100 * InstanceGroupManager.targetSize) If there is a remainder, the number is rounded. If unset, this version will update any remaining instances not updated by another version. Read Starting a canary update for more information.
                  &quot;calculated&quot;: 42, # [Output Only] Absolute value of VM instances calculated based on the specific mode. - If the value is fixed, then the calculated value is equal to the fixed value. - If the value is a percent, then the calculated value is percent/100 * targetSize. For example, the calculated value of a 80% of a managed instance group with 150 instances would be (80/100 * 150) = 120 VM instances. If there is a remainder, the number is rounded.
                  &quot;fixed&quot;: 42, # Specifies a fixed number of VM instances. This must be a positive integer.
                  &quot;percent&quot;: 42, # Specifies a percentage of instances between 0 to 100%, inclusive. For example, specify 80 for 80%.
                },
              },
            ],
            &quot;zone&quot;: &quot;A String&quot;, # [Output Only] The URL of a zone where the managed instance group is located (for zonal resources).
          },
        },
      },
      &quot;region&quot;: &quot;A String&quot;, # [Output Only] URL of the region where the resource resides. Only applicable for regional resources. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
      &quot;schedulingPolicy&quot;: { # Policy for handling provisioning and other scheduling-related events. # Policy for handling provisioning and other scheduling-related events.
        &quot;provisioning&quot;: &quot;A String&quot;, # How provisioning of MIGs should be scheduled (coordinated or not)
      },
      &quot;selfLink&quot;: &quot;A String&quot;, # [Output only] Server-defined URL for the resource.
      &quot;selfLinkWithId&quot;: &quot;A String&quot;, # [Output Only] Server-defined URL for this resource with the resource id.
    },
  ],
  &quot;kind&quot;: &quot;compute#multiMigList&quot;, # Type of resource.
  &quot;nextPageToken&quot;: &quot;A String&quot;, # This token allows you to get the next page of results for maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
  &quot;selfLink&quot;: &quot;A String&quot;, # [Output only] Server-defined URL for this resource.
  &quot;unreachables&quot;: [ # [Output only] Unreachable resources.
    &quot;A String&quot;,
  ],
  &quot;warning&quot;: { # Informational warning message.
    &quot;code&quot;: &quot;A String&quot;, # [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
    &quot;data&quot;: [ # [Output Only] Metadata about this warning in key: value format. For example: &quot;data&quot;: [ { &quot;key&quot;: &quot;scope&quot;, &quot;value&quot;: &quot;zones/us-east1-d&quot; }
      {
        &quot;key&quot;: &quot;A String&quot;, # [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
        &quot;value&quot;: &quot;A String&quot;, # [Output Only] A warning data value corresponding to the key.
      },
    ],
    &quot;message&quot;: &quot;A String&quot;, # [Output Only] A human-readable description of the warning code.
  },
}</pre>
</div>

<div class="method">
    <code class="details" id="list_next">list_next()</code>
  <pre>Retrieves the next page of results.

        Args:
          previous_request: The request for the previous page. (required)
          previous_response: The response from the request for the previous page. (required)

        Returns:
          A request object that you can call &#x27;execute()&#x27; on to request the next
          page. Returns None if there are no more items in the collection.
        </pre>
</div>

</body></html>