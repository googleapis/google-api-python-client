<html><body>
<style>

body, h1, h2, h3, div, span, p, pre, a {
  margin: 0;
  padding: 0;
  border: 0;
  font-weight: inherit;
  font-style: inherit;
  font-size: 100%;
  font-family: inherit;
  vertical-align: baseline;
}

body {
  font-size: 13px;
  padding: 1em;
}

h1 {
  font-size: 26px;
  margin-bottom: 1em;
}

h2 {
  font-size: 24px;
  margin-bottom: 1em;
}

h3 {
  font-size: 20px;
  margin-bottom: 1em;
  margin-top: 1em;
}

pre, code {
  line-height: 1.5;
  font-family: Monaco, 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Lucida Console', monospace;
}

pre {
  margin-top: 0.5em;
}

h1, h2, h3, p {
  font-family: Arial, sans serif;
}

h1, h2, h3 {
  border-bottom: solid #CCC 1px;
}

.toc_element {
  margin-top: 0.5em;
}

.firstline {
  margin-left: 2 em;
}

.method  {
  margin-top: 1em;
  border: solid 1px #CCC;
  padding: 1em;
  background: #EEE;
}

.details {
  font-weight: bold;
  font-size: 14px;
}

</style>

<h1><a href="documentai_v1beta3.html">Cloud Document AI API</a> . <a href="documentai_v1beta3.projects.html">projects</a> . <a href="documentai_v1beta3.projects.locations.html">locations</a> . <a href="documentai_v1beta3.projects.locations.processors.html">processors</a> . <a href="documentai_v1beta3.projects.locations.processors.dataset.html">dataset</a></h1>
<h2>Instance Methods</h2>
<p class="toc_element">
  <code><a href="#close">close()</a></code></p>
<p class="firstline">Close httplib2 connections.</p>
<p class="toc_element">
  <code><a href="#getDatasetSchema">getDatasetSchema(name, visibleFieldsOnly=None, x__xgafv=None)</a></code></p>
<p class="firstline">Gets the DatasetSchema of a Dataset.</p>
<p class="toc_element">
  <code><a href="#updateDatasetSchema">updateDatasetSchema(name, body=None, updateMask=None, x__xgafv=None)</a></code></p>
<p class="firstline">Updates a DatasetSchema.</p>
<h3>Method Details</h3>
<div class="method">
    <code class="details" id="close">close()</code>
  <pre>Close httplib2 connections.</pre>
</div>

<div class="method">
    <code class="details" id="getDatasetSchema">getDatasetSchema(name, visibleFieldsOnly=None, x__xgafv=None)</code>
  <pre>Gets the DatasetSchema of a Dataset.

Args:
  name: string, Required. The dataset schema resource name. Format: projects/{project}/locations/{location}/processors/{processor}/dataset/datasetSchema (required)
  visibleFieldsOnly: boolean, If set, only returns the visible fields of the schema.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Dataset Schema.
  &quot;documentSchema&quot;: { # The schema defines the output of the processed document by a processor. # Optional. Schema of the dataset.
    &quot;description&quot;: &quot;A String&quot;, # Description of the schema.
    &quot;displayName&quot;: &quot;A String&quot;, # Display name to show to users.
    &quot;entityTypes&quot;: [ # Entity types of the schema.
      { # EntityType is the wrapper of a label of the corresponding model with detailed attributes and limitations for entity-based processors. Multiple types can also compose a dependency tree to represent nested types.
        &quot;baseTypes&quot;: [ # The entity type that this type is derived from. For now, one and only one should be set.
          &quot;A String&quot;,
        ],
        &quot;displayName&quot;: &quot;A String&quot;, # User defined name for the type.
        &quot;entityTypeMetadata&quot;: { # Metadata about an entity type. # Metadata for the entity type.
          &quot;inactive&quot;: True or False, # Whether the entity type should be considered as &quot;inactive&quot;.
        },
        &quot;enumValues&quot;: { # Defines the a list of enum values. # If specified, lists all the possible values for this entity. This should not be more than a handful of values. If the number of values is &gt;10 or could change frequently use the `EntityType.value_ontology` field and specify a list of all possible values in a value ontology file.
          &quot;values&quot;: [ # The individual values that this enum values type can include.
            &quot;A String&quot;,
          ],
        },
        &quot;name&quot;: &quot;A String&quot;, # Name of the type. It must be unique within the schema file and cannot be a &#x27;Common Type&#x27;. Besides that we use the following naming conventions: - *use `snake_casing`* - name matching is case-sensitive - Maximum 64 characters. - Must start with a letter. - Allowed characters: ASCII letters `[a-z0-9_-]`. (For backward compatibility internal infrastructure and tooling can handle any ascii character) - The `/` is sometimes used to denote a property of a type. For example `line_item/amount`. This convention is deprecated, but will still be honored for backward compatibility.
        &quot;properties&quot;: [ # Description the nested structure, or composition of an entity.
          { # Defines properties that can be part of the entity type.
            &quot;name&quot;: &quot;A String&quot;, # The name of the property. Follows the same guidelines as the EntityType name.
            &quot;occurrenceType&quot;: &quot;A String&quot;, # Occurrence type limits the number of instances an entity type appears in the document.
            &quot;propertyMetadata&quot;: { # Metadata about a property. # Any additional metadata about the property can be added here.
              &quot;inactive&quot;: True or False, # Whether the property should be considered as &quot;inactive&quot;.
            },
            &quot;valueType&quot;: &quot;A String&quot;, # A reference to the value type of the property. This type is subject to the same conventions as the `Entity.base_types` field.
          },
        ],
      },
    ],
    &quot;metadata&quot;: { # Metadata for global schema behavior. # Metadata of the schema.
      &quot;documentAllowMultipleLabels&quot;: True or False, # If true, on a given page, there can be multiple `document` annotations covering it.
      &quot;documentSplitter&quot;: True or False, # If true, a `document` entity type can be applied to subdocument ( splitting). Otherwise, it can only be applied to the entire document (classification).
      &quot;prefixedNamingOnProperties&quot;: True or False, # If set, all the nested entities must be prefixed with the parents.
      &quot;skipNamingValidation&quot;: True or False, # If set, we will skip the naming format validation in the schema. So the string values in `DocumentSchema.EntityType.name` and `DocumentSchema.EntityType.Property.name` will not be checked.
    },
  },
  &quot;name&quot;: &quot;A String&quot;, # Dataset schema resource name. Format: `projects/{project}/locations/{location}/processors/{processor}/dataset/datasetSchema`
}</pre>
</div>

<div class="method">
    <code class="details" id="updateDatasetSchema">updateDatasetSchema(name, body=None, updateMask=None, x__xgafv=None)</code>
  <pre>Updates a DatasetSchema.

Args:
  name: string, Dataset schema resource name. Format: `projects/{project}/locations/{location}/processors/{processor}/dataset/datasetSchema` (required)
  body: object, The request body.
    The object takes the form of:

{ # Dataset Schema.
  &quot;documentSchema&quot;: { # The schema defines the output of the processed document by a processor. # Optional. Schema of the dataset.
    &quot;description&quot;: &quot;A String&quot;, # Description of the schema.
    &quot;displayName&quot;: &quot;A String&quot;, # Display name to show to users.
    &quot;entityTypes&quot;: [ # Entity types of the schema.
      { # EntityType is the wrapper of a label of the corresponding model with detailed attributes and limitations for entity-based processors. Multiple types can also compose a dependency tree to represent nested types.
        &quot;baseTypes&quot;: [ # The entity type that this type is derived from. For now, one and only one should be set.
          &quot;A String&quot;,
        ],
        &quot;displayName&quot;: &quot;A String&quot;, # User defined name for the type.
        &quot;entityTypeMetadata&quot;: { # Metadata about an entity type. # Metadata for the entity type.
          &quot;inactive&quot;: True or False, # Whether the entity type should be considered as &quot;inactive&quot;.
        },
        &quot;enumValues&quot;: { # Defines the a list of enum values. # If specified, lists all the possible values for this entity. This should not be more than a handful of values. If the number of values is &gt;10 or could change frequently use the `EntityType.value_ontology` field and specify a list of all possible values in a value ontology file.
          &quot;values&quot;: [ # The individual values that this enum values type can include.
            &quot;A String&quot;,
          ],
        },
        &quot;name&quot;: &quot;A String&quot;, # Name of the type. It must be unique within the schema file and cannot be a &#x27;Common Type&#x27;. Besides that we use the following naming conventions: - *use `snake_casing`* - name matching is case-sensitive - Maximum 64 characters. - Must start with a letter. - Allowed characters: ASCII letters `[a-z0-9_-]`. (For backward compatibility internal infrastructure and tooling can handle any ascii character) - The `/` is sometimes used to denote a property of a type. For example `line_item/amount`. This convention is deprecated, but will still be honored for backward compatibility.
        &quot;properties&quot;: [ # Description the nested structure, or composition of an entity.
          { # Defines properties that can be part of the entity type.
            &quot;name&quot;: &quot;A String&quot;, # The name of the property. Follows the same guidelines as the EntityType name.
            &quot;occurrenceType&quot;: &quot;A String&quot;, # Occurrence type limits the number of instances an entity type appears in the document.
            &quot;propertyMetadata&quot;: { # Metadata about a property. # Any additional metadata about the property can be added here.
              &quot;inactive&quot;: True or False, # Whether the property should be considered as &quot;inactive&quot;.
            },
            &quot;valueType&quot;: &quot;A String&quot;, # A reference to the value type of the property. This type is subject to the same conventions as the `Entity.base_types` field.
          },
        ],
      },
    ],
    &quot;metadata&quot;: { # Metadata for global schema behavior. # Metadata of the schema.
      &quot;documentAllowMultipleLabels&quot;: True or False, # If true, on a given page, there can be multiple `document` annotations covering it.
      &quot;documentSplitter&quot;: True or False, # If true, a `document` entity type can be applied to subdocument ( splitting). Otherwise, it can only be applied to the entire document (classification).
      &quot;prefixedNamingOnProperties&quot;: True or False, # If set, all the nested entities must be prefixed with the parents.
      &quot;skipNamingValidation&quot;: True or False, # If set, we will skip the naming format validation in the schema. So the string values in `DocumentSchema.EntityType.name` and `DocumentSchema.EntityType.Property.name` will not be checked.
    },
  },
  &quot;name&quot;: &quot;A String&quot;, # Dataset schema resource name. Format: `projects/{project}/locations/{location}/processors/{processor}/dataset/datasetSchema`
}

  updateMask: string, The update mask applies to the resource.
  x__xgafv: string, V1 error format.
    Allowed values
      1 - v1 error format
      2 - v2 error format

Returns:
  An object of the form:

    { # Dataset Schema.
  &quot;documentSchema&quot;: { # The schema defines the output of the processed document by a processor. # Optional. Schema of the dataset.
    &quot;description&quot;: &quot;A String&quot;, # Description of the schema.
    &quot;displayName&quot;: &quot;A String&quot;, # Display name to show to users.
    &quot;entityTypes&quot;: [ # Entity types of the schema.
      { # EntityType is the wrapper of a label of the corresponding model with detailed attributes and limitations for entity-based processors. Multiple types can also compose a dependency tree to represent nested types.
        &quot;baseTypes&quot;: [ # The entity type that this type is derived from. For now, one and only one should be set.
          &quot;A String&quot;,
        ],
        &quot;displayName&quot;: &quot;A String&quot;, # User defined name for the type.
        &quot;entityTypeMetadata&quot;: { # Metadata about an entity type. # Metadata for the entity type.
          &quot;inactive&quot;: True or False, # Whether the entity type should be considered as &quot;inactive&quot;.
        },
        &quot;enumValues&quot;: { # Defines the a list of enum values. # If specified, lists all the possible values for this entity. This should not be more than a handful of values. If the number of values is &gt;10 or could change frequently use the `EntityType.value_ontology` field and specify a list of all possible values in a value ontology file.
          &quot;values&quot;: [ # The individual values that this enum values type can include.
            &quot;A String&quot;,
          ],
        },
        &quot;name&quot;: &quot;A String&quot;, # Name of the type. It must be unique within the schema file and cannot be a &#x27;Common Type&#x27;. Besides that we use the following naming conventions: - *use `snake_casing`* - name matching is case-sensitive - Maximum 64 characters. - Must start with a letter. - Allowed characters: ASCII letters `[a-z0-9_-]`. (For backward compatibility internal infrastructure and tooling can handle any ascii character) - The `/` is sometimes used to denote a property of a type. For example `line_item/amount`. This convention is deprecated, but will still be honored for backward compatibility.
        &quot;properties&quot;: [ # Description the nested structure, or composition of an entity.
          { # Defines properties that can be part of the entity type.
            &quot;name&quot;: &quot;A String&quot;, # The name of the property. Follows the same guidelines as the EntityType name.
            &quot;occurrenceType&quot;: &quot;A String&quot;, # Occurrence type limits the number of instances an entity type appears in the document.
            &quot;propertyMetadata&quot;: { # Metadata about a property. # Any additional metadata about the property can be added here.
              &quot;inactive&quot;: True or False, # Whether the property should be considered as &quot;inactive&quot;.
            },
            &quot;valueType&quot;: &quot;A String&quot;, # A reference to the value type of the property. This type is subject to the same conventions as the `Entity.base_types` field.
          },
        ],
      },
    ],
    &quot;metadata&quot;: { # Metadata for global schema behavior. # Metadata of the schema.
      &quot;documentAllowMultipleLabels&quot;: True or False, # If true, on a given page, there can be multiple `document` annotations covering it.
      &quot;documentSplitter&quot;: True or False, # If true, a `document` entity type can be applied to subdocument ( splitting). Otherwise, it can only be applied to the entire document (classification).
      &quot;prefixedNamingOnProperties&quot;: True or False, # If set, all the nested entities must be prefixed with the parents.
      &quot;skipNamingValidation&quot;: True or False, # If set, we will skip the naming format validation in the schema. So the string values in `DocumentSchema.EntityType.name` and `DocumentSchema.EntityType.Property.name` will not be checked.
    },
  },
  &quot;name&quot;: &quot;A String&quot;, # Dataset schema resource name. Format: `projects/{project}/locations/{location}/processors/{processor}/dataset/datasetSchema`
}</pre>
</div>

</body></html>